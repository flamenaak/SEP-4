
FreeRTOS-Test2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000088  00800100  00002e1e  00002eb2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e1e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000765  00800188  00800188  00002f3a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002f3a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002f6c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000540  00000000  00000000  00002fac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007428  00000000  00000000  000034ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001c68  00000000  00000000  0000a914  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003766  00000000  00000000  0000c57c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001164  00000000  00000000  0000fce4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000020f8  00000000  00000000  00010e48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006685  00000000  00000000  00012f40  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006e0  00000000  00000000  000195c5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 48 00 	jmp	0x90	; 0x90 <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      34:	0c 94 85 08 	jmp	0x110a	; 0x110a <__vector_13>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 2e 06 	jmp	0xc5c	; 0xc5c <__vector_16>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 9c 09 	jmp	0x1338	; 0x1338 <__vector_20>
      54:	0c 94 da 09 	jmp	0x13b4	; 0x13b4 <__vector_21>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 22 0a 	jmp	0x1444	; 0x1444 <__vector_28>
      74:	0c 94 60 0a 	jmp	0x14c0	; 0x14c0 <__vector_29>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	c2 14       	cp	r12, r2
      7e:	c2 14       	cp	r12, r2
      80:	c2 14       	cp	r12, r2
      82:	fd 14       	cp	r15, r13
      84:	eb 14       	cp	r14, r11
      86:	fa 14       	cp	r15, r10
      88:	c2 14       	cp	r12, r2
      8a:	c2 14       	cp	r12, r2
      8c:	fd 14       	cp	r15, r13
      8e:	eb 14       	cp	r14, r11

00000090 <__ctors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d8 e0       	ldi	r29, 0x08	; 8
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	ee e1       	ldi	r30, 0x1E	; 30
      a4:	fe e2       	ldi	r31, 0x2E	; 46
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
      a8:	05 90       	lpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a8 38       	cpi	r26, 0x88	; 136
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
      b2:	28 e0       	ldi	r18, 0x08	; 8
      b4:	a8 e8       	ldi	r26, 0x88	; 136
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	ad 3e       	cpi	r26, 0xED	; 237
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 6b 05 	call	0xad6	; 0xad6 <main>
      c6:	0c 94 0d 17 	jmp	0x2e1a	; 0x2e1a <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <vTimeout>:
/************************************************************************/
/* System Timer for SENDER TIMEOUT                                      */
/************************************************************************/
void vTimeout(TimerHandle_t xTimer);
void vTimeout(TimerHandle_t xTimer) {
	com_send_bytes((&current_message), 1);
      ce:	61 e0       	ldi	r22, 0x01	; 1
      d0:	8e e5       	ldi	r24, 0x5E	; 94
      d2:	93 e0       	ldi	r25, 0x03	; 3
      d4:	0e 94 57 06 	call	0xcae	; 0xcae <com_send_bytes>
      d8:	08 95       	ret

000000da <obstacles_task>:



//-----------------------------------------

void obstacles_task(void *pvParameters){
      da:	cf 93       	push	r28
      dc:	df 93       	push	r29
      de:	00 d0       	rcall	.+0      	; 0xe0 <obstacles_task+0x6>
      e0:	00 d0       	rcall	.+0      	; 0xe2 <obstacles_task+0x8>
      e2:	cd b7       	in	r28, 0x3d	; 61
      e4:	de b7       	in	r29, 0x3e	; 62
 	#if (configUSE_APPLICATION_TASK_TAG == 1)
			vTaskSetApplicationTaskTag( NULL, ( void * ) 1 ); // Set task no to be used for tracing with R2R-Network
      e6:	61 e0       	ldi	r22, 0x01	; 1
      e8:	70 e0       	ldi	r23, 0x00	; 0
      ea:	80 e0       	ldi	r24, 0x00	; 0
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 ba 10 	call	0x2174	; 0x2174 <vTaskSetApplicationTaskTag>
	#endif
	while(1){		
					if(stop == 0){
							if(obstacles[car[0]][car[1]-1] == 0){
      f2:	0f 2e       	mov	r0, r31
      f4:	f1 e9       	ldi	r31, 0x91	; 145
      f6:	6f 2e       	mov	r6, r31
      f8:	f1 e0       	ldi	r31, 0x01	; 1
      fa:	7f 2e       	mov	r7, r31
      fc:	f0 2d       	mov	r31, r0
											myMatrix[car1[0]][car1[1]] = 1;
											xSemaphoreGive(xMutex);
										}
									}
									else{
										stop = 1;
      fe:	33 24       	eor	r3, r3
     100:	33 94       	inc	r3
     102:	21 2c       	mov	r2, r1
     104:	0f 2e       	mov	r0, r31
     106:	ff ea       	ldi	r31, 0xAF	; 175
     108:	af 2e       	mov	r10, r31
     10a:	f2 e0       	ldi	r31, 0x02	; 2
     10c:	bf 2e       	mov	r11, r31
     10e:	f0 2d       	mov	r31, r0
													myMatrix[i][1+j] = obstacles[i][j];
												}
											}
											for (int i = 1; i < 14; i++)
											{
												myMatrix[0][0] = rand()%2;
     110:	0f 2e       	mov	r0, r31
     112:	f5 e9       	ldi	r31, 0x95	; 149
     114:	8f 2e       	mov	r8, r31
     116:	f1 e0       	ldi	r31, 0x01	; 1
     118:	9f 2e       	mov	r9, r31
     11a:	f0 2d       	mov	r31, r0
     11c:	0f 2e       	mov	r0, r31
     11e:	fd ea       	ldi	r31, 0xAD	; 173
     120:	cf 2e       	mov	r12, r31
     122:	f2 e0       	ldi	r31, 0x02	; 2
     124:	df 2e       	mov	r13, r31
     126:	f0 2d       	mov	r31, r0
												if(count < 2 || i == 13) {
													myMatrix[i][0] = rand()%2;
													if(myMatrix[i][0] == 1)
													count++;
													if(i % 4 == 0) count = 0;
     128:	19 82       	std	Y+1, r1	; 0x01
     12a:	1a 82       	std	Y+2, r1	; 0x02
void obstacles_task(void *pvParameters){
 	#if (configUSE_APPLICATION_TASK_TAG == 1)
			vTaskSetApplicationTaskTag( NULL, ( void * ) 1 ); // Set task no to be used for tracing with R2R-Network
	#endif
	while(1){		
					if(stop == 0){
     12c:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <stop>
     130:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <stop+0x1>
     134:	89 2b       	or	r24, r25
     136:	09 f0       	breq	.+2      	; 0x13a <obstacles_task+0x60>
     138:	f2 c0       	rjmp	.+484    	; 0x31e <obstacles_task+0x244>
							if(obstacles[car[0]][car[1]-1] == 0){
     13a:	d3 01       	movw	r26, r6
     13c:	8d 91       	ld	r24, X+
     13e:	9c 91       	ld	r25, X
     140:	11 97       	sbiw	r26, 0x01	; 1
     142:	9c 01       	movw	r18, r24
     144:	22 0f       	add	r18, r18
     146:	33 1f       	adc	r19, r19
     148:	88 0f       	add	r24, r24
     14a:	99 1f       	adc	r25, r25
     14c:	88 0f       	add	r24, r24
     14e:	99 1f       	adc	r25, r25
     150:	88 0f       	add	r24, r24
     152:	99 1f       	adc	r25, r25
     154:	82 0f       	add	r24, r18
     156:	93 1f       	adc	r25, r19
     158:	12 96       	adiw	r26, 0x02	; 2
     15a:	ed 91       	ld	r30, X+
     15c:	fc 91       	ld	r31, X
     15e:	13 97       	sbiw	r26, 0x03	; 3
     160:	8e 0f       	add	r24, r30
     162:	9f 1f       	adc	r25, r31
     164:	fc 01       	movw	r30, r24
     166:	e4 55       	subi	r30, 0x54	; 84
     168:	fd 4f       	sbci	r31, 0xFD	; 253
     16a:	80 81       	ld	r24, Z
     16c:	81 11       	cpse	r24, r1
     16e:	d3 c0       	rjmp	.+422    	; 0x316 <obstacles_task+0x23c>
								if(xSemaphoreTake(xMutex, portMAX_DELAY)){
     170:	20 e0       	ldi	r18, 0x00	; 0
     172:	4f ef       	ldi	r20, 0xFF	; 255
     174:	5f ef       	ldi	r21, 0xFF	; 255
     176:	60 e0       	ldi	r22, 0x00	; 0
     178:	70 e0       	ldi	r23, 0x00	; 0
     17a:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <xMutex>
     17e:	90 91 61 03 	lds	r25, 0x0361	; 0x800361 <xMutex+0x1>
     182:	0e 94 c7 0c 	call	0x198e	; 0x198e <xQueueGenericReceive>
     186:	88 23       	and	r24, r24
     188:	09 f4       	brne	.+2      	; 0x18c <obstacles_task+0xb2>
     18a:	c9 c0       	rjmp	.+402    	; 0x31e <obstacles_task+0x244>
     18c:	ed ea       	ldi	r30, 0xAD	; 173
     18e:	f2 e0       	ldi	r31, 0x02	; 2
     190:	fc 83       	std	Y+4, r31	; 0x04
     192:	eb 83       	std	Y+3, r30	; 0x03
     194:	47 e9       	ldi	r20, 0x97	; 151
     196:	51 e0       	ldi	r21, 0x01	; 1
     198:	bf 01       	movw	r22, r30
     19a:	cf 01       	movw	r24, r30
     19c:	0f c0       	rjmp	.+30     	; 0x1bc <obstacles_task+0xe2>
											int count = 0;
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													myMatrix[i][1+j] = obstacles[i][j];
     19e:	8d 91       	ld	r24, X+
     1a0:	90 e0       	ldi	r25, 0x00	; 0
     1a2:	81 93       	st	Z+, r24
     1a4:	91 93       	st	Z+, r25
					if(stop == 0){
							if(obstacles[car[0]][car[1]-1] == 0){
								if(xSemaphoreTake(xMutex, portMAX_DELAY)){
											int count = 0;
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
     1a6:	e2 17       	cp	r30, r18
     1a8:	f3 07       	cpc	r31, r19
     1aa:	c9 f7       	brne	.-14     	; 0x19e <obstacles_task+0xc4>
     1ac:	c8 01       	movw	r24, r16
     1ae:	66 5f       	subi	r22, 0xF6	; 246
     1b0:	7f 4f       	sbci	r23, 0xFF	; 255
     1b2:	4c 5e       	subi	r20, 0xEC	; 236
     1b4:	5f 4f       	sbci	r21, 0xFF	; 255
	while(1){		
					if(stop == 0){
							if(obstacles[car[0]][car[1]-1] == 0){
								if(xSemaphoreTake(xMutex, portMAX_DELAY)){
											int count = 0;
											for(int i = 0; i < 14; i++){
     1b6:	4a 15       	cp	r20, r10
     1b8:	5b 05       	cpc	r21, r11
     1ba:	39 f0       	breq	.+14     	; 0x1ca <obstacles_task+0xf0>
     1bc:	9a 01       	movw	r18, r20
     1be:	2e 5e       	subi	r18, 0xEE	; 238
     1c0:	3f 4f       	sbci	r19, 0xFF	; 255



//-----------------------------------------

void obstacles_task(void *pvParameters){
     1c2:	fa 01       	movw	r30, r20
     1c4:	db 01       	movw	r26, r22
     1c6:	8c 01       	movw	r16, r24
     1c8:	ea cf       	rjmp	.-44     	; 0x19e <obstacles_task+0xc4>
     1ca:	09 ea       	ldi	r16, 0xA9	; 169
     1cc:	11 e0       	ldi	r17, 0x01	; 1
	while(1){		
					if(stop == 0){
							if(obstacles[car[0]][car[1]-1] == 0){
								if(xSemaphoreTake(xMutex, portMAX_DELAY)){
											int count = 0;
											for(int i = 0; i < 14; i++){
     1ce:	43 2c       	mov	r4, r3
     1d0:	52 2c       	mov	r5, r2
     1d2:	e1 2c       	mov	r14, r1
     1d4:	f1 2c       	mov	r15, r1
     1d6:	1c 83       	std	Y+4, r17	; 0x04
     1d8:	0b 83       	std	Y+3, r16	; 0x03
     1da:	8c 01       	movw	r16, r24
													myMatrix[i][1+j] = obstacles[i][j];
												}
											}
											for (int i = 1; i < 14; i++)
											{
												myMatrix[0][0] = rand()%2;
     1dc:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <rand>
     1e0:	81 70       	andi	r24, 0x01	; 1
     1e2:	90 78       	andi	r25, 0x80	; 128
     1e4:	99 23       	and	r25, r25
     1e6:	24 f4       	brge	.+8      	; 0x1f0 <obstacles_task+0x116>
     1e8:	01 97       	sbiw	r24, 0x01	; 1
     1ea:	8e 6f       	ori	r24, 0xFE	; 254
     1ec:	9f 6f       	ori	r25, 0xFF	; 255
     1ee:	01 96       	adiw	r24, 0x01	; 1
     1f0:	d4 01       	movw	r26, r8
     1f2:	8d 93       	st	X+, r24
     1f4:	9c 93       	st	X, r25
												if(count < 2 || i == 13) {
     1f6:	b2 e0       	ldi	r27, 0x02	; 2
     1f8:	eb 16       	cp	r14, r27
     1fa:	f1 04       	cpc	r15, r1
     1fc:	2c f0       	brlt	.+10     	; 0x208 <obstacles_task+0x12e>
     1fe:	ed e0       	ldi	r30, 0x0D	; 13
     200:	4e 16       	cp	r4, r30
     202:	51 04       	cpc	r5, r1
     204:	e1 f4       	brne	.+56     	; 0x23e <obstacles_task+0x164>
     206:	90 c0       	rjmp	.+288    	; 0x328 <obstacles_task+0x24e>
													myMatrix[i][0] = rand()%2;
     208:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <rand>
     20c:	81 70       	andi	r24, 0x01	; 1
     20e:	90 78       	andi	r25, 0x80	; 128
     210:	99 23       	and	r25, r25
     212:	24 f4       	brge	.+8      	; 0x21c <obstacles_task+0x142>
     214:	01 97       	sbiw	r24, 0x01	; 1
     216:	8e 6f       	ori	r24, 0xFE	; 254
     218:	9f 6f       	ori	r25, 0xFF	; 255
     21a:	01 96       	adiw	r24, 0x01	; 1
     21c:	ab 81       	ldd	r26, Y+3	; 0x03
     21e:	bc 81       	ldd	r27, Y+4	; 0x04
     220:	8d 93       	st	X+, r24
     222:	9c 93       	st	X, r25
													if(myMatrix[i][0] == 1)
     224:	01 97       	sbiw	r24, 0x01	; 1
     226:	19 f4       	brne	.+6      	; 0x22e <obstacles_task+0x154>
													count++;
     228:	bf ef       	ldi	r27, 0xFF	; 255
     22a:	eb 1a       	sub	r14, r27
     22c:	fb 0a       	sbc	r15, r27
													if(i % 4 == 0) count = 0;
     22e:	c2 01       	movw	r24, r4
     230:	83 70       	andi	r24, 0x03	; 3
     232:	99 27       	eor	r25, r25
     234:	89 2b       	or	r24, r25
     236:	39 f4       	brne	.+14     	; 0x246 <obstacles_task+0x16c>
     238:	e9 80       	ldd	r14, Y+1	; 0x01
     23a:	fa 80       	ldd	r15, Y+2	; 0x02
     23c:	04 c0       	rjmp	.+8      	; 0x246 <obstacles_task+0x16c>
												}
												else {
													myMatrix[i][0] = 0;
     23e:	eb 81       	ldd	r30, Y+3	; 0x03
     240:	fc 81       	ldd	r31, Y+4	; 0x04
     242:	11 82       	std	Z+1, r1	; 0x01
     244:	10 82       	st	Z, r1
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													myMatrix[i][1+j] = obstacles[i][j];
												}
											}
											for (int i = 1; i < 14; i++)
     246:	ff ef       	ldi	r31, 0xFF	; 255
     248:	4f 1a       	sub	r4, r31
     24a:	5f 0a       	sbc	r5, r31
     24c:	8b 81       	ldd	r24, Y+3	; 0x03
     24e:	9c 81       	ldd	r25, Y+4	; 0x04
     250:	44 96       	adiw	r24, 0x14	; 20
     252:	9c 83       	std	Y+4, r25	; 0x04
     254:	8b 83       	std	Y+3, r24	; 0x03
     256:	9e e0       	ldi	r25, 0x0E	; 14
     258:	49 16       	cp	r4, r25
     25a:	51 04       	cpc	r5, r1
     25c:	09 f0       	breq	.+2      	; 0x260 <obstacles_task+0x186>
     25e:	be cf       	rjmp	.-132    	; 0x1dc <obstacles_task+0x102>
     260:	1c 83       	std	Y+4, r17	; 0x04
     262:	0b 83       	std	Y+3, r16	; 0x03
     264:	a4 01       	movw	r20, r8
     266:	c8 01       	movw	r24, r16
     268:	0d c0       	rjmp	.+26     	; 0x284 <obstacles_task+0x1aa>
													myMatrix[i][0] = 0;
												}
											}
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													obstacles[i][j] = myMatrix[i][j];
     26a:	80 81       	ld	r24, Z
     26c:	32 96       	adiw	r30, 0x02	; 2
     26e:	8d 93       	st	X+, r24
												else {
													myMatrix[i][0] = 0;
												}
											}
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
     270:	e2 17       	cp	r30, r18
     272:	f3 07       	cpc	r31, r19
     274:	d1 f7       	brne	.-12     	; 0x26a <obstacles_task+0x190>
     276:	cb 01       	movw	r24, r22
     278:	4c 5e       	subi	r20, 0xEC	; 236
     27a:	5f 4f       	sbci	r21, 0xFF	; 255
     27c:	0a 96       	adiw	r24, 0x0a	; 10
												}
												else {
													myMatrix[i][0] = 0;
												}
											}
											for(int i = 0; i < 14; i++){
     27e:	4c 15       	cp	r20, r12
     280:	5d 05       	cpc	r21, r13
     282:	39 f0       	breq	.+14     	; 0x292 <obstacles_task+0x1b8>
     284:	9a 01       	movw	r18, r20
     286:	2e 5e       	subi	r18, 0xEE	; 238
     288:	3f 4f       	sbci	r19, 0xFF	; 255
												myMatrix[0][0] = rand()%2;
												if(count < 2 || i == 13) {
													myMatrix[i][0] = rand()%2;
													if(myMatrix[i][0] == 1)
													count++;
													if(i % 4 == 0) count = 0;
     28a:	dc 01       	movw	r26, r24
     28c:	fa 01       	movw	r30, r20
     28e:	bc 01       	movw	r22, r24
     290:	ec cf       	rjmp	.-40     	; 0x26a <obstacles_task+0x190>
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													obstacles[i][j] = myMatrix[i][j];
												}
											}
											myMatrix[car[0]][car[1]] = 1;
     292:	d3 01       	movw	r26, r6
     294:	8d 91       	ld	r24, X+
     296:	9c 91       	ld	r25, X
     298:	11 97       	sbiw	r26, 0x01	; 1
     29a:	fc 01       	movw	r30, r24
     29c:	ee 0f       	add	r30, r30
     29e:	ff 1f       	adc	r31, r31
     2a0:	88 0f       	add	r24, r24
     2a2:	99 1f       	adc	r25, r25
     2a4:	88 0f       	add	r24, r24
     2a6:	99 1f       	adc	r25, r25
     2a8:	88 0f       	add	r24, r24
     2aa:	99 1f       	adc	r25, r25
     2ac:	e8 0f       	add	r30, r24
     2ae:	f9 1f       	adc	r31, r25
     2b0:	12 96       	adiw	r26, 0x02	; 2
     2b2:	8d 91       	ld	r24, X+
     2b4:	9c 91       	ld	r25, X
     2b6:	13 97       	sbiw	r26, 0x03	; 3
     2b8:	e8 0f       	add	r30, r24
     2ba:	f9 1f       	adc	r31, r25
     2bc:	ee 0f       	add	r30, r30
     2be:	ff 1f       	adc	r31, r31
     2c0:	eb 56       	subi	r30, 0x6B	; 107
     2c2:	fe 4f       	sbci	r31, 0xFE	; 254
     2c4:	30 82       	st	Z, r3
     2c6:	21 82       	std	Z+1, r2	; 0x01
											myMatrix[car1[0]][car1[1]] = 1;
     2c8:	ed e8       	ldi	r30, 0x8D	; 141
     2ca:	f1 e0       	ldi	r31, 0x01	; 1
     2cc:	80 81       	ld	r24, Z
     2ce:	91 81       	ldd	r25, Z+1	; 0x01
     2d0:	fc 01       	movw	r30, r24
     2d2:	ee 0f       	add	r30, r30
     2d4:	ff 1f       	adc	r31, r31
     2d6:	88 0f       	add	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	88 0f       	add	r24, r24
     2dc:	99 1f       	adc	r25, r25
     2de:	88 0f       	add	r24, r24
     2e0:	99 1f       	adc	r25, r25
     2e2:	e8 0f       	add	r30, r24
     2e4:	f9 1f       	adc	r31, r25
     2e6:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <car1+0x2>
     2ea:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <car1+0x3>
     2ee:	e8 0f       	add	r30, r24
     2f0:	f9 1f       	adc	r31, r25
     2f2:	ee 0f       	add	r30, r30
     2f4:	ff 1f       	adc	r31, r31
     2f6:	eb 56       	subi	r30, 0x6B	; 107
     2f8:	fe 4f       	sbci	r31, 0xFE	; 254
     2fa:	30 82       	st	Z, r3
     2fc:	21 82       	std	Z+1, r2	; 0x01
											xSemaphoreGive(xMutex);
     2fe:	20 e0       	ldi	r18, 0x00	; 0
     300:	40 e0       	ldi	r20, 0x00	; 0
     302:	50 e0       	ldi	r21, 0x00	; 0
     304:	60 e0       	ldi	r22, 0x00	; 0
     306:	70 e0       	ldi	r23, 0x00	; 0
     308:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <xMutex>
     30c:	90 91 61 03 	lds	r25, 0x0361	; 0x800361 <xMutex+0x1>
     310:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
     314:	04 c0       	rjmp	.+8      	; 0x31e <obstacles_task+0x244>
										}
									}
									else{
										stop = 1;
     316:	30 92 8b 01 	sts	0x018B, r3	; 0x80018b <stop>
     31a:	20 92 8c 01 	sts	0x018C, r2	; 0x80018c <stop+0x1>
									}
						}
						vTaskDelay(1000);
     31e:	88 ee       	ldi	r24, 0xE8	; 232
     320:	93 e0       	ldi	r25, 0x03	; 3
     322:	0e 94 71 10 	call	0x20e2	; 0x20e2 <vTaskDelay>
	}
     326:	02 cf       	rjmp	.-508    	; 0x12c <obstacles_task+0x52>
											}
											for (int i = 1; i < 14; i++)
											{
												myMatrix[0][0] = rand()%2;
												if(count < 2 || i == 13) {
													myMatrix[i][0] = rand()%2;
     328:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <rand>
     32c:	81 70       	andi	r24, 0x01	; 1
     32e:	90 78       	andi	r25, 0x80	; 128
     330:	99 23       	and	r25, r25
     332:	24 f4       	brge	.+8      	; 0x33c <obstacles_task+0x262>
     334:	01 97       	sbiw	r24, 0x01	; 1
     336:	8e 6f       	ori	r24, 0xFE	; 254
     338:	9f 6f       	ori	r25, 0xFF	; 255
     33a:	01 96       	adiw	r24, 0x01	; 1
     33c:	ab 81       	ldd	r26, Y+3	; 0x03
     33e:	bc 81       	ldd	r27, Y+4	; 0x04
     340:	8d 93       	st	X+, r24
     342:	9c 93       	st	X, r25
													if(myMatrix[i][0] == 1)
     344:	01 97       	sbiw	r24, 0x01	; 1
     346:	09 f0       	breq	.+2      	; 0x34a <obstacles_task+0x270>
     348:	8b cf       	rjmp	.-234    	; 0x260 <obstacles_task+0x186>
     34a:	6e cf       	rjmp	.-292    	; 0x228 <obstacles_task+0x14e>

0000034c <joystickSampler_task>:
				vTaskDelay(75);		
	}
}
//-----------------------------------------
void joystickSampler_task(void *pvParameters)
{
     34c:	cf 93       	push	r28
     34e:	df 93       	push	r29
     350:	00 d0       	rcall	.+0      	; 0x352 <joystickSampler_task+0x6>
     352:	00 d0       	rcall	.+0      	; 0x354 <joystickSampler_task+0x8>
     354:	00 d0       	rcall	.+0      	; 0x356 <joystickSampler_task+0xa>
     356:	cd b7       	in	r28, 0x3d	; 61
     358:	de b7       	in	r29, 0x3e	; 62
	#if (configUSE_APPLICATION_TASK_TAG == 1)
			vTaskSetApplicationTaskTag( NULL, ( void * ) 6 ); // Set task no to be used for tracing with R2R-Network
     35a:	66 e0       	ldi	r22, 0x06	; 6
     35c:	70 e0       	ldi	r23, 0x00	; 0
     35e:	80 e0       	ldi	r24, 0x00	; 0
     360:	90 e0       	ldi	r25, 0x00	; 0
     362:	0e 94 ba 10 	call	0x2174	; 0x2174 <vTaskSetApplicationTaskTag>
				xQueueSend(xInputQueue, (void*)&inp, portMAX_DELAY); //left
			}
		}
		else{
			if((~PIND & (1<<PIND3)) != 0){
				restart1 = 1;
     366:	ee 24       	eor	r14, r14
     368:	e3 94       	inc	r14
     36a:	f1 2c       	mov	r15, r1
	struct input inp;
	while(1)
	{
		if(stop == 0)
		{
			inp.car[0] = car[0];
     36c:	01 e9       	ldi	r16, 0x91	; 145
     36e:	11 e0       	ldi	r17, 0x01	; 1
			if((~PINC & (1<<PINC6)) != 0){
				inp.direction = 1;
				xQueueSend(xInputQueue, (void*)&inp, portMAX_DELAY); //up
			}
			if((~PINC & (1<<PINC7)) != 0){
				inp.direction = 3;
     370:	0f 2e       	mov	r0, r31
     372:	f3 e0       	ldi	r31, 0x03	; 3
     374:	cf 2e       	mov	r12, r31
     376:	d1 2c       	mov	r13, r1
     378:	f0 2d       	mov	r31, r0
			if((~PINC & (1<<PINC0)) != 0){
				inp.direction = 0;
				xQueueSend(xInputQueue, (void*)&inp , portMAX_DELAY); //down
			}
			if((~PINC & (1<<PINC1)) != 0){
				inp.direction = 2;
     37a:	68 94       	set
     37c:	aa 24       	eor	r10, r10
     37e:	a1 f8       	bld	r10, 1
     380:	b1 2c       	mov	r11, r1
			vTaskSetApplicationTaskTag( NULL, ( void * ) 6 ); // Set task no to be used for tracing with R2R-Network
	#endif
	struct input inp;
	while(1)
	{
		if(stop == 0)
     382:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <stop>
     386:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <stop+0x1>
     38a:	89 2b       	or	r24, r25
     38c:	09 f0       	breq	.+2      	; 0x390 <joystickSampler_task+0x44>
     38e:	4a c0       	rjmp	.+148    	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
		{
			inp.car[0] = car[0];
     390:	f8 01       	movw	r30, r16
     392:	80 81       	ld	r24, Z
     394:	91 81       	ldd	r25, Z+1	; 0x01
     396:	9c 83       	std	Y+4, r25	; 0x04
     398:	8b 83       	std	Y+3, r24	; 0x03
			inp.car[1] = car[1];
     39a:	82 81       	ldd	r24, Z+2	; 0x02
     39c:	93 81       	ldd	r25, Z+3	; 0x03
     39e:	9e 83       	std	Y+6, r25	; 0x06
     3a0:	8d 83       	std	Y+5, r24	; 0x05
			if((~PINC & (1<<PINC0)) != 0){
     3a2:	30 99       	sbic	0x06, 0	; 6
     3a4:	0e c0       	rjmp	.+28     	; 0x3c2 <joystickSampler_task+0x76>
				inp.direction = 0;
     3a6:	1a 82       	std	Y+2, r1	; 0x02
     3a8:	19 82       	std	Y+1, r1	; 0x01
				xQueueSend(xInputQueue, (void*)&inp , portMAX_DELAY); //down
     3aa:	20 e0       	ldi	r18, 0x00	; 0
     3ac:	4f ef       	ldi	r20, 0xFF	; 255
     3ae:	5f ef       	ldi	r21, 0xFF	; 255
     3b0:	be 01       	movw	r22, r28
     3b2:	6f 5f       	subi	r22, 0xFF	; 255
     3b4:	7f 4f       	sbci	r23, 0xFF	; 255
     3b6:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <xInputQueue>
     3ba:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <xInputQueue+0x1>
     3be:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
			}
			if((~PINC & (1<<PINC1)) != 0){
     3c2:	31 99       	sbic	0x06, 1	; 6
     3c4:	0e c0       	rjmp	.+28     	; 0x3e2 <joystickSampler_task+0x96>
				inp.direction = 2;
     3c6:	ba 82       	std	Y+2, r11	; 0x02
     3c8:	a9 82       	std	Y+1, r10	; 0x01
				xQueueSend(xInputQueue, (void*)&inp, portMAX_DELAY);// right
     3ca:	20 e0       	ldi	r18, 0x00	; 0
     3cc:	4f ef       	ldi	r20, 0xFF	; 255
     3ce:	5f ef       	ldi	r21, 0xFF	; 255
     3d0:	be 01       	movw	r22, r28
     3d2:	6f 5f       	subi	r22, 0xFF	; 255
     3d4:	7f 4f       	sbci	r23, 0xFF	; 255
     3d6:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <xInputQueue>
     3da:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <xInputQueue+0x1>
     3de:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
			}
			if((~PINC & (1<<PINC6)) != 0){
     3e2:	36 99       	sbic	0x06, 6	; 6
     3e4:	0e c0       	rjmp	.+28     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
				inp.direction = 1;
     3e6:	fa 82       	std	Y+2, r15	; 0x02
     3e8:	e9 82       	std	Y+1, r14	; 0x01
				xQueueSend(xInputQueue, (void*)&inp, portMAX_DELAY); //up
     3ea:	20 e0       	ldi	r18, 0x00	; 0
     3ec:	4f ef       	ldi	r20, 0xFF	; 255
     3ee:	5f ef       	ldi	r21, 0xFF	; 255
     3f0:	be 01       	movw	r22, r28
     3f2:	6f 5f       	subi	r22, 0xFF	; 255
     3f4:	7f 4f       	sbci	r23, 0xFF	; 255
     3f6:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <xInputQueue>
     3fa:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <xInputQueue+0x1>
     3fe:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
			}
			if((~PINC & (1<<PINC7)) != 0){
     402:	37 99       	sbic	0x06, 7	; 6
     404:	15 c0       	rjmp	.+42     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
				inp.direction = 3;
     406:	da 82       	std	Y+2, r13	; 0x02
     408:	c9 82       	std	Y+1, r12	; 0x01
				xQueueSend(xInputQueue, (void*)&inp, portMAX_DELAY); //left
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	4f ef       	ldi	r20, 0xFF	; 255
     40e:	5f ef       	ldi	r21, 0xFF	; 255
     410:	be 01       	movw	r22, r28
     412:	6f 5f       	subi	r22, 0xFF	; 255
     414:	7f 4f       	sbci	r23, 0xFF	; 255
     416:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <xInputQueue>
     41a:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <xInputQueue+0x1>
     41e:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
     422:	06 c0       	rjmp	.+12     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
			}
		}
		else{
			if((~PIND & (1<<PIND3)) != 0){
     424:	4b 99       	sbic	0x09, 3	; 9
     426:	04 c0       	rjmp	.+8      	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
				restart1 = 1;
     428:	f0 92 8a 01 	sts	0x018A, r15	; 0x80018a <restart1+0x1>
     42c:	e0 92 89 01 	sts	0x0189, r14	; 0x800189 <restart1>
			}
		}
		vTaskDelay(150);
     430:	86 e9       	ldi	r24, 0x96	; 150
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 71 10 	call	0x20e2	; 0x20e2 <vTaskDelay>
	}
     438:	a4 cf       	rjmp	.-184    	; 0x382 <joystickSampler_task+0x36>

0000043a <comSender_task>:
	myMatrix[car1[0]][car1[1]] = 1;		//Placement of the car on the matrix
	//update();
}
// -----------------------------------------
void comSender_task(void *pvParameters)
{
     43a:	cf 93       	push	r28
     43c:	df 93       	push	r29
     43e:	1f 92       	push	r1
     440:	cd b7       	in	r28, 0x3d	; 61
     442:	de b7       	in	r29, 0x3e	; 62
			//11 xxx - NACK
			//need global var for tracking the current message - so no new item will be dequeued if no ACK was received
			// have to make sure that it doesnt send a MESSAGE from CS before an ACK from the receiver: idea: maybe having a flag for sending ACK or NACK before anything else in the sender

			while (1) {
				if (ackFLAG == 0) { //is not waiting for ACK
     444:	80 91 5d 03 	lds	r24, 0x035D	; 0x80035d <ackFLAG>
     448:	81 11       	cpse	r24, r1
     44a:	23 c0       	rjmp	.+70     	; 0x492 <comSender_task+0x58>
					
					if (xQueueReceive(xSendQueue, &(current_message), (TickType_t)10)) {
     44c:	20 e0       	ldi	r18, 0x00	; 0
     44e:	4a e0       	ldi	r20, 0x0A	; 10
     450:	50 e0       	ldi	r21, 0x00	; 0
     452:	6e e5       	ldi	r22, 0x5E	; 94
     454:	73 e0       	ldi	r23, 0x03	; 3
     456:	80 91 5b 03 	lds	r24, 0x035B	; 0x80035b <xSendQueue>
     45a:	90 91 5c 03 	lds	r25, 0x035C	; 0x80035c <xSendQueue+0x1>
     45e:	0e 94 c7 0c 	call	0x198e	; 0x198e <xQueueGenericReceive>
     462:	88 23       	and	r24, r24
     464:	b1 f0       	breq	.+44     	; 0x492 <comSender_task+0x58>
						com_send_bytes(&(current_message), 1); //maybe &
     466:	61 e0       	ldi	r22, 0x01	; 1
     468:	8e e5       	ldi	r24, 0x5E	; 94
     46a:	93 e0       	ldi	r25, 0x03	; 3
     46c:	0e 94 57 06 	call	0xcae	; 0xcae <com_send_bytes>
						ackFLAG = 1;
     470:	81 e0       	ldi	r24, 0x01	; 1
     472:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <ackFLAG>
						xTimerStart(sender_timeout, pdMS_TO_TICKS(10));
     476:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <xTaskGetTickCount>
     47a:	0a e0       	ldi	r16, 0x0A	; 10
     47c:	10 e0       	ldi	r17, 0x00	; 0
     47e:	20 e0       	ldi	r18, 0x00	; 0
     480:	30 e0       	ldi	r19, 0x00	; 0
     482:	ac 01       	movw	r20, r24
     484:	61 e0       	ldi	r22, 0x01	; 1
     486:	80 91 55 03 	lds	r24, 0x0355	; 0x800355 <sender_timeout>
     48a:	90 91 56 03 	lds	r25, 0x0356	; 0x800356 <sender_timeout+0x1>
     48e:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTimerGenericCommand>
					}
				}
				// waiting for ACK
				uint8_t ACK = 0;
     492:	19 82       	std	Y+1, r1	; 0x01
				if (xQueueReceive(xACKQueue, &(ACK), (TickType_t)10)) com_send_bytes(&(ACK), 1); // maybe &
     494:	20 e0       	ldi	r18, 0x00	; 0
     496:	4a e0       	ldi	r20, 0x0A	; 10
     498:	50 e0       	ldi	r21, 0x00	; 0
     49a:	be 01       	movw	r22, r28
     49c:	6f 5f       	subi	r22, 0xFF	; 255
     49e:	7f 4f       	sbci	r23, 0xFF	; 255
     4a0:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <xACKQueue>
     4a4:	90 91 5a 03 	lds	r25, 0x035A	; 0x80035a <xACKQueue+0x1>
     4a8:	0e 94 c7 0c 	call	0x198e	; 0x198e <xQueueGenericReceive>
     4ac:	88 23       	and	r24, r24
     4ae:	29 f0       	breq	.+10     	; 0x4ba <comSender_task+0x80>
     4b0:	61 e0       	ldi	r22, 0x01	; 1
     4b2:	ce 01       	movw	r24, r28
     4b4:	01 96       	adiw	r24, 0x01	; 1
     4b6:	0e 94 57 06 	call	0xcae	; 0xcae <com_send_bytes>
				vTaskDelay(30);
     4ba:	8e e1       	ldi	r24, 0x1E	; 30
     4bc:	90 e0       	ldi	r25, 0x00	; 0
     4be:	0e 94 71 10 	call	0x20e2	; 0x20e2 <vTaskDelay>
			}
     4c2:	c0 cf       	rjmp	.-128    	; 0x444 <comSender_task+0xa>

000004c4 <comReceiver_task>:
}

//-----------------------------------------

void comReceiver_task(void *pvParameters)
{
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29
     4c8:	cd b7       	in	r28, 0x3d	; 61
     4ca:	de b7       	in	r29, 0x3e	; 62
     4cc:	28 97       	sbiw	r28, 0x08	; 8
     4ce:	0f b6       	in	r0, 0x3f	; 63
     4d0:	f8 94       	cli
     4d2:	de bf       	out	0x3e, r29	; 62
     4d4:	0f be       	out	0x3f, r0	; 63
     4d6:	cd bf       	out	0x3d, r28	; 61
		#if (configUSE_APPLICATION_TASK_TAG == 1)
		vTaskSetApplicationTaskTag( NULL, ( void * ) 9 ); // Set task no to be used for tracing with R2R-Network
     4d8:	69 e0       	ldi	r22, 0x09	; 9
     4da:	70 e0       	ldi	r23, 0x00	; 0
     4dc:	80 e0       	ldi	r24, 0x00	; 0
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	0e 94 ba 10 	call	0x2174	; 0x2174 <vTaskSetApplicationTaskTag>
			if (xQueueReceive(_x_com_received_chars_queue, &byte, 1000L)) {
				//payload = check_parity_bits(*byte);
				//01 xxx - simple message
				//10 xxx - ACK
				//11 xxx - NACK
				frame_buf[0] = 124;
     4e4:	0f 2e       	mov	r0, r31
     4e6:	f9 e3       	ldi	r31, 0x39	; 57
     4e8:	cf 2e       	mov	r12, r31
     4ea:	f3 e0       	ldi	r31, 0x03	; 3
     4ec:	df 2e       	mov	r13, r31
     4ee:	f0 2d       	mov	r31, r0
     4f0:	0f 2e       	mov	r0, r31
     4f2:	fc e7       	ldi	r31, 0x7C	; 124
     4f4:	ef 2e       	mov	r14, r31
     4f6:	f1 2c       	mov	r15, r1
     4f8:	f0 2d       	mov	r31, r0
					{
						if (byte && (1 << i)) cmd += 1;
					}
					struct input inp;

					inp.car[0] = car1[0];
     4fa:	0f 2e       	mov	r0, r31
     4fc:	fd e8       	ldi	r31, 0x8D	; 141
     4fe:	af 2e       	mov	r10, r31
     500:	f1 e0       	ldi	r31, 0x01	; 1
     502:	bf 2e       	mov	r11, r31
     504:	f0 2d       	mov	r31, r0
		#endif
		while (1) {
			BaseType_t result = 0;
			BaseType_t payload = 0;
			uint8_t byte;
			if (xQueueReceive(_x_com_received_chars_queue, &byte, 1000L)) {
     506:	20 e0       	ldi	r18, 0x00	; 0
     508:	48 ee       	ldi	r20, 0xE8	; 232
     50a:	53 e0       	ldi	r21, 0x03	; 3
     50c:	be 01       	movw	r22, r28
     50e:	68 5f       	subi	r22, 0xF8	; 248
     510:	7f 4f       	sbci	r23, 0xFF	; 255
     512:	80 91 62 03 	lds	r24, 0x0362	; 0x800362 <_x_com_received_chars_queue>
     516:	90 91 63 03 	lds	r25, 0x0363	; 0x800363 <_x_com_received_chars_queue+0x1>
     51a:	0e 94 c7 0c 	call	0x198e	; 0x198e <xQueueGenericReceive>
     51e:	88 23       	and	r24, r24
     520:	e9 f1       	breq	.+122    	; 0x59c <comReceiver_task+0xd8>
				//payload = check_parity_bits(*byte);
				//01 xxx - simple message
				//10 xxx - ACK
				//11 xxx - NACK
				frame_buf[0] = 124;
     522:	f6 01       	movw	r30, r12
     524:	f1 82       	std	Z+1, r15	; 0x01
     526:	e0 82       	st	Z, r14
				uint8_t type = byte & ((1 << 6) | (1 << 7));
     528:	88 85       	ldd	r24, Y+8	; 0x08
     52a:	98 2f       	mov	r25, r24
     52c:	90 7c       	andi	r25, 0xC0	; 192
				uint8_t sequence = byte & (1 << 5);
				if (type == ((1 << 6))) //message
     52e:	90 34       	cpi	r25, 0x40	; 64
     530:	31 f5       	brne	.+76     	; 0x57e <comReceiver_task+0xba>
				//01 xxx - simple message
				//10 xxx - ACK
				//11 xxx - NACK
				frame_buf[0] = 124;
				uint8_t type = byte & ((1 << 6) | (1 << 7));
				uint8_t sequence = byte & (1 << 5);
     532:	80 72       	andi	r24, 0x20	; 32
				if (type == ((1 << 6))) //message
				{
					uint8_t ack = ( sequence) | (1 << 3) | (1 << 4);
     534:	88 61       	ori	r24, 0x18	; 24
     536:	8f 83       	std	Y+7, r24	; 0x07
					{
						if (byte && (1 << i)) cmd += 1;
					}
					struct input inp;

					inp.car[0] = car1[0];
     538:	f5 01       	movw	r30, r10
     53a:	80 81       	ld	r24, Z
     53c:	91 81       	ldd	r25, Z+1	; 0x01
     53e:	9c 83       	std	Y+4, r25	; 0x04
     540:	8b 83       	std	Y+3, r24	; 0x03

					inp.car[1] = car1[1];
     542:	82 81       	ldd	r24, Z+2	; 0x02
     544:	93 81       	ldd	r25, Z+3	; 0x03
     546:	9e 83       	std	Y+6, r25	; 0x06
     548:	8d 83       	std	Y+5, r24	; 0x05
					inp.direction = 0;
     54a:	1a 82       	std	Y+2, r1	; 0x02
     54c:	19 82       	std	Y+1, r1	; 0x01
					xQueueSend(xACKQueue, &ack, 1000L);  //send ack
     54e:	20 e0       	ldi	r18, 0x00	; 0
     550:	48 ee       	ldi	r20, 0xE8	; 232
     552:	53 e0       	ldi	r21, 0x03	; 3
     554:	be 01       	movw	r22, r28
     556:	69 5f       	subi	r22, 0xF9	; 249
     558:	7f 4f       	sbci	r23, 0xFF	; 255
     55a:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <xACKQueue>
     55e:	90 91 5a 03 	lds	r25, 0x035A	; 0x80035a <xACKQueue+0x1>
     562:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
					xQueueSend(xInputQueue, &inp, 1000L);
     566:	20 e0       	ldi	r18, 0x00	; 0
     568:	48 ee       	ldi	r20, 0xE8	; 232
     56a:	53 e0       	ldi	r21, 0x03	; 3
     56c:	be 01       	movw	r22, r28
     56e:	6f 5f       	subi	r22, 0xFF	; 255
     570:	7f 4f       	sbci	r23, 0xFF	; 255
     572:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <xInputQueue>
     576:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <xInputQueue+0x1>
     57a:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
				}
				if (type == 0 || result == 0) //ACK
				{
					//nice, do nothing, or maybe unreference the current message, because there is no need to resend
					ackFLAG = 0;
     57e:	10 92 5d 03 	sts	0x035D, r1	; 0x80035d <ackFLAG>
					xTimerStop(sender_timeout, pdMS_TO_TICKS(10));
     582:	0a e0       	ldi	r16, 0x0A	; 10
     584:	10 e0       	ldi	r17, 0x00	; 0
     586:	20 e0       	ldi	r18, 0x00	; 0
     588:	30 e0       	ldi	r19, 0x00	; 0
     58a:	40 e0       	ldi	r20, 0x00	; 0
     58c:	50 e0       	ldi	r21, 0x00	; 0
     58e:	63 e0       	ldi	r22, 0x03	; 3
     590:	80 91 55 03 	lds	r24, 0x0355	; 0x800355 <sender_timeout>
     594:	90 91 56 03 	lds	r25, 0x0356	; 0x800356 <sender_timeout+0x1>
     598:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTimerGenericCommand>
				if (type == ((1 << 7) | (1 << 6))) //NACK
				{
					//retransmit message - aka do nothing, cause there is a timeout
				}
			}
			vTaskDelay(30);
     59c:	8e e1       	ldi	r24, 0x1E	; 30
     59e:	90 e0       	ldi	r25, 0x00	; 0
     5a0:	0e 94 71 10 	call	0x20e2	; 0x20e2 <vTaskDelay>
		}
     5a4:	b0 cf       	rjmp	.-160    	; 0x506 <comReceiver_task+0x42>

000005a6 <moveCar>:
struct input1{
	uint16_t direction;
	uint16_t car1[2];
};

void moveCar (uint16_t direction, uint16_t car[2]){
     5a6:	fb 01       	movw	r30, r22
	switch(direction){
     5a8:	81 30       	cpi	r24, 0x01	; 1
     5aa:	91 05       	cpc	r25, r1
     5ac:	09 f4       	brne	.+2      	; 0x5b0 <moveCar+0xa>
     5ae:	53 c0       	rjmp	.+166    	; 0x656 <moveCar+0xb0>
     5b0:	40 f0       	brcs	.+16     	; 0x5c2 <moveCar+0x1c>
     5b2:	82 30       	cpi	r24, 0x02	; 2
     5b4:	91 05       	cpc	r25, r1
     5b6:	09 f4       	brne	.+2      	; 0x5ba <moveCar+0x14>
     5b8:	9d c0       	rjmp	.+314    	; 0x6f4 <moveCar+0x14e>
     5ba:	03 97       	sbiw	r24, 0x03	; 3
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <moveCar+0x1a>
     5be:	ec c0       	rjmp	.+472    	; 0x798 <moveCar+0x1f2>
     5c0:	08 95       	ret
		case 0:
		if((car[1] + 1 <= 9) && myMatrix[car[0]][car[1] + 1] == 0){
     5c2:	22 81       	ldd	r18, Z+2	; 0x02
     5c4:	33 81       	ldd	r19, Z+3	; 0x03
     5c6:	c9 01       	movw	r24, r18
     5c8:	01 96       	adiw	r24, 0x01	; 1
     5ca:	8a 30       	cpi	r24, 0x0A	; 10
     5cc:	91 05       	cpc	r25, r1
     5ce:	08 f0       	brcs	.+2      	; 0x5d2 <moveCar+0x2c>
     5d0:	42 c0       	rjmp	.+132    	; 0x656 <moveCar+0xb0>
     5d2:	40 81       	ld	r20, Z
     5d4:	51 81       	ldd	r21, Z+1	; 0x01
     5d6:	da 01       	movw	r26, r20
     5d8:	aa 0f       	add	r26, r26
     5da:	bb 1f       	adc	r27, r27
     5dc:	ba 01       	movw	r22, r20
     5de:	66 0f       	add	r22, r22
     5e0:	77 1f       	adc	r23, r23
     5e2:	66 0f       	add	r22, r22
     5e4:	77 1f       	adc	r23, r23
     5e6:	66 0f       	add	r22, r22
     5e8:	77 1f       	adc	r23, r23
     5ea:	a6 0f       	add	r26, r22
     5ec:	b7 1f       	adc	r27, r23
     5ee:	a8 0f       	add	r26, r24
     5f0:	b9 1f       	adc	r27, r25
     5f2:	aa 0f       	add	r26, r26
     5f4:	bb 1f       	adc	r27, r27
     5f6:	ab 56       	subi	r26, 0x6B	; 107
     5f8:	be 4f       	sbci	r27, 0xFE	; 254
     5fa:	8d 91       	ld	r24, X+
     5fc:	9c 91       	ld	r25, X
     5fe:	89 2b       	or	r24, r25
     600:	51 f5       	brne	.+84     	; 0x656 <moveCar+0xb0>
			myMatrix[car[0]][car[1]] = 0;
     602:	da 01       	movw	r26, r20
     604:	aa 0f       	add	r26, r26
     606:	bb 1f       	adc	r27, r27
     608:	a6 0f       	add	r26, r22
     60a:	b7 1f       	adc	r27, r23
     60c:	a2 0f       	add	r26, r18
     60e:	b3 1f       	adc	r27, r19
     610:	aa 0f       	add	r26, r26
     612:	bb 1f       	adc	r27, r27
     614:	ab 56       	subi	r26, 0x6B	; 107
     616:	be 4f       	sbci	r27, 0xFE	; 254
     618:	1d 92       	st	X+, r1
     61a:	1c 92       	st	X, r1
			myMatrix[car[0]][++car[1]] = 1;
     61c:	20 81       	ld	r18, Z
     61e:	31 81       	ldd	r19, Z+1	; 0x01
     620:	82 81       	ldd	r24, Z+2	; 0x02
     622:	93 81       	ldd	r25, Z+3	; 0x03
     624:	01 96       	adiw	r24, 0x01	; 1
     626:	93 83       	std	Z+3, r25	; 0x03
     628:	82 83       	std	Z+2, r24	; 0x02
     62a:	f9 01       	movw	r30, r18
     62c:	ee 0f       	add	r30, r30
     62e:	ff 1f       	adc	r31, r31
     630:	22 0f       	add	r18, r18
     632:	33 1f       	adc	r19, r19
     634:	22 0f       	add	r18, r18
     636:	33 1f       	adc	r19, r19
     638:	22 0f       	add	r18, r18
     63a:	33 1f       	adc	r19, r19
     63c:	e2 0f       	add	r30, r18
     63e:	f3 1f       	adc	r31, r19
     640:	e8 0f       	add	r30, r24
     642:	f9 1f       	adc	r31, r25
     644:	ee 0f       	add	r30, r30
     646:	ff 1f       	adc	r31, r31
     648:	eb 56       	subi	r30, 0x6B	; 107
     64a:	fe 4f       	sbci	r31, 0xFE	; 254
     64c:	81 e0       	ldi	r24, 0x01	; 1
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	91 83       	std	Z+1, r25	; 0x01
     652:	80 83       	st	Z, r24
		break;
     654:	08 95       	ret
		}
		case 1:
		if(car[1] >= 1 && myMatrix[car[0]][car[1] - 1] == 0){
     656:	22 81       	ldd	r18, Z+2	; 0x02
     658:	33 81       	ldd	r19, Z+3	; 0x03
     65a:	21 15       	cp	r18, r1
     65c:	31 05       	cpc	r19, r1
     65e:	09 f4       	brne	.+2      	; 0x662 <moveCar+0xbc>
     660:	eb c0       	rjmp	.+470    	; 0x838 <moveCar+0x292>
     662:	40 81       	ld	r20, Z
     664:	51 81       	ldd	r21, Z+1	; 0x01
     666:	da 01       	movw	r26, r20
     668:	aa 0f       	add	r26, r26
     66a:	bb 1f       	adc	r27, r27
     66c:	ca 01       	movw	r24, r20
     66e:	88 0f       	add	r24, r24
     670:	99 1f       	adc	r25, r25
     672:	88 0f       	add	r24, r24
     674:	99 1f       	adc	r25, r25
     676:	88 0f       	add	r24, r24
     678:	99 1f       	adc	r25, r25
     67a:	a8 0f       	add	r26, r24
     67c:	b9 1f       	adc	r27, r25
     67e:	a2 0f       	add	r26, r18
     680:	b3 1f       	adc	r27, r19
     682:	aa 0f       	add	r26, r26
     684:	bb 1f       	adc	r27, r27
     686:	ad 56       	subi	r26, 0x6D	; 109
     688:	be 4f       	sbci	r27, 0xFE	; 254
     68a:	8d 91       	ld	r24, X+
     68c:	9c 91       	ld	r25, X
     68e:	89 2b       	or	r24, r25
     690:	09 f0       	breq	.+2      	; 0x694 <moveCar+0xee>
     692:	d2 c0       	rjmp	.+420    	; 0x838 <moveCar+0x292>
			myMatrix[car[0]][car[1]] = 0;
     694:	da 01       	movw	r26, r20
     696:	aa 0f       	add	r26, r26
     698:	bb 1f       	adc	r27, r27
     69a:	44 0f       	add	r20, r20
     69c:	55 1f       	adc	r21, r21
     69e:	44 0f       	add	r20, r20
     6a0:	55 1f       	adc	r21, r21
     6a2:	44 0f       	add	r20, r20
     6a4:	55 1f       	adc	r21, r21
     6a6:	a4 0f       	add	r26, r20
     6a8:	b5 1f       	adc	r27, r21
     6aa:	a2 0f       	add	r26, r18
     6ac:	b3 1f       	adc	r27, r19
     6ae:	aa 0f       	add	r26, r26
     6b0:	bb 1f       	adc	r27, r27
     6b2:	ab 56       	subi	r26, 0x6B	; 107
     6b4:	be 4f       	sbci	r27, 0xFE	; 254
     6b6:	1d 92       	st	X+, r1
     6b8:	1c 92       	st	X, r1
			--car[1];
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	93 81       	ldd	r25, Z+3	; 0x03
     6be:	01 97       	sbiw	r24, 0x01	; 1
     6c0:	93 83       	std	Z+3, r25	; 0x03
     6c2:	82 83       	std	Z+2, r24	; 0x02
			myMatrix[car[0]][car[1]] = 1;
     6c4:	20 81       	ld	r18, Z
     6c6:	31 81       	ldd	r19, Z+1	; 0x01
     6c8:	f9 01       	movw	r30, r18
     6ca:	ee 0f       	add	r30, r30
     6cc:	ff 1f       	adc	r31, r31
     6ce:	22 0f       	add	r18, r18
     6d0:	33 1f       	adc	r19, r19
     6d2:	22 0f       	add	r18, r18
     6d4:	33 1f       	adc	r19, r19
     6d6:	22 0f       	add	r18, r18
     6d8:	33 1f       	adc	r19, r19
     6da:	e2 0f       	add	r30, r18
     6dc:	f3 1f       	adc	r31, r19
     6de:	e8 0f       	add	r30, r24
     6e0:	f9 1f       	adc	r31, r25
     6e2:	ee 0f       	add	r30, r30
     6e4:	ff 1f       	adc	r31, r31
     6e6:	eb 56       	subi	r30, 0x6B	; 107
     6e8:	fe 4f       	sbci	r31, 0xFE	; 254
     6ea:	81 e0       	ldi	r24, 0x01	; 1
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	91 83       	std	Z+1, r25	; 0x01
     6f0:	80 83       	st	Z, r24
     6f2:	08 95       	ret
			}
		break;

		case 2:
		if((car[0] + 1 <= 13) && myMatrix[car[0] + 1][car[1]] == 0){
     6f4:	20 81       	ld	r18, Z
     6f6:	31 81       	ldd	r19, Z+1	; 0x01
     6f8:	c9 01       	movw	r24, r18
     6fa:	01 96       	adiw	r24, 0x01	; 1
     6fc:	8e 30       	cpi	r24, 0x0E	; 14
     6fe:	91 05       	cpc	r25, r1
     700:	08 f0       	brcs	.+2      	; 0x704 <moveCar+0x15e>
     702:	9a c0       	rjmp	.+308    	; 0x838 <moveCar+0x292>
     704:	42 81       	ldd	r20, Z+2	; 0x02
     706:	53 81       	ldd	r21, Z+3	; 0x03
     708:	dc 01       	movw	r26, r24
     70a:	aa 0f       	add	r26, r26
     70c:	bb 1f       	adc	r27, r27
     70e:	88 0f       	add	r24, r24
     710:	99 1f       	adc	r25, r25
     712:	88 0f       	add	r24, r24
     714:	99 1f       	adc	r25, r25
     716:	88 0f       	add	r24, r24
     718:	99 1f       	adc	r25, r25
     71a:	a8 0f       	add	r26, r24
     71c:	b9 1f       	adc	r27, r25
     71e:	a4 0f       	add	r26, r20
     720:	b5 1f       	adc	r27, r21
     722:	aa 0f       	add	r26, r26
     724:	bb 1f       	adc	r27, r27
     726:	ab 56       	subi	r26, 0x6B	; 107
     728:	be 4f       	sbci	r27, 0xFE	; 254
     72a:	8d 91       	ld	r24, X+
     72c:	9c 91       	ld	r25, X
     72e:	89 2b       	or	r24, r25
     730:	09 f0       	breq	.+2      	; 0x734 <moveCar+0x18e>
     732:	82 c0       	rjmp	.+260    	; 0x838 <moveCar+0x292>
			myMatrix[car[0]][car[1]] = 0;
     734:	c9 01       	movw	r24, r18
     736:	88 0f       	add	r24, r24
     738:	99 1f       	adc	r25, r25
     73a:	22 0f       	add	r18, r18
     73c:	33 1f       	adc	r19, r19
     73e:	22 0f       	add	r18, r18
     740:	33 1f       	adc	r19, r19
     742:	22 0f       	add	r18, r18
     744:	33 1f       	adc	r19, r19
     746:	28 0f       	add	r18, r24
     748:	39 1f       	adc	r19, r25
     74a:	d9 01       	movw	r26, r18
     74c:	a4 0f       	add	r26, r20
     74e:	b5 1f       	adc	r27, r21
     750:	aa 0f       	add	r26, r26
     752:	bb 1f       	adc	r27, r27
     754:	ab 56       	subi	r26, 0x6B	; 107
     756:	be 4f       	sbci	r27, 0xFE	; 254
     758:	1d 92       	st	X+, r1
     75a:	1c 92       	st	X, r1
			myMatrix[++car[0]][car[1]] = 1;
     75c:	80 81       	ld	r24, Z
     75e:	91 81       	ldd	r25, Z+1	; 0x01
     760:	01 96       	adiw	r24, 0x01	; 1
     762:	91 83       	std	Z+1, r25	; 0x01
     764:	80 83       	st	Z, r24
     766:	02 80       	ldd	r0, Z+2	; 0x02
     768:	f3 81       	ldd	r31, Z+3	; 0x03
     76a:	e0 2d       	mov	r30, r0
     76c:	9c 01       	movw	r18, r24
     76e:	22 0f       	add	r18, r18
     770:	33 1f       	adc	r19, r19
     772:	88 0f       	add	r24, r24
     774:	99 1f       	adc	r25, r25
     776:	88 0f       	add	r24, r24
     778:	99 1f       	adc	r25, r25
     77a:	88 0f       	add	r24, r24
     77c:	99 1f       	adc	r25, r25
     77e:	82 0f       	add	r24, r18
     780:	93 1f       	adc	r25, r19
     782:	e8 0f       	add	r30, r24
     784:	f9 1f       	adc	r31, r25
     786:	ee 0f       	add	r30, r30
     788:	ff 1f       	adc	r31, r31
     78a:	eb 56       	subi	r30, 0x6B	; 107
     78c:	fe 4f       	sbci	r31, 0xFE	; 254
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	91 83       	std	Z+1, r25	; 0x01
     794:	80 83       	st	Z, r24
     796:	08 95       	ret
		}
		break;
		
		case 3:
		if((car[0] >= 1) && myMatrix[car[0] - 1][car[1]] == 0){
     798:	20 81       	ld	r18, Z
     79a:	31 81       	ldd	r19, Z+1	; 0x01
     79c:	21 15       	cp	r18, r1
     79e:	31 05       	cpc	r19, r1
     7a0:	09 f4       	brne	.+2      	; 0x7a4 <moveCar+0x1fe>
     7a2:	4a c0       	rjmp	.+148    	; 0x838 <moveCar+0x292>
     7a4:	42 81       	ldd	r20, Z+2	; 0x02
     7a6:	53 81       	ldd	r21, Z+3	; 0x03
     7a8:	c9 01       	movw	r24, r18
     7aa:	01 97       	sbiw	r24, 0x01	; 1
     7ac:	dc 01       	movw	r26, r24
     7ae:	aa 0f       	add	r26, r26
     7b0:	bb 1f       	adc	r27, r27
     7b2:	88 0f       	add	r24, r24
     7b4:	99 1f       	adc	r25, r25
     7b6:	88 0f       	add	r24, r24
     7b8:	99 1f       	adc	r25, r25
     7ba:	88 0f       	add	r24, r24
     7bc:	99 1f       	adc	r25, r25
     7be:	a8 0f       	add	r26, r24
     7c0:	b9 1f       	adc	r27, r25
     7c2:	a4 0f       	add	r26, r20
     7c4:	b5 1f       	adc	r27, r21
     7c6:	aa 0f       	add	r26, r26
     7c8:	bb 1f       	adc	r27, r27
     7ca:	ab 56       	subi	r26, 0x6B	; 107
     7cc:	be 4f       	sbci	r27, 0xFE	; 254
     7ce:	8d 91       	ld	r24, X+
     7d0:	9c 91       	ld	r25, X
     7d2:	89 2b       	or	r24, r25
     7d4:	89 f5       	brne	.+98     	; 0x838 <moveCar+0x292>
			myMatrix[car[0]][car[1]] = 0;
     7d6:	c9 01       	movw	r24, r18
     7d8:	88 0f       	add	r24, r24
     7da:	99 1f       	adc	r25, r25
     7dc:	22 0f       	add	r18, r18
     7de:	33 1f       	adc	r19, r19
     7e0:	22 0f       	add	r18, r18
     7e2:	33 1f       	adc	r19, r19
     7e4:	22 0f       	add	r18, r18
     7e6:	33 1f       	adc	r19, r19
     7e8:	28 0f       	add	r18, r24
     7ea:	39 1f       	adc	r19, r25
     7ec:	d9 01       	movw	r26, r18
     7ee:	a4 0f       	add	r26, r20
     7f0:	b5 1f       	adc	r27, r21
     7f2:	aa 0f       	add	r26, r26
     7f4:	bb 1f       	adc	r27, r27
     7f6:	ab 56       	subi	r26, 0x6B	; 107
     7f8:	be 4f       	sbci	r27, 0xFE	; 254
     7fa:	1d 92       	st	X+, r1
     7fc:	1c 92       	st	X, r1
			myMatrix[--car[0]][car[1]] = 1;
     7fe:	80 81       	ld	r24, Z
     800:	91 81       	ldd	r25, Z+1	; 0x01
     802:	01 97       	sbiw	r24, 0x01	; 1
     804:	91 83       	std	Z+1, r25	; 0x01
     806:	80 83       	st	Z, r24
     808:	02 80       	ldd	r0, Z+2	; 0x02
     80a:	f3 81       	ldd	r31, Z+3	; 0x03
     80c:	e0 2d       	mov	r30, r0
     80e:	9c 01       	movw	r18, r24
     810:	22 0f       	add	r18, r18
     812:	33 1f       	adc	r19, r19
     814:	88 0f       	add	r24, r24
     816:	99 1f       	adc	r25, r25
     818:	88 0f       	add	r24, r24
     81a:	99 1f       	adc	r25, r25
     81c:	88 0f       	add	r24, r24
     81e:	99 1f       	adc	r25, r25
     820:	82 0f       	add	r24, r18
     822:	93 1f       	adc	r25, r19
     824:	e8 0f       	add	r30, r24
     826:	f9 1f       	adc	r31, r25
     828:	ee 0f       	add	r30, r30
     82a:	ff 1f       	adc	r31, r31
     82c:	eb 56       	subi	r30, 0x6B	; 107
     82e:	fe 4f       	sbci	r31, 0xFE	; 254
     830:	81 e0       	ldi	r24, 0x01	; 1
     832:	90 e0       	ldi	r25, 0x00	; 0
     834:	91 83       	std	Z+1, r25	; 0x01
     836:	80 83       	st	Z, r24
     838:	08 95       	ret

0000083a <update>:
		}
		break;
	}
}

void update(){
     83a:	cf 92       	push	r12
     83c:	df 92       	push	r13
     83e:	ef 92       	push	r14
     840:	ff 92       	push	r15
     842:	0f 93       	push	r16
     844:	1f 93       	push	r17
     846:	cf 93       	push	r28
     848:	df 93       	push	r29
     84a:	c9 e3       	ldi	r28, 0x39	; 57
     84c:	d3 e0       	ldi	r29, 0x03	; 3
     84e:	45 e9       	ldi	r20, 0x95	; 149
     850:	51 e0       	ldi	r21, 0x01	; 1
     852:	0d ea       	ldi	r16, 0xAD	; 173
     854:	12 e0       	ldi	r17, 0x02	; 2
	for (int i = 0; i < 14; i++)
	{
		frame_buf[i] = 0;
		for(int j =0; j < 10 ; j++){
     856:	c1 2c       	mov	r12, r1
     858:	d1 2c       	mov	r13, r1
			if(myMatrix[i][j] == 1){
				frame_buf[i] |= 1<<j;
     85a:	61 e0       	ldi	r22, 0x01	; 1
     85c:	70 e0       	ldi	r23, 0x00	; 0
     85e:	de 01       	movw	r26, r28
}

void update(){
	for (int i = 0; i < 14; i++)
	{
		frame_buf[i] = 0;
     860:	19 82       	std	Y+1, r1	; 0x01
     862:	18 82       	st	Y, r1
     864:	fa 01       	movw	r30, r20
		for(int j =0; j < 10 ; j++){
     866:	8c 2d       	mov	r24, r12
     868:	9d 2d       	mov	r25, r13
			if(myMatrix[i][j] == 1){
     86a:	21 91       	ld	r18, Z+
     86c:	31 91       	ld	r19, Z+
     86e:	21 30       	cpi	r18, 0x01	; 1
     870:	31 05       	cpc	r19, r1
     872:	79 f4       	brne	.+30     	; 0x892 <update+0x58>
				frame_buf[i] |= 1<<j;
     874:	ed 90       	ld	r14, X+
     876:	fc 90       	ld	r15, X
     878:	11 97       	sbiw	r26, 0x01	; 1
     87a:	9b 01       	movw	r18, r22
     87c:	08 2e       	mov	r0, r24
     87e:	02 c0       	rjmp	.+4      	; 0x884 <update+0x4a>
     880:	22 0f       	add	r18, r18
     882:	33 1f       	adc	r19, r19
     884:	0a 94       	dec	r0
     886:	e2 f7       	brpl	.-8      	; 0x880 <update+0x46>
     888:	2e 29       	or	r18, r14
     88a:	3f 29       	or	r19, r15
     88c:	11 96       	adiw	r26, 0x01	; 1
     88e:	3c 93       	st	X, r19
     890:	2e 93       	st	-X, r18

void update(){
	for (int i = 0; i < 14; i++)
	{
		frame_buf[i] = 0;
		for(int j =0; j < 10 ; j++){
     892:	01 96       	adiw	r24, 0x01	; 1
     894:	8a 30       	cpi	r24, 0x0A	; 10
     896:	91 05       	cpc	r25, r1
     898:	41 f7       	brne	.-48     	; 0x86a <update+0x30>
     89a:	22 96       	adiw	r28, 0x02	; 2
     89c:	4c 5e       	subi	r20, 0xEC	; 236
     89e:	5f 4f       	sbci	r21, 0xFF	; 255
		break;
	}
}

void update(){
	for (int i = 0; i < 14; i++)
     8a0:	40 17       	cp	r20, r16
     8a2:	51 07       	cpc	r21, r17
     8a4:	e1 f6       	brne	.-72     	; 0x85e <update+0x24>
			if(myMatrix[i][j] == 1){
				frame_buf[i] |= 1<<j;
			}
		}
	}
}
     8a6:	df 91       	pop	r29
     8a8:	cf 91       	pop	r28
     8aa:	1f 91       	pop	r17
     8ac:	0f 91       	pop	r16
     8ae:	ff 90       	pop	r15
     8b0:	ef 90       	pop	r14
     8b2:	df 90       	pop	r13
     8b4:	cf 90       	pop	r12
     8b6:	08 95       	ret

000008b8 <displayUpdater_task>:
}
//-----------------------------------------
void displayUpdater_task(void *pvParameters)
{
	#if (configUSE_APPLICATION_TASK_TAG == 1)
	vTaskSetApplicationTaskTag( NULL, ( void * ) 3 );
     8b8:	63 e0       	ldi	r22, 0x03	; 3
     8ba:	70 e0       	ldi	r23, 0x00	; 0
     8bc:	80 e0       	ldi	r24, 0x00	; 0
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	0e 94 ba 10 	call	0x2174	; 0x2174 <vTaskSetApplicationTaskTag>
	#endif
	while(1)
	{
				update();
     8c4:	0e 94 1d 04 	call	0x83a	; 0x83a <update>
		vTaskDelay(100);
     8c8:	84 e6       	ldi	r24, 0x64	; 100
     8ca:	90 e0       	ldi	r25, 0x00	; 0
     8cc:	0e 94 71 10 	call	0x20e2	; 0x20e2 <vTaskDelay>
	}
     8d0:	f9 cf       	rjmp	.-14     	; 0x8c4 <displayUpdater_task+0xc>

000008d2 <setupGame>:
		}
		vTaskDelay(150);
	}
}

void setupGame(){
     8d2:	e5 e9       	ldi	r30, 0x95	; 149
     8d4:	f1 e0       	ldi	r31, 0x01	; 1
     8d6:	2d ea       	ldi	r18, 0xAD	; 173
     8d8:	32 e0       	ldi	r19, 0x02	; 2
     8da:	4d ea       	ldi	r20, 0xAD	; 173
     8dc:	52 e0       	ldi	r21, 0x02	; 2
     8de:	0c c0       	rjmp	.+24     	; 0x8f8 <setupGame+0x26>
	for(int i = 0; i < 14; i++) {		//Setup matrix
		for(int j = 0; j < 10; j++){
			myMatrix[i][j] = 0;
     8e0:	11 92       	st	Z+, r1
     8e2:	11 92       	st	Z+, r1
			obstacles[i][j] = 0;
     8e4:	1d 92       	st	X+, r1
	}
}

void setupGame(){
	for(int i = 0; i < 14; i++) {		//Setup matrix
		for(int j = 0; j < 10; j++){
     8e6:	e8 17       	cp	r30, r24
     8e8:	f9 07       	cpc	r31, r25
     8ea:	d1 f7       	brne	.-12     	; 0x8e0 <setupGame+0xe>
     8ec:	26 5f       	subi	r18, 0xF6	; 246
     8ee:	3f 4f       	sbci	r19, 0xFF	; 255
     8f0:	fc 01       	movw	r30, r24
		vTaskDelay(150);
	}
}

void setupGame(){
	for(int i = 0; i < 14; i++) {		//Setup matrix
     8f2:	48 17       	cp	r20, r24
     8f4:	59 07       	cpc	r21, r25
     8f6:	21 f0       	breq	.+8      	; 0x900 <__stack+0x1>
     8f8:	cf 01       	movw	r24, r30
     8fa:	44 96       	adiw	r24, 0x14	; 20
		}
		vTaskDelay(150);
	}
}

void setupGame(){
     8fc:	d9 01       	movw	r26, r18
     8fe:	f0 cf       	rjmp	.-32     	; 0x8e0 <setupGame+0xe>
		for(int j = 0; j < 10; j++){
			myMatrix[i][j] = 0;
			obstacles[i][j] = 0;
		}
	}
	car[0] = 5; //column				//Start position for the first car
     900:	e1 e9       	ldi	r30, 0x91	; 145
     902:	f1 e0       	ldi	r31, 0x01	; 1
     904:	85 e0       	ldi	r24, 0x05	; 5
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	91 83       	std	Z+1, r25	; 0x01
     90a:	80 83       	st	Z, r24
	car[1] = 9; // row
     90c:	89 e0       	ldi	r24, 0x09	; 9
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	93 83       	std	Z+3, r25	; 0x03
     912:	82 83       	std	Z+2, r24	; 0x02
	car1[0] = 9; //column				//Start position for the second car
     914:	ed e8       	ldi	r30, 0x8D	; 141
     916:	f1 e0       	ldi	r31, 0x01	; 1
     918:	91 83       	std	Z+1, r25	; 0x01
     91a:	80 83       	st	Z, r24
	car1[1] = 7; // row
     91c:	87 e0       	ldi	r24, 0x07	; 7
     91e:	90 e0       	ldi	r25, 0x00	; 0
     920:	93 83       	std	Z+3, r25	; 0x03
     922:	82 83       	std	Z+2, r24	; 0x02
	myMatrix[car[0]][car[1]] = 1;		//Placement of the car on the matrix
     924:	81 e0       	ldi	r24, 0x01	; 1
     926:	90 e0       	ldi	r25, 0x00	; 0
     928:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <myMatrix+0x77>
     92c:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <myMatrix+0x76>
	myMatrix[car1[0]][car1[1]] = 1;		//Placement of the car on the matrix
     930:	90 93 58 02 	sts	0x0258, r25	; 0x800258 <myMatrix+0xc3>
     934:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <myMatrix+0xc2>
     938:	08 95       	ret

0000093a <gameLogic_task>:
	}
}
//-----------------------------------------

void gameLogic_task(void *pvParameters)
{
     93a:	cf 93       	push	r28
     93c:	df 93       	push	r29
     93e:	00 d0       	rcall	.+0      	; 0x940 <gameLogic_task+0x6>
     940:	00 d0       	rcall	.+0      	; 0x942 <gameLogic_task+0x8>
     942:	00 d0       	rcall	.+0      	; 0x944 <gameLogic_task+0xa>
     944:	cd b7       	in	r28, 0x3d	; 61
     946:	de b7       	in	r29, 0x3e	; 62
	#if (configUSE_APPLICATION_TASK_TAG == 1)
	vTaskSetApplicationTaskTag( NULL, ( void * ) 7 );
     948:	67 e0       	ldi	r22, 0x07	; 7
     94a:	70 e0       	ldi	r23, 0x00	; 0
     94c:	80 e0       	ldi	r24, 0x00	; 0
     94e:	90 e0       	ldi	r25, 0x00	; 0
     950:	0e 94 ba 10 	call	0x2174	; 0x2174 <vTaskSetApplicationTaskTag>
				}
				else{
					if(restart1 + restart2 == 2){
						stop = 0;
						restart1 = 0;
						restart2 = 1; //later 0 when we add a player
     954:	01 e0       	ldi	r16, 0x01	; 1
     956:	10 e0       	ldi	r17, 0x00	; 0
	while(1){
				if(stop == 0){
					struct input inp;
							if(xQueueReceive(xInputQueue, (void*)&inp, 2000)){
									if(xSemaphoreTake(xMutex, portMAX_DELAY)){
											if(inp.car[0] == car[0] && inp.car[1] == car[1]){
     958:	0f 2e       	mov	r0, r31
     95a:	f1 e9       	ldi	r31, 0x91	; 145
     95c:	ef 2e       	mov	r14, r31
     95e:	f1 e0       	ldi	r31, 0x01	; 1
     960:	ff 2e       	mov	r15, r31
     962:	f0 2d       	mov	r31, r0
												moveCar(inp.direction, car);
											}
											else if(inp.car[0] == car1[0] && inp.car[1] == car1[1]){
     964:	0f 2e       	mov	r0, r31
     966:	fd e8       	ldi	r31, 0x8D	; 141
     968:	cf 2e       	mov	r12, r31
     96a:	f1 e0       	ldi	r31, 0x01	; 1
     96c:	df 2e       	mov	r13, r31
     96e:	f0 2d       	mov	r31, r0
{
	#if (configUSE_APPLICATION_TASK_TAG == 1)
	vTaskSetApplicationTaskTag( NULL, ( void * ) 7 );
	#endif
	while(1){
				if(stop == 0){
     970:	80 91 8b 01 	lds	r24, 0x018B	; 0x80018b <stop>
     974:	90 91 8c 01 	lds	r25, 0x018C	; 0x80018c <stop+0x1>
     978:	89 2b       	or	r24, r25
     97a:	09 f0       	breq	.+2      	; 0x97e <gameLogic_task+0x44>
     97c:	50 c0       	rjmp	.+160    	; 0xa1e <gameLogic_task+0xe4>
					struct input inp;
							if(xQueueReceive(xInputQueue, (void*)&inp, 2000)){
     97e:	20 e0       	ldi	r18, 0x00	; 0
     980:	40 ed       	ldi	r20, 0xD0	; 208
     982:	57 e0       	ldi	r21, 0x07	; 7
     984:	be 01       	movw	r22, r28
     986:	6f 5f       	subi	r22, 0xFF	; 255
     988:	7f 4f       	sbci	r23, 0xFF	; 255
     98a:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <xInputQueue>
     98e:	90 91 58 03 	lds	r25, 0x0358	; 0x800358 <xInputQueue+0x1>
     992:	0e 94 c7 0c 	call	0x198e	; 0x198e <xQueueGenericReceive>
     996:	88 23       	and	r24, r24
     998:	09 f4       	brne	.+2      	; 0x99c <gameLogic_task+0x62>
     99a:	5b c0       	rjmp	.+182    	; 0xa52 <gameLogic_task+0x118>
									if(xSemaphoreTake(xMutex, portMAX_DELAY)){
     99c:	20 e0       	ldi	r18, 0x00	; 0
     99e:	4f ef       	ldi	r20, 0xFF	; 255
     9a0:	5f ef       	ldi	r21, 0xFF	; 255
     9a2:	60 e0       	ldi	r22, 0x00	; 0
     9a4:	70 e0       	ldi	r23, 0x00	; 0
     9a6:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <xMutex>
     9aa:	90 91 61 03 	lds	r25, 0x0361	; 0x800361 <xMutex+0x1>
     9ae:	0e 94 c7 0c 	call	0x198e	; 0x198e <xQueueGenericReceive>
     9b2:	88 23       	and	r24, r24
     9b4:	09 f4       	brne	.+2      	; 0x9b8 <gameLogic_task+0x7e>
     9b6:	4d c0       	rjmp	.+154    	; 0xa52 <gameLogic_task+0x118>
											if(inp.car[0] == car[0] && inp.car[1] == car[1]){
     9b8:	8b 81       	ldd	r24, Y+3	; 0x03
     9ba:	9c 81       	ldd	r25, Y+4	; 0x04
     9bc:	f7 01       	movw	r30, r14
     9be:	20 81       	ld	r18, Z
     9c0:	31 81       	ldd	r19, Z+1	; 0x01
     9c2:	82 17       	cp	r24, r18
     9c4:	93 07       	cpc	r25, r19
     9c6:	69 f4       	brne	.+26     	; 0x9e2 <gameLogic_task+0xa8>
     9c8:	4d 81       	ldd	r20, Y+5	; 0x05
     9ca:	5e 81       	ldd	r21, Y+6	; 0x06
     9cc:	22 81       	ldd	r18, Z+2	; 0x02
     9ce:	33 81       	ldd	r19, Z+3	; 0x03
     9d0:	42 17       	cp	r20, r18
     9d2:	53 07       	cpc	r21, r19
     9d4:	31 f4       	brne	.+12     	; 0x9e2 <gameLogic_task+0xa8>
												moveCar(inp.direction, car);
     9d6:	b7 01       	movw	r22, r14
     9d8:	89 81       	ldd	r24, Y+1	; 0x01
     9da:	9a 81       	ldd	r25, Y+2	; 0x02
     9dc:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <moveCar>
     9e0:	12 c0       	rjmp	.+36     	; 0xa06 <gameLogic_task+0xcc>
											}
											else if(inp.car[0] == car1[0] && inp.car[1] == car1[1]){
     9e2:	f6 01       	movw	r30, r12
     9e4:	20 81       	ld	r18, Z
     9e6:	31 81       	ldd	r19, Z+1	; 0x01
     9e8:	82 17       	cp	r24, r18
     9ea:	93 07       	cpc	r25, r19
     9ec:	61 f4       	brne	.+24     	; 0xa06 <gameLogic_task+0xcc>
     9ee:	2d 81       	ldd	r18, Y+5	; 0x05
     9f0:	3e 81       	ldd	r19, Y+6	; 0x06
     9f2:	82 81       	ldd	r24, Z+2	; 0x02
     9f4:	93 81       	ldd	r25, Z+3	; 0x03
     9f6:	28 17       	cp	r18, r24
     9f8:	39 07       	cpc	r19, r25
     9fa:	29 f4       	brne	.+10     	; 0xa06 <gameLogic_task+0xcc>
												moveCar(inp.direction, car1);
     9fc:	b6 01       	movw	r22, r12
     9fe:	89 81       	ldd	r24, Y+1	; 0x01
     a00:	9a 81       	ldd	r25, Y+2	; 0x02
     a02:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <moveCar>
											}
									xSemaphoreGive(xMutex);
     a06:	20 e0       	ldi	r18, 0x00	; 0
     a08:	40 e0       	ldi	r20, 0x00	; 0
     a0a:	50 e0       	ldi	r21, 0x00	; 0
     a0c:	60 e0       	ldi	r22, 0x00	; 0
     a0e:	70 e0       	ldi	r23, 0x00	; 0
     a10:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <xMutex>
     a14:	90 91 61 03 	lds	r25, 0x0361	; 0x800361 <xMutex+0x1>
     a18:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
     a1c:	1a c0       	rjmp	.+52     	; 0xa52 <gameLogic_task+0x118>
									}
							}				
				}
				else{
					if(restart1 + restart2 == 2){
     a1e:	20 91 89 01 	lds	r18, 0x0189	; 0x800189 <restart1>
     a22:	30 91 8a 01 	lds	r19, 0x018A	; 0x80018a <restart1+0x1>
     a26:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <restart2>
     a2a:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <restart2+0x1>
     a2e:	82 0f       	add	r24, r18
     a30:	93 1f       	adc	r25, r19
     a32:	02 97       	sbiw	r24, 0x02	; 2
     a34:	71 f4       	brne	.+28     	; 0xa52 <gameLogic_task+0x118>
						stop = 0;
     a36:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <stop+0x1>
     a3a:	10 92 8b 01 	sts	0x018B, r1	; 0x80018b <stop>
						restart1 = 0;
     a3e:	10 92 8a 01 	sts	0x018A, r1	; 0x80018a <restart1+0x1>
     a42:	10 92 89 01 	sts	0x0189, r1	; 0x800189 <restart1>
						restart2 = 1; //later 0 when we add a player
     a46:	10 93 0b 01 	sts	0x010B, r17	; 0x80010b <restart2+0x1>
     a4a:	00 93 0a 01 	sts	0x010A, r16	; 0x80010a <restart2>
						setupGame();
     a4e:	0e 94 69 04 	call	0x8d2	; 0x8d2 <setupGame>
					}
				}
				vTaskDelay(75);		
     a52:	8b e4       	ldi	r24, 0x4B	; 75
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	0e 94 71 10 	call	0x20e2	; 0x20e2 <vTaskDelay>
	}
     a5a:	8a cf       	rjmp	.-236    	; 0x970 <gameLogic_task+0x36>

00000a5c <prepare_shiftregister>:

// Prepare shift register setting SER = 1
void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     a5c:	5a 9a       	sbi	0x0b, 2	; 11
     a5e:	08 95       	ret

00000a60 <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     a60:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     a62:	5d 98       	cbi	0x0b, 5	; 11
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     a64:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     a66:	5c 98       	cbi	0x0b, 4	; 11
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     a68:	5a 98       	cbi	0x0b, 2	; 11
     a6a:	08 95       	ret

00000a6c <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     a6c:	80 95       	com	r24
     a6e:	82 b9       	out	0x02, r24	; 2
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     a70:	85 b1       	in	r24, 0x05	; 5
     a72:	83 60       	ori	r24, 0x03	; 3
     a74:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     a76:	85 b1       	in	r24, 0x05	; 5
     a78:	93 70       	andi	r25, 0x03	; 3
     a7a:	90 95       	com	r25
     a7c:	89 23       	and	r24, r25
     a7e:	85 b9       	out	0x05, r24	; 5
     a80:	08 95       	ret

00000a82 <handle_display>:
}
//-----------------------------------------

void handle_display(void)
{
     a82:	cf 93       	push	r28
	static uint8_t col = 0;
	if (col == 0)
     a84:	c0 91 88 01 	lds	r28, 0x0188	; 0x800188 <__data_end>
     a88:	c1 11       	cpse	r28, r1
     a8a:	0e c0       	rjmp	.+28     	; 0xaa8 <handle_display+0x26>
	{
		prepare_shiftregister();
     a8c:	0e 94 2e 05 	call	0xa5c	; 0xa5c <prepare_shiftregister>
	}
	load_col_value(frame_buf[col]);
     a90:	80 91 39 03 	lds	r24, 0x0339	; 0x800339 <frame_buf>
     a94:	90 91 3a 03 	lds	r25, 0x033A	; 0x80033a <frame_buf+0x1>
     a98:	0e 94 36 05 	call	0xa6c	; 0xa6c <load_col_value>
	clock_shift_register_and_prepare_for_next_col();
     a9c:	0e 94 30 05 	call	0xa60	; 0xa60 <clock_shift_register_and_prepare_for_next_col>
	// count column up - prepare for next
	col++;
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <__data_end>
     aa6:	14 c0       	rjmp	.+40     	; 0xad0 <handle_display+0x4e>
	static uint8_t col = 0;
	if (col == 0)
	{
		prepare_shiftregister();
	}
	load_col_value(frame_buf[col]);
     aa8:	ec 2f       	mov	r30, r28
     aaa:	f0 e0       	ldi	r31, 0x00	; 0
     aac:	ee 0f       	add	r30, r30
     aae:	ff 1f       	adc	r31, r31
     ab0:	e7 5c       	subi	r30, 0xC7	; 199
     ab2:	fc 4f       	sbci	r31, 0xFC	; 252
     ab4:	80 81       	ld	r24, Z
     ab6:	91 81       	ldd	r25, Z+1	; 0x01
     ab8:	0e 94 36 05 	call	0xa6c	; 0xa6c <load_col_value>
	clock_shift_register_and_prepare_for_next_col();
     abc:	0e 94 30 05 	call	0xa60	; 0xa60 <clock_shift_register_and_prepare_for_next_col>
	// count column up - prepare for next
	col++;
     ac0:	cf 5f       	subi	r28, 0xFF	; 255
	if (col > 13)
     ac2:	ce 30       	cpi	r28, 0x0E	; 14
     ac4:	18 f4       	brcc	.+6      	; 0xacc <handle_display+0x4a>
		prepare_shiftregister();
	}
	load_col_value(frame_buf[col]);
	clock_shift_register_and_prepare_for_next_col();
	// count column up - prepare for next
	col++;
     ac6:	c0 93 88 01 	sts	0x0188, r28	; 0x800188 <__data_end>
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <handle_display+0x4e>
	if (col > 13)
	{
		col = 0;
     acc:	10 92 88 01 	sts	0x0188, r1	; 0x800188 <__data_end>
	}
}
     ad0:	cf 91       	pop	r28
     ad2:	08 95       	ret

00000ad4 <vApplicationIdleHook>:
//-----------------------------------------

void vApplicationIdleHook( void )
{
     ad4:	08 95       	ret

00000ad6 <main>:
	//
}
//----------------------------------------- MAIN ---------------------------------------------------------------
int main(void)
{
	init_board();
     ad6:	0e 94 60 06 	call	0xcc0	; 0xcc0 <init_board>
	_x_com_received_chars_queue = xQueueCreate( _COM_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
     ada:	40 e0       	ldi	r20, 0x00	; 0
     adc:	61 e0       	ldi	r22, 0x01	; 1
     ade:	8e e1       	ldi	r24, 0x1E	; 30
     ae0:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericCreate>
     ae4:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <_x_com_received_chars_queue+0x1>
     ae8:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <_x_com_received_chars_queue>
	init_com(_x_com_received_chars_queue);
     aec:	0e 94 17 06 	call	0xc2e	; 0xc2e <init_com>
	sender_timeout = xTimerCreate("Timeout", pdMS_TO_TICKS(100), pdFALSE, 1, vTimeout);
     af0:	07 e6       	ldi	r16, 0x67	; 103
     af2:	10 e0       	ldi	r17, 0x00	; 0
     af4:	21 e0       	ldi	r18, 0x01	; 1
     af6:	30 e0       	ldi	r19, 0x00	; 0
     af8:	40 e0       	ldi	r20, 0x00	; 0
     afa:	62 e2       	ldi	r22, 0x22	; 34
     afc:	70 e0       	ldi	r23, 0x00	; 0
     afe:	80 e1       	ldi	r24, 0x10	; 16
     b00:	91 e0       	ldi	r25, 0x01	; 1
     b02:	0e 94 2f 13 	call	0x265e	; 0x265e <xTimerCreate>
     b06:	90 93 56 03 	sts	0x0356, r25	; 0x800356 <sender_timeout+0x1>
     b0a:	80 93 55 03 	sts	0x0355, r24	; 0x800355 <sender_timeout>
	xSendQueue = xQueueCreate(4, sizeof(unsigned char));
     b0e:	40 e0       	ldi	r20, 0x00	; 0
     b10:	61 e0       	ldi	r22, 0x01	; 1
     b12:	84 e0       	ldi	r24, 0x04	; 4
     b14:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericCreate>
     b18:	90 93 5c 03 	sts	0x035C, r25	; 0x80035c <xSendQueue+0x1>
     b1c:	80 93 5b 03 	sts	0x035B, r24	; 0x80035b <xSendQueue>
	xACKQueue = xQueueCreate(4, sizeof(unsigned char));
     b20:	40 e0       	ldi	r20, 0x00	; 0
     b22:	61 e0       	ldi	r22, 0x01	; 1
     b24:	84 e0       	ldi	r24, 0x04	; 4
     b26:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericCreate>
     b2a:	90 93 5a 03 	sts	0x035A, r25	; 0x80035a <xACKQueue+0x1>
     b2e:	80 93 59 03 	sts	0x0359, r24	; 0x800359 <xACKQueue>
	xInputQueue = xQueueCreate(4, sizeof(struct input));
     b32:	40 e0       	ldi	r20, 0x00	; 0
     b34:	66 e0       	ldi	r22, 0x06	; 6
     b36:	84 e0       	ldi	r24, 0x04	; 4
     b38:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericCreate>
     b3c:	90 93 58 03 	sts	0x0358, r25	; 0x800358 <xInputQueue+0x1>
     b40:	80 93 57 03 	sts	0x0357, r24	; 0x800357 <xInputQueue>
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     b44:	5e 98       	cbi	0x0b, 6	; 11
	//Create task to blink gpio
	setupGame();
     b46:	0e 94 69 04 	call	0x8d2	; 0x8d2 <setupGame>
	xMutex = xSemaphoreCreateMutex();  // Initialise Mutex
     b4a:	81 e0       	ldi	r24, 0x01	; 1
     b4c:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <xQueueCreateMutex>
     b50:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <xMutex+0x1>
     b54:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <xMutex>
	BaseType_t tDU = xTaskCreate(displayUpdater_task, (const char *)"Display updater", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY + 2, NULL);
     b58:	e1 2c       	mov	r14, r1
     b5a:	f1 2c       	mov	r15, r1
     b5c:	02 e0       	ldi	r16, 0x02	; 2
     b5e:	20 e0       	ldi	r18, 0x00	; 0
     b60:	30 e0       	ldi	r19, 0x00	; 0
     b62:	4b e3       	ldi	r20, 0x3B	; 59
     b64:	50 e0       	ldi	r21, 0x00	; 0
     b66:	68 e1       	ldi	r22, 0x18	; 24
     b68:	71 e0       	ldi	r23, 0x01	; 1
     b6a:	8c e5       	ldi	r24, 0x5C	; 92
     b6c:	94 e0       	ldi	r25, 0x04	; 4
     b6e:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
	BaseType_t tGL = xTaskCreate(gameLogic_task, (const char *)"Game logic", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY + 3, NULL);
     b72:	03 e0       	ldi	r16, 0x03	; 3
     b74:	20 e0       	ldi	r18, 0x00	; 0
     b76:	30 e0       	ldi	r19, 0x00	; 0
     b78:	4b e3       	ldi	r20, 0x3B	; 59
     b7a:	50 e0       	ldi	r21, 0x00	; 0
     b7c:	68 e2       	ldi	r22, 0x28	; 40
     b7e:	71 e0       	ldi	r23, 0x01	; 1
     b80:	8d e9       	ldi	r24, 0x9D	; 157
     b82:	94 e0       	ldi	r25, 0x04	; 4
     b84:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
	BaseType_t t2 = xTaskCreate(obstacles_task, (const char *)"Obstacles", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY , NULL);
     b88:	00 e0       	ldi	r16, 0x00	; 0
     b8a:	20 e0       	ldi	r18, 0x00	; 0
     b8c:	30 e0       	ldi	r19, 0x00	; 0
     b8e:	4b e3       	ldi	r20, 0x3B	; 59
     b90:	50 e0       	ldi	r21, 0x00	; 0
     b92:	63 e3       	ldi	r22, 0x33	; 51
     b94:	71 e0       	ldi	r23, 0x01	; 1
     b96:	8d e6       	ldi	r24, 0x6D	; 109
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
	BaseType_t tJS = xTaskCreate(joystickSampler_task, (const char *)"Joystick sampler", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY + 1, NULL);
     b9e:	01 e0       	ldi	r16, 0x01	; 1
     ba0:	20 e0       	ldi	r18, 0x00	; 0
     ba2:	30 e0       	ldi	r19, 0x00	; 0
     ba4:	4b e3       	ldi	r20, 0x3B	; 59
     ba6:	50 e0       	ldi	r21, 0x00	; 0
     ba8:	6d e3       	ldi	r22, 0x3D	; 61
     baa:	71 e0       	ldi	r23, 0x01	; 1
     bac:	86 ea       	ldi	r24, 0xA6	; 166
     bae:	91 e0       	ldi	r25, 0x01	; 1
     bb0:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
	BaseType_t tCS1 = xTaskCreate(comSender_task, (const char *)"Communication sender", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY + 5, NULL);
     bb4:	05 e0       	ldi	r16, 0x05	; 5
     bb6:	20 e0       	ldi	r18, 0x00	; 0
     bb8:	30 e0       	ldi	r19, 0x00	; 0
     bba:	4b e3       	ldi	r20, 0x3B	; 59
     bbc:	50 e0       	ldi	r21, 0x00	; 0
     bbe:	6e e4       	ldi	r22, 0x4E	; 78
     bc0:	71 e0       	ldi	r23, 0x01	; 1
     bc2:	8d e1       	ldi	r24, 0x1D	; 29
     bc4:	92 e0       	ldi	r25, 0x02	; 2
     bc6:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
	BaseType_t tCR1 = xTaskCreate(comReceiver_task, (const char *)"Communication receiver", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY + 4, NULL);
     bca:	04 e0       	ldi	r16, 0x04	; 4
     bcc:	20 e0       	ldi	r18, 0x00	; 0
     bce:	30 e0       	ldi	r19, 0x00	; 0
     bd0:	4b e3       	ldi	r20, 0x3B	; 59
     bd2:	50 e0       	ldi	r21, 0x00	; 0
     bd4:	63 e6       	ldi	r22, 0x63	; 99
     bd6:	71 e0       	ldi	r23, 0x01	; 1
     bd8:	82 e6       	ldi	r24, 0x62	; 98
     bda:	92 e0       	ldi	r25, 0x02	; 2
     bdc:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
	
	// Start the display handler timer
	init_display_timer(handle_display);
     be0:	81 e4       	ldi	r24, 0x41	; 65
     be2:	95 e0       	ldi	r25, 0x05	; 5
     be4:	0e 94 1c 06 	call	0xc38	; 0xc38 <init_display_timer>
	sei();
     be8:	78 94       	sei
	//Start the scheduler
	vTaskStartScheduler();
     bea:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <vTaskStartScheduler>
	//Should never reach here
	while (1)
	{
	}
     bee:	ff cf       	rjmp	.-2      	; 0xbee <main+0x118>

00000bf0 <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <_com_call_back+0x6>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     bfc:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <_x_rx_com_queue>
     c00:	90 91 ad 03 	lds	r25, 0x03AD	; 0x8003ad <_x_rx_com_queue+0x1>
     c04:	00 97       	sbiw	r24, 0x00	; 0
     c06:	71 f0       	breq	.+28     	; 0xc24 <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     c08:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     c0a:	20 e0       	ldi	r18, 0x00	; 0
     c0c:	ae 01       	movw	r20, r28
     c0e:	4f 5f       	subi	r20, 0xFF	; 255
     c10:	5f 4f       	sbci	r21, 0xFF	; 255
     c12:	be 01       	movw	r22, r28
     c14:	6e 5f       	subi	r22, 0xFE	; 254
     c16:	7f 4f       	sbci	r23, 0xFF	; 255
     c18:	0e 94 8d 0c 	call	0x191a	; 0x191a <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     c1c:	89 81       	ldd	r24, Y+1	; 0x01
     c1e:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     c20:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
		}
	}
}
     c24:	0f 90       	pop	r0
     c26:	0f 90       	pop	r0
     c28:	df 91       	pop	r29
     c2a:	cf 91       	pop	r28
     c2c:	08 95       	ret

00000c2e <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     c2e:	90 93 ad 03 	sts	0x03AD, r25	; 0x8003ad <_x_rx_com_queue+0x1>
     c32:	80 93 ac 03 	sts	0x03AC, r24	; 0x8003ac <_x_rx_com_queue>
     c36:	08 95       	ret

00000c38 <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     c38:	90 93 ab 03 	sts	0x03AB, r25	; 0x8003ab <cb_ptr+0x1>
     c3c:	80 93 aa 03 	sts	0x03AA, r24	; 0x8003aa <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     c40:	8a e0       	ldi	r24, 0x0A	; 10
     c42:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     c44:	84 b5       	in	r24, 0x24	; 36
     c46:	82 60       	ori	r24, 0x02	; 2
     c48:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     c4a:	ee e6       	ldi	r30, 0x6E	; 110
     c4c:	f0 e0       	ldi	r31, 0x00	; 0
     c4e:	80 81       	ld	r24, Z
     c50:	82 60       	ori	r24, 0x02	; 2
     c52:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     c54:	85 b5       	in	r24, 0x25	; 37
     c56:	85 60       	ori	r24, 0x05	; 5
     c58:	85 bd       	out	0x25, r24	; 37
     c5a:	08 95       	ret

00000c5c <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     c5c:	1f 92       	push	r1
     c5e:	0f 92       	push	r0
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	0f 92       	push	r0
     c64:	11 24       	eor	r1, r1
     c66:	2f 93       	push	r18
     c68:	3f 93       	push	r19
     c6a:	4f 93       	push	r20
     c6c:	5f 93       	push	r21
     c6e:	6f 93       	push	r22
     c70:	7f 93       	push	r23
     c72:	8f 93       	push	r24
     c74:	9f 93       	push	r25
     c76:	af 93       	push	r26
     c78:	bf 93       	push	r27
     c7a:	ef 93       	push	r30
     c7c:	ff 93       	push	r31
	if (cb_ptr)
     c7e:	e0 91 aa 03 	lds	r30, 0x03AA	; 0x8003aa <cb_ptr>
     c82:	f0 91 ab 03 	lds	r31, 0x03AB	; 0x8003ab <cb_ptr+0x1>
     c86:	30 97       	sbiw	r30, 0x00	; 0
     c88:	09 f0       	breq	.+2      	; 0xc8c <__vector_16+0x30>
	{
		cb_ptr();
     c8a:	09 95       	icall
	}
}
     c8c:	ff 91       	pop	r31
     c8e:	ef 91       	pop	r30
     c90:	bf 91       	pop	r27
     c92:	af 91       	pop	r26
     c94:	9f 91       	pop	r25
     c96:	8f 91       	pop	r24
     c98:	7f 91       	pop	r23
     c9a:	6f 91       	pop	r22
     c9c:	5f 91       	pop	r21
     c9e:	4f 91       	pop	r20
     ca0:	3f 91       	pop	r19
     ca2:	2f 91       	pop	r18
     ca4:	0f 90       	pop	r0
     ca6:	0f be       	out	0x3f, r0	; 63
     ca8:	0f 90       	pop	r0
     caa:	1f 90       	pop	r1
     cac:	18 95       	reti

00000cae <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     cae:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     cb0:	bc 01       	movw	r22, r24
     cb2:	80 91 ae 03 	lds	r24, 0x03AE	; 0x8003ae <_com_serial_instance>
     cb6:	90 91 af 03 	lds	r25, 0x03AF	; 0x8003af <_com_serial_instance+0x1>
     cba:	0e 94 59 09 	call	0x12b2	; 0x12b2 <serial_send_bytes>
     cbe:	08 95       	ret

00000cc0 <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     cc0:	8f 92       	push	r8
     cc2:	9f 92       	push	r9
     cc4:	af 92       	push	r10
     cc6:	bf 92       	push	r11
     cc8:	cf 92       	push	r12
     cca:	df 92       	push	r13
     ccc:	ef 92       	push	r14
     cce:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     cd0:	87 e8       	ldi	r24, 0x87	; 135
     cd2:	93 e0       	ldi	r25, 0x03	; 3
     cd4:	0e 94 b9 06 	call	0xd72	; 0xd72 <buffer_init>
	buffer_init(&_com_tx_buffer);
     cd8:	84 e6       	ldi	r24, 0x64	; 100
     cda:	93 e0       	ldi	r25, 0x03	; 3
     cdc:	0e 94 b9 06 	call	0xd72	; 0xd72 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     ce0:	0f 2e       	mov	r0, r31
     ce2:	f8 ef       	ldi	r31, 0xF8	; 248
     ce4:	8f 2e       	mov	r8, r31
     ce6:	f5 e0       	ldi	r31, 0x05	; 5
     ce8:	9f 2e       	mov	r9, r31
     cea:	f0 2d       	mov	r31, r0
     cec:	0f 2e       	mov	r0, r31
     cee:	f4 e6       	ldi	r31, 0x64	; 100
     cf0:	af 2e       	mov	r10, r31
     cf2:	f3 e0       	ldi	r31, 0x03	; 3
     cf4:	bf 2e       	mov	r11, r31
     cf6:	f0 2d       	mov	r31, r0
     cf8:	0f 2e       	mov	r0, r31
     cfa:	f7 e8       	ldi	r31, 0x87	; 135
     cfc:	cf 2e       	mov	r12, r31
     cfe:	f3 e0       	ldi	r31, 0x03	; 3
     d00:	df 2e       	mov	r13, r31
     d02:	f0 2d       	mov	r31, r0
     d04:	e1 2c       	mov	r14, r1
     d06:	00 e0       	ldi	r16, 0x00	; 0
     d08:	23 e0       	ldi	r18, 0x03	; 3
     d0a:	40 e0       	ldi	r20, 0x00	; 0
     d0c:	52 ec       	ldi	r21, 0xC2	; 194
     d0e:	61 e0       	ldi	r22, 0x01	; 1
     d10:	70 e0       	ldi	r23, 0x00	; 0
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	0e 94 df 08 	call	0x11be	; 0x11be <serial_new_instance>
     d18:	90 93 af 03 	sts	0x03AF, r25	; 0x8003af <_com_serial_instance+0x1>
     d1c:	80 93 ae 03 	sts	0x03AE, r24	; 0x8003ae <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     d20:	88 b1       	in	r24, 0x08	; 8
     d22:	83 6c       	ori	r24, 0xC3	; 195
     d24:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     d26:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     d28:	8a b1       	in	r24, 0x0a	; 10
     d2a:	84 67       	ori	r24, 0x74	; 116
     d2c:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     d2e:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     d30:	81 b1       	in	r24, 0x01	; 1
     d32:	8f ef       	ldi	r24, 0xFF	; 255
     d34:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     d36:	84 b1       	in	r24, 0x04	; 4
     d38:	83 60       	ori	r24, 0x03	; 3
     d3a:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     d3c:	84 b1       	in	r24, 0x04	; 4
     d3e:	8c 63       	ori	r24, 0x3C	; 60
     d40:	84 b9       	out	0x04, r24	; 4
}
     d42:	0f 91       	pop	r16
     d44:	ef 90       	pop	r14
     d46:	df 90       	pop	r13
     d48:	cf 90       	pop	r12
     d4a:	bf 90       	pop	r11
     d4c:	af 90       	pop	r10
     d4e:	9f 90       	pop	r9
     d50:	8f 90       	pop	r8
     d52:	08 95       	ret

00000d54 <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     d54:	95 b1       	in	r25, 0x05	; 5
     d56:	93 7c       	andi	r25, 0xC3	; 195
     d58:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     d5a:	25 b1       	in	r18, 0x05	; 5
     d5c:	34 e0       	ldi	r19, 0x04	; 4
     d5e:	83 9f       	mul	r24, r19
     d60:	c0 01       	movw	r24, r0
     d62:	11 24       	eor	r1, r1
     d64:	82 2b       	or	r24, r18
     d66:	85 b9       	out	0x05, r24	; 5
     d68:	08 95       	ret

00000d6a <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     d6a:	85 b1       	in	r24, 0x05	; 5
     d6c:	83 7c       	andi	r24, 0xC3	; 195
     d6e:	85 b9       	out	0x05, r24	; 5
     d70:	08 95       	ret

00000d72 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     d72:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     d74:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     d76:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     d78:	12 a2       	std	Z+34, r1	; 0x22
     d7a:	08 95       	ret

00000d7c <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     d7c:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     d7e:	82 a1       	ldd	r24, Z+34	; 0x22
     d80:	88 23       	and	r24, r24
     d82:	d9 f0       	breq	.+54     	; 0xdba <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     d84:	81 a1       	ldd	r24, Z+33	; 0x21
     d86:	df 01       	movw	r26, r30
     d88:	a8 0f       	add	r26, r24
     d8a:	b1 1d       	adc	r27, r1
     d8c:	8c 91       	ld	r24, X
     d8e:	db 01       	movw	r26, r22
     d90:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     d92:	21 a1       	ldd	r18, Z+33	; 0x21
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	2f 5f       	subi	r18, 0xFF	; 255
     d98:	3f 4f       	sbci	r19, 0xFF	; 255
     d9a:	2f 71       	andi	r18, 0x1F	; 31
     d9c:	30 78       	andi	r19, 0x80	; 128
     d9e:	33 23       	and	r19, r19
     da0:	34 f4       	brge	.+12     	; 0xdae <buffer_get_item+0x32>
     da2:	21 50       	subi	r18, 0x01	; 1
     da4:	31 09       	sbc	r19, r1
     da6:	20 6e       	ori	r18, 0xE0	; 224
     da8:	3f 6f       	ori	r19, 0xFF	; 255
     daa:	2f 5f       	subi	r18, 0xFF	; 255
     dac:	3f 4f       	sbci	r19, 0xFF	; 255
     dae:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     db0:	82 a1       	ldd	r24, Z+34	; 0x22
     db2:	81 50       	subi	r24, 0x01	; 1
     db4:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     db6:	80 e0       	ldi	r24, 0x00	; 0
     db8:	08 95       	ret
	}
	return BUFFER_EMPTY;
     dba:	81 e0       	ldi	r24, 0x01	; 1
}
     dbc:	08 95       	ret

00000dbe <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     dbe:	fc 01       	movw	r30, r24
     dc0:	42 a1       	ldd	r20, Z+34	; 0x22
     dc2:	40 32       	cpi	r20, 0x20	; 32
     dc4:	b8 f4       	brcc	.+46     	; 0xdf4 <buffer_put_item+0x36>
		buffer->storage[buffer->in_i] = item;
     dc6:	20 a1       	ldd	r18, Z+32	; 0x20
     dc8:	30 e0       	ldi	r19, 0x00	; 0
     dca:	e2 0f       	add	r30, r18
     dcc:	f3 1f       	adc	r31, r19
     dce:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     dd0:	2f 5f       	subi	r18, 0xFF	; 255
     dd2:	3f 4f       	sbci	r19, 0xFF	; 255
     dd4:	2f 71       	andi	r18, 0x1F	; 31
     dd6:	30 78       	andi	r19, 0x80	; 128
     dd8:	33 23       	and	r19, r19
     dda:	34 f4       	brge	.+12     	; 0xde8 <buffer_put_item+0x2a>
     ddc:	21 50       	subi	r18, 0x01	; 1
     dde:	31 09       	sbc	r19, r1
     de0:	20 6e       	ori	r18, 0xE0	; 224
     de2:	3f 6f       	ori	r19, 0xFF	; 255
     de4:	2f 5f       	subi	r18, 0xFF	; 255
     de6:	3f 4f       	sbci	r19, 0xFF	; 255
     de8:	fc 01       	movw	r30, r24
     dea:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     dec:	4f 5f       	subi	r20, 0xFF	; 255
     dee:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     df0:	80 e0       	ldi	r24, 0x00	; 0
     df2:	08 95       	ret
	}
	return BUFFER_FULL;
     df4:	82 e0       	ldi	r24, 0x02	; 2
}
     df6:	08 95       	ret

00000df8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     df8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dfa:	03 96       	adiw	r24, 0x03	; 3
     dfc:	92 83       	std	Z+2, r25	; 0x02
     dfe:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e00:	2f ef       	ldi	r18, 0xFF	; 255
     e02:	3f ef       	ldi	r19, 0xFF	; 255
     e04:	34 83       	std	Z+4, r19	; 0x04
     e06:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e08:	96 83       	std	Z+6, r25	; 0x06
     e0a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e0c:	90 87       	std	Z+8, r25	; 0x08
     e0e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e10:	10 82       	st	Z, r1
     e12:	08 95       	ret

00000e14 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     e14:	fc 01       	movw	r30, r24
     e16:	11 86       	std	Z+9, r1	; 0x09
     e18:	10 86       	std	Z+8, r1	; 0x08
     e1a:	08 95       	ret

00000e1c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e1c:	cf 93       	push	r28
     e1e:	df 93       	push	r29
     e20:	9c 01       	movw	r18, r24
     e22:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     e24:	dc 01       	movw	r26, r24
     e26:	11 96       	adiw	r26, 0x01	; 1
     e28:	cd 91       	ld	r28, X+
     e2a:	dc 91       	ld	r29, X
     e2c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     e2e:	d3 83       	std	Z+3, r29	; 0x03
     e30:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e32:	8c 81       	ldd	r24, Y+4	; 0x04
     e34:	9d 81       	ldd	r25, Y+5	; 0x05
     e36:	95 83       	std	Z+5, r25	; 0x05
     e38:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     e3a:	8c 81       	ldd	r24, Y+4	; 0x04
     e3c:	9d 81       	ldd	r25, Y+5	; 0x05
     e3e:	dc 01       	movw	r26, r24
     e40:	13 96       	adiw	r26, 0x03	; 3
     e42:	7c 93       	st	X, r23
     e44:	6e 93       	st	-X, r22
     e46:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     e48:	7d 83       	std	Y+5, r23	; 0x05
     e4a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e4c:	31 87       	std	Z+9, r19	; 0x09
     e4e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     e50:	f9 01       	movw	r30, r18
     e52:	80 81       	ld	r24, Z
     e54:	8f 5f       	subi	r24, 0xFF	; 255
     e56:	80 83       	st	Z, r24
}
     e58:	df 91       	pop	r29
     e5a:	cf 91       	pop	r28
     e5c:	08 95       	ret

00000e5e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e5e:	cf 93       	push	r28
     e60:	df 93       	push	r29
     e62:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     e64:	48 81       	ld	r20, Y
     e66:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e68:	4f 3f       	cpi	r20, 0xFF	; 255
     e6a:	2f ef       	ldi	r18, 0xFF	; 255
     e6c:	52 07       	cpc	r21, r18
     e6e:	21 f4       	brne	.+8      	; 0xe78 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e70:	fc 01       	movw	r30, r24
     e72:	a7 81       	ldd	r26, Z+7	; 0x07
     e74:	b0 85       	ldd	r27, Z+8	; 0x08
     e76:	0d c0       	rjmp	.+26     	; 0xe92 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e78:	dc 01       	movw	r26, r24
     e7a:	13 96       	adiw	r26, 0x03	; 3
     e7c:	01 c0       	rjmp	.+2      	; 0xe80 <vListInsert+0x22>
     e7e:	df 01       	movw	r26, r30
     e80:	12 96       	adiw	r26, 0x02	; 2
     e82:	ed 91       	ld	r30, X+
     e84:	fc 91       	ld	r31, X
     e86:	13 97       	sbiw	r26, 0x03	; 3
     e88:	20 81       	ld	r18, Z
     e8a:	31 81       	ldd	r19, Z+1	; 0x01
     e8c:	42 17       	cp	r20, r18
     e8e:	53 07       	cpc	r21, r19
     e90:	b0 f7       	brcc	.-20     	; 0xe7e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     e92:	12 96       	adiw	r26, 0x02	; 2
     e94:	ed 91       	ld	r30, X+
     e96:	fc 91       	ld	r31, X
     e98:	13 97       	sbiw	r26, 0x03	; 3
     e9a:	fb 83       	std	Y+3, r31	; 0x03
     e9c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     e9e:	d5 83       	std	Z+5, r29	; 0x05
     ea0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     ea2:	bd 83       	std	Y+5, r27	; 0x05
     ea4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ea6:	13 96       	adiw	r26, 0x03	; 3
     ea8:	dc 93       	st	X, r29
     eaa:	ce 93       	st	-X, r28
     eac:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     eae:	99 87       	std	Y+9, r25	; 0x09
     eb0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     eb2:	fc 01       	movw	r30, r24
     eb4:	20 81       	ld	r18, Z
     eb6:	2f 5f       	subi	r18, 0xFF	; 255
     eb8:	20 83       	st	Z, r18
}
     eba:	df 91       	pop	r29
     ebc:	cf 91       	pop	r28
     ebe:	08 95       	ret

00000ec0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
     ec4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     ec6:	a0 85       	ldd	r26, Z+8	; 0x08
     ec8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     eca:	c2 81       	ldd	r28, Z+2	; 0x02
     ecc:	d3 81       	ldd	r29, Z+3	; 0x03
     ece:	84 81       	ldd	r24, Z+4	; 0x04
     ed0:	95 81       	ldd	r25, Z+5	; 0x05
     ed2:	9d 83       	std	Y+5, r25	; 0x05
     ed4:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ed6:	c4 81       	ldd	r28, Z+4	; 0x04
     ed8:	d5 81       	ldd	r29, Z+5	; 0x05
     eda:	82 81       	ldd	r24, Z+2	; 0x02
     edc:	93 81       	ldd	r25, Z+3	; 0x03
     ede:	9b 83       	std	Y+3, r25	; 0x03
     ee0:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ee2:	11 96       	adiw	r26, 0x01	; 1
     ee4:	cd 91       	ld	r28, X+
     ee6:	dc 91       	ld	r29, X
     ee8:	12 97       	sbiw	r26, 0x02	; 2
     eea:	ce 17       	cp	r28, r30
     eec:	df 07       	cpc	r29, r31
     eee:	31 f4       	brne	.+12     	; 0xefc <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ef0:	8c 81       	ldd	r24, Y+4	; 0x04
     ef2:	9d 81       	ldd	r25, Y+5	; 0x05
     ef4:	12 96       	adiw	r26, 0x02	; 2
     ef6:	9c 93       	st	X, r25
     ef8:	8e 93       	st	-X, r24
     efa:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     efc:	11 86       	std	Z+9, r1	; 0x09
     efe:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     f00:	8c 91       	ld	r24, X
     f02:	81 50       	subi	r24, 0x01	; 1
     f04:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     f06:	df 91       	pop	r29
     f08:	cf 91       	pop	r28
     f0a:	08 95       	ret

00000f0c <pxPortInitialiseStack>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     f0c:	31 e1       	ldi	r19, 0x11	; 17
     f0e:	fc 01       	movw	r30, r24
     f10:	30 83       	st	Z, r19
     f12:	31 97       	sbiw	r30, 0x01	; 1
     f14:	22 e2       	ldi	r18, 0x22	; 34
     f16:	20 83       	st	Z, r18
     f18:	31 97       	sbiw	r30, 0x01	; 1
     f1a:	a3 e3       	ldi	r26, 0x33	; 51
     f1c:	a0 83       	st	Z, r26
     f1e:	31 97       	sbiw	r30, 0x01	; 1
     f20:	60 83       	st	Z, r22
     f22:	31 97       	sbiw	r30, 0x01	; 1
     f24:	70 83       	st	Z, r23
     f26:	31 97       	sbiw	r30, 0x01	; 1
     f28:	10 82       	st	Z, r1
     f2a:	31 97       	sbiw	r30, 0x01	; 1
     f2c:	60 e8       	ldi	r22, 0x80	; 128
     f2e:	60 83       	st	Z, r22
     f30:	31 97       	sbiw	r30, 0x01	; 1
     f32:	10 82       	st	Z, r1
     f34:	31 97       	sbiw	r30, 0x01	; 1
     f36:	62 e0       	ldi	r22, 0x02	; 2
     f38:	60 83       	st	Z, r22
     f3a:	31 97       	sbiw	r30, 0x01	; 1
     f3c:	63 e0       	ldi	r22, 0x03	; 3
     f3e:	60 83       	st	Z, r22
     f40:	31 97       	sbiw	r30, 0x01	; 1
     f42:	64 e0       	ldi	r22, 0x04	; 4
     f44:	60 83       	st	Z, r22
     f46:	31 97       	sbiw	r30, 0x01	; 1
     f48:	65 e0       	ldi	r22, 0x05	; 5
     f4a:	60 83       	st	Z, r22
     f4c:	31 97       	sbiw	r30, 0x01	; 1
     f4e:	66 e0       	ldi	r22, 0x06	; 6
     f50:	60 83       	st	Z, r22
     f52:	31 97       	sbiw	r30, 0x01	; 1
     f54:	67 e0       	ldi	r22, 0x07	; 7
     f56:	60 83       	st	Z, r22
     f58:	31 97       	sbiw	r30, 0x01	; 1
     f5a:	68 e0       	ldi	r22, 0x08	; 8
     f5c:	60 83       	st	Z, r22
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	69 e0       	ldi	r22, 0x09	; 9
     f62:	60 83       	st	Z, r22
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	60 e1       	ldi	r22, 0x10	; 16
     f68:	60 83       	st	Z, r22
     f6a:	31 97       	sbiw	r30, 0x01	; 1
     f6c:	30 83       	st	Z, r19
     f6e:	31 97       	sbiw	r30, 0x01	; 1
     f70:	32 e1       	ldi	r19, 0x12	; 18
     f72:	30 83       	st	Z, r19
     f74:	31 97       	sbiw	r30, 0x01	; 1
     f76:	33 e1       	ldi	r19, 0x13	; 19
     f78:	30 83       	st	Z, r19
     f7a:	31 97       	sbiw	r30, 0x01	; 1
     f7c:	34 e1       	ldi	r19, 0x14	; 20
     f7e:	30 83       	st	Z, r19
     f80:	31 97       	sbiw	r30, 0x01	; 1
     f82:	35 e1       	ldi	r19, 0x15	; 21
     f84:	30 83       	st	Z, r19
     f86:	31 97       	sbiw	r30, 0x01	; 1
     f88:	36 e1       	ldi	r19, 0x16	; 22
     f8a:	30 83       	st	Z, r19
     f8c:	31 97       	sbiw	r30, 0x01	; 1
     f8e:	37 e1       	ldi	r19, 0x17	; 23
     f90:	30 83       	st	Z, r19
     f92:	31 97       	sbiw	r30, 0x01	; 1
     f94:	38 e1       	ldi	r19, 0x18	; 24
     f96:	30 83       	st	Z, r19
     f98:	31 97       	sbiw	r30, 0x01	; 1
     f9a:	39 e1       	ldi	r19, 0x19	; 25
     f9c:	30 83       	st	Z, r19
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	30 e2       	ldi	r19, 0x20	; 32
     fa2:	30 83       	st	Z, r19
     fa4:	31 97       	sbiw	r30, 0x01	; 1
     fa6:	31 e2       	ldi	r19, 0x21	; 33
     fa8:	30 83       	st	Z, r19
     faa:	31 97       	sbiw	r30, 0x01	; 1
     fac:	20 83       	st	Z, r18
     fae:	31 97       	sbiw	r30, 0x01	; 1
     fb0:	23 e2       	ldi	r18, 0x23	; 35
     fb2:	20 83       	st	Z, r18
     fb4:	31 97       	sbiw	r30, 0x01	; 1
     fb6:	40 83       	st	Z, r20
     fb8:	31 97       	sbiw	r30, 0x01	; 1
     fba:	50 83       	st	Z, r21
     fbc:	31 97       	sbiw	r30, 0x01	; 1
     fbe:	26 e2       	ldi	r18, 0x26	; 38
     fc0:	20 83       	st	Z, r18
     fc2:	31 97       	sbiw	r30, 0x01	; 1
     fc4:	27 e2       	ldi	r18, 0x27	; 39
     fc6:	20 83       	st	Z, r18
     fc8:	31 97       	sbiw	r30, 0x01	; 1
     fca:	28 e2       	ldi	r18, 0x28	; 40
     fcc:	20 83       	st	Z, r18
     fce:	31 97       	sbiw	r30, 0x01	; 1
     fd0:	29 e2       	ldi	r18, 0x29	; 41
     fd2:	20 83       	st	Z, r18
     fd4:	31 97       	sbiw	r30, 0x01	; 1
     fd6:	20 e3       	ldi	r18, 0x30	; 48
     fd8:	20 83       	st	Z, r18
     fda:	31 97       	sbiw	r30, 0x01	; 1
     fdc:	21 e3       	ldi	r18, 0x31	; 49
     fde:	20 83       	st	Z, r18
     fe0:	86 97       	sbiw	r24, 0x26	; 38
     fe2:	08 95       	ret

00000fe4 <xPortStartScheduler>:
     fe4:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     fe8:	85 ee       	ldi	r24, 0xE5	; 229
     fea:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     fee:	8b e0       	ldi	r24, 0x0B	; 11
     ff0:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     ff4:	ef e6       	ldi	r30, 0x6F	; 111
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	80 81       	ld	r24, Z
     ffa:	82 60       	ori	r24, 0x02	; 2
     ffc:	80 83       	st	Z, r24
     ffe:	a0 91 cb 08 	lds	r26, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1002:	b0 91 cc 08 	lds	r27, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1006:	cd 91       	ld	r28, X+
    1008:	cd bf       	out	0x3d, r28	; 61
    100a:	dd 91       	ld	r29, X+
    100c:	de bf       	out	0x3e, r29	; 62
    100e:	ff 91       	pop	r31
    1010:	ef 91       	pop	r30
    1012:	df 91       	pop	r29
    1014:	cf 91       	pop	r28
    1016:	bf 91       	pop	r27
    1018:	af 91       	pop	r26
    101a:	9f 91       	pop	r25
    101c:	8f 91       	pop	r24
    101e:	7f 91       	pop	r23
    1020:	6f 91       	pop	r22
    1022:	5f 91       	pop	r21
    1024:	4f 91       	pop	r20
    1026:	3f 91       	pop	r19
    1028:	2f 91       	pop	r18
    102a:	1f 91       	pop	r17
    102c:	0f 91       	pop	r16
    102e:	ff 90       	pop	r15
    1030:	ef 90       	pop	r14
    1032:	df 90       	pop	r13
    1034:	cf 90       	pop	r12
    1036:	bf 90       	pop	r11
    1038:	af 90       	pop	r10
    103a:	9f 90       	pop	r9
    103c:	8f 90       	pop	r8
    103e:	7f 90       	pop	r7
    1040:	6f 90       	pop	r6
    1042:	5f 90       	pop	r5
    1044:	4f 90       	pop	r4
    1046:	3f 90       	pop	r3
    1048:	2f 90       	pop	r2
    104a:	1f 90       	pop	r1
    104c:	0f 90       	pop	r0
    104e:	0f be       	out	0x3f, r0	; 63
    1050:	0f 90       	pop	r0
    1052:	08 95       	ret
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	08 95       	ret

00001058 <vPortYield>:
    1058:	0f 92       	push	r0
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	0f 92       	push	r0
    1060:	1f 92       	push	r1
    1062:	11 24       	eor	r1, r1
    1064:	2f 92       	push	r2
    1066:	3f 92       	push	r3
    1068:	4f 92       	push	r4
    106a:	5f 92       	push	r5
    106c:	6f 92       	push	r6
    106e:	7f 92       	push	r7
    1070:	8f 92       	push	r8
    1072:	9f 92       	push	r9
    1074:	af 92       	push	r10
    1076:	bf 92       	push	r11
    1078:	cf 92       	push	r12
    107a:	df 92       	push	r13
    107c:	ef 92       	push	r14
    107e:	ff 92       	push	r15
    1080:	0f 93       	push	r16
    1082:	1f 93       	push	r17
    1084:	2f 93       	push	r18
    1086:	3f 93       	push	r19
    1088:	4f 93       	push	r20
    108a:	5f 93       	push	r21
    108c:	6f 93       	push	r22
    108e:	7f 93       	push	r23
    1090:	8f 93       	push	r24
    1092:	9f 93       	push	r25
    1094:	af 93       	push	r26
    1096:	bf 93       	push	r27
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	ef 93       	push	r30
    109e:	ff 93       	push	r31
    10a0:	a0 91 cb 08 	lds	r26, 0x08CB	; 0x8008cb <pxCurrentTCB>
    10a4:	b0 91 cc 08 	lds	r27, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    10a8:	0d b6       	in	r0, 0x3d	; 61
    10aa:	0d 92       	st	X+, r0
    10ac:	0e b6       	in	r0, 0x3e	; 62
    10ae:	0d 92       	st	X+, r0
    10b0:	0e 94 c9 10 	call	0x2192	; 0x2192 <vTaskSwitchContext>
    10b4:	a0 91 cb 08 	lds	r26, 0x08CB	; 0x8008cb <pxCurrentTCB>
    10b8:	b0 91 cc 08 	lds	r27, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    10bc:	cd 91       	ld	r28, X+
    10be:	cd bf       	out	0x3d, r28	; 61
    10c0:	dd 91       	ld	r29, X+
    10c2:	de bf       	out	0x3e, r29	; 62
    10c4:	ff 91       	pop	r31
    10c6:	ef 91       	pop	r30
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	bf 91       	pop	r27
    10ce:	af 91       	pop	r26
    10d0:	9f 91       	pop	r25
    10d2:	8f 91       	pop	r24
    10d4:	7f 91       	pop	r23
    10d6:	6f 91       	pop	r22
    10d8:	5f 91       	pop	r21
    10da:	4f 91       	pop	r20
    10dc:	3f 91       	pop	r19
    10de:	2f 91       	pop	r18
    10e0:	1f 91       	pop	r17
    10e2:	0f 91       	pop	r16
    10e4:	ff 90       	pop	r15
    10e6:	ef 90       	pop	r14
    10e8:	df 90       	pop	r13
    10ea:	cf 90       	pop	r12
    10ec:	bf 90       	pop	r11
    10ee:	af 90       	pop	r10
    10f0:	9f 90       	pop	r9
    10f2:	8f 90       	pop	r8
    10f4:	7f 90       	pop	r7
    10f6:	6f 90       	pop	r6
    10f8:	5f 90       	pop	r5
    10fa:	4f 90       	pop	r4
    10fc:	3f 90       	pop	r3
    10fe:	2f 90       	pop	r2
    1100:	1f 90       	pop	r1
    1102:	0f 90       	pop	r0
    1104:	0f be       	out	0x3f, r0	; 63
    1106:	0f 90       	pop	r0
    1108:	08 95       	ret

0000110a <__vector_13>:
	 * manual calls to taskYIELD();
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
SIGNAL(TIMER1_COMPA_vect) // IHA
	{
    110a:	1f 92       	push	r1
    110c:	0f 92       	push	r0
    110e:	0f b6       	in	r0, 0x3f	; 63
    1110:	0f 92       	push	r0
    1112:	11 24       	eor	r1, r1
    1114:	2f 93       	push	r18
    1116:	3f 93       	push	r19
    1118:	4f 93       	push	r20
    111a:	5f 93       	push	r21
    111c:	6f 93       	push	r22
    111e:	7f 93       	push	r23
    1120:	8f 93       	push	r24
    1122:	9f 93       	push	r25
    1124:	af 93       	push	r26
    1126:	bf 93       	push	r27
    1128:	ef 93       	push	r30
    112a:	ff 93       	push	r31
		xTaskIncrementTick();
    112c:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xTaskIncrementTick>
	}
    1130:	ff 91       	pop	r31
    1132:	ef 91       	pop	r30
    1134:	bf 91       	pop	r27
    1136:	af 91       	pop	r26
    1138:	9f 91       	pop	r25
    113a:	8f 91       	pop	r24
    113c:	7f 91       	pop	r23
    113e:	6f 91       	pop	r22
    1140:	5f 91       	pop	r21
    1142:	4f 91       	pop	r20
    1144:	3f 91       	pop	r19
    1146:	2f 91       	pop	r18
    1148:	0f 90       	pop	r0
    114a:	0f be       	out	0x3f, r0	; 63
    114c:	0f 90       	pop	r0
    114e:	1f 90       	pop	r1
    1150:	18 95       	reti

00001152 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1152:	cf 93       	push	r28
    1154:	df 93       	push	r29
    1156:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1158:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    115c:	80 91 b0 03 	lds	r24, 0x03B0	; 0x8003b0 <pucAlignedHeap.1965>
    1160:	90 91 b1 03 	lds	r25, 0x03B1	; 0x8003b1 <pucAlignedHeap.1965+0x1>
    1164:	89 2b       	or	r24, r25
    1166:	31 f4       	brne	.+12     	; 0x1174 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1168:	85 eb       	ldi	r24, 0xB5	; 181
    116a:	93 e0       	ldi	r25, 0x03	; 3
    116c:	90 93 b1 03 	sts	0x03B1, r25	; 0x8003b1 <pucAlignedHeap.1965+0x1>
    1170:	80 93 b0 03 	sts	0x03B0, r24	; 0x8003b0 <pucAlignedHeap.1965>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1174:	20 91 b2 03 	lds	r18, 0x03B2	; 0x8003b2 <xNextFreeByte>
    1178:	30 91 b3 03 	lds	r19, 0x03B3	; 0x8003b3 <xNextFreeByte+0x1>
    117c:	ce 01       	movw	r24, r28
    117e:	82 0f       	add	r24, r18
    1180:	93 1f       	adc	r25, r19
    1182:	85 3a       	cpi	r24, 0xA5	; 165
    1184:	44 e0       	ldi	r20, 0x04	; 4
    1186:	94 07       	cpc	r25, r20
    1188:	70 f4       	brcc	.+28     	; 0x11a6 <pvPortMalloc+0x54>
    118a:	28 17       	cp	r18, r24
    118c:	39 07       	cpc	r19, r25
    118e:	70 f4       	brcc	.+28     	; 0x11ac <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1190:	c0 91 b0 03 	lds	r28, 0x03B0	; 0x8003b0 <pucAlignedHeap.1965>
    1194:	d0 91 b1 03 	lds	r29, 0x03B1	; 0x8003b1 <pucAlignedHeap.1965+0x1>
    1198:	c2 0f       	add	r28, r18
    119a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    119c:	90 93 b3 03 	sts	0x03B3, r25	; 0x8003b3 <xNextFreeByte+0x1>
    11a0:	80 93 b2 03 	sts	0x03B2, r24	; 0x8003b2 <xNextFreeByte>
    11a4:	05 c0       	rjmp	.+10     	; 0x11b0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    11a6:	c0 e0       	ldi	r28, 0x00	; 0
    11a8:	d0 e0       	ldi	r29, 0x00	; 0
    11aa:	02 c0       	rjmp	.+4      	; 0x11b0 <pvPortMalloc+0x5e>
    11ac:	c0 e0       	ldi	r28, 0x00	; 0
    11ae:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    11b0:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    11b4:	ce 01       	movw	r24, r28
    11b6:	df 91       	pop	r29
    11b8:	cf 91       	pop	r28
    11ba:	08 95       	ret

000011bc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    11bc:	08 95       	ret

000011be <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
    11be:	4f 92       	push	r4
    11c0:	5f 92       	push	r5
    11c2:	6f 92       	push	r6
    11c4:	7f 92       	push	r7
    11c6:	8f 92       	push	r8
    11c8:	9f 92       	push	r9
    11ca:	af 92       	push	r10
    11cc:	bf 92       	push	r11
    11ce:	cf 92       	push	r12
    11d0:	df 92       	push	r13
    11d2:	ff 92       	push	r15
    11d4:	0f 93       	push	r16
    11d6:	1f 93       	push	r17
    11d8:	cf 93       	push	r28
    11da:	df 93       	push	r29
    11dc:	cd b7       	in	r28, 0x3d	; 61
    11de:	de b7       	in	r29, 0x3e	; 62
    11e0:	f8 2e       	mov	r15, r24
    11e2:	2a 01       	movw	r4, r20
    11e4:	3b 01       	movw	r6, r22
    11e6:	88 e0       	ldi	r24, 0x08	; 8
    11e8:	90 e0       	ldi	r25, 0x00	; 0
    11ea:	0e 94 33 15 	call	0x2a66	; 0x2a66 <malloc>
    11ee:	8c 01       	movw	r16, r24
    11f0:	8f 2d       	mov	r24, r15
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	88 0f       	add	r24, r24
    11f6:	99 1f       	adc	r25, r25
    11f8:	fc 01       	movw	r30, r24
    11fa:	e6 5a       	subi	r30, 0xA6	; 166
    11fc:	f7 4f       	sbci	r31, 0xF7	; 247
    11fe:	11 83       	std	Z+1, r17	; 0x01
    1200:	00 83       	st	Z, r16
    1202:	fc 01       	movw	r30, r24
    1204:	e4 5f       	subi	r30, 0xF4	; 244
    1206:	fe 4f       	sbci	r31, 0xFE	; 254
    1208:	80 81       	ld	r24, Z
    120a:	91 81       	ldd	r25, Z+1	; 0x01
    120c:	d8 01       	movw	r26, r16
    120e:	11 96       	adiw	r26, 0x01	; 1
    1210:	9c 93       	st	X, r25
    1212:	8e 93       	st	-X, r24
    1214:	13 96       	adiw	r26, 0x03	; 3
    1216:	bc 92       	st	X, r11
    1218:	ae 92       	st	-X, r10
    121a:	12 97       	sbiw	r26, 0x02	; 2
    121c:	15 96       	adiw	r26, 0x05	; 5
    121e:	dc 92       	st	X, r13
    1220:	ce 92       	st	-X, r12
    1222:	14 97       	sbiw	r26, 0x04	; 4
    1224:	17 96       	adiw	r26, 0x07	; 7
    1226:	9c 92       	st	X, r9
    1228:	8e 92       	st	-X, r8
    122a:	16 97       	sbiw	r26, 0x06	; 6
    122c:	ff b6       	in	r15, 0x3f	; 63
    122e:	f8 94       	cli
    1230:	ed 91       	ld	r30, X+
    1232:	fc 91       	ld	r31, X
    1234:	11 97       	sbiw	r26, 0x01	; 1
    1236:	36 97       	sbiw	r30, 0x06	; 6
    1238:	80 81       	ld	r24, Z
    123a:	82 60       	ori	r24, 0x02	; 2
    123c:	80 83       	st	Z, r24
    123e:	cd 90       	ld	r12, X+
    1240:	dc 90       	ld	r13, X
    1242:	d3 01       	movw	r26, r6
    1244:	c2 01       	movw	r24, r4
    1246:	88 0f       	add	r24, r24
    1248:	99 1f       	adc	r25, r25
    124a:	aa 1f       	adc	r26, r26
    124c:	bb 1f       	adc	r27, r27
    124e:	88 0f       	add	r24, r24
    1250:	99 1f       	adc	r25, r25
    1252:	aa 1f       	adc	r26, r26
    1254:	bb 1f       	adc	r27, r27
    1256:	9c 01       	movw	r18, r24
    1258:	ad 01       	movw	r20, r26
    125a:	22 0f       	add	r18, r18
    125c:	33 1f       	adc	r19, r19
    125e:	44 1f       	adc	r20, r20
    1260:	55 1f       	adc	r21, r21
    1262:	60 e0       	ldi	r22, 0x00	; 0
    1264:	70 e0       	ldi	r23, 0x00	; 0
    1266:	81 ee       	ldi	r24, 0xE1	; 225
    1268:	90 e0       	ldi	r25, 0x00	; 0
    126a:	0e 94 0b 15 	call	0x2a16	; 0x2a16 <__udivmodsi4>
    126e:	21 50       	subi	r18, 0x01	; 1
    1270:	f6 01       	movw	r30, r12
    1272:	32 97       	sbiw	r30, 0x02	; 2
    1274:	20 83       	st	Z, r18
    1276:	d8 01       	movw	r26, r16
    1278:	ed 91       	ld	r30, X+
    127a:	fc 91       	ld	r31, X
    127c:	11 97       	sbiw	r26, 0x01	; 1
    127e:	35 97       	sbiw	r30, 0x05	; 5
    1280:	88 e9       	ldi	r24, 0x98	; 152
    1282:	80 83       	st	Z, r24
    1284:	ed 91       	ld	r30, X+
    1286:	fc 91       	ld	r31, X
    1288:	34 97       	sbiw	r30, 0x04	; 4
    128a:	86 e0       	ldi	r24, 0x06	; 6
    128c:	80 83       	st	Z, r24
    128e:	ff be       	out	0x3f, r15	; 63
    1290:	c8 01       	movw	r24, r16
    1292:	df 91       	pop	r29
    1294:	cf 91       	pop	r28
    1296:	1f 91       	pop	r17
    1298:	0f 91       	pop	r16
    129a:	ff 90       	pop	r15
    129c:	df 90       	pop	r13
    129e:	cf 90       	pop	r12
    12a0:	bf 90       	pop	r11
    12a2:	af 90       	pop	r10
    12a4:	9f 90       	pop	r9
    12a6:	8f 90       	pop	r8
    12a8:	7f 90       	pop	r7
    12aa:	6f 90       	pop	r6
    12ac:	5f 90       	pop	r5
    12ae:	4f 90       	pop	r4
    12b0:	08 95       	ret

000012b2 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
    12b2:	ef 92       	push	r14
    12b4:	ff 92       	push	r15
    12b6:	0f 93       	push	r16
    12b8:	1f 93       	push	r17
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    12be:	fc 01       	movw	r30, r24
    12c0:	a2 81       	ldd	r26, Z+2	; 0x02
    12c2:	b3 81       	ldd	r27, Z+3	; 0x03
    12c4:	10 97       	sbiw	r26, 0x00	; 0
    12c6:	79 f0       	breq	.+30     	; 0x12e6 <serial_send_bytes+0x34>
    12c8:	e4 2f       	mov	r30, r20
    12ca:	f0 e0       	ldi	r31, 0x00	; 0
    12cc:	92 96       	adiw	r26, 0x22	; 34
    12ce:	5c 91       	ld	r21, X
    12d0:	20 e2       	ldi	r18, 0x20	; 32
    12d2:	30 e0       	ldi	r19, 0x00	; 0
    12d4:	25 1b       	sub	r18, r21
    12d6:	31 09       	sbc	r19, r1
    12d8:	2e 17       	cp	r18, r30
    12da:	3f 07       	cpc	r19, r31
    12dc:	1c f1       	brlt	.+70     	; 0x1324 <serial_send_bytes+0x72>
    12de:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    12e0:	41 11       	cpse	r20, r1
    12e2:	04 c0       	rjmp	.+8      	; 0x12ec <serial_send_bytes+0x3a>
    12e4:	16 c0       	rjmp	.+44     	; 0x1312 <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    12e6:	42 30       	cpi	r20, 0x02	; 2
    12e8:	f8 f4       	brcc	.+62     	; 0x1328 <serial_send_bytes+0x76>
    12ea:	f9 cf       	rjmp	.-14     	; 0x12de <serial_send_bytes+0x2c>
    12ec:	eb 01       	movw	r28, r22
    12ee:	41 50       	subi	r20, 0x01	; 1
    12f0:	04 2f       	mov	r16, r20
    12f2:	10 e0       	ldi	r17, 0x00	; 0
    12f4:	0f 5f       	subi	r16, 0xFF	; 255
    12f6:	1f 4f       	sbci	r17, 0xFF	; 255
    12f8:	06 0f       	add	r16, r22
    12fa:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
    12fc:	69 91       	ld	r22, Y+
    12fe:	d7 01       	movw	r26, r14
    1300:	12 96       	adiw	r26, 0x02	; 2
    1302:	8d 91       	ld	r24, X+
    1304:	9c 91       	ld	r25, X
    1306:	13 97       	sbiw	r26, 0x03	; 3
    1308:	0e 94 df 06 	call	0xdbe	; 0xdbe <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    130c:	c0 17       	cp	r28, r16
    130e:	d1 07       	cpc	r29, r17
    1310:	a9 f7       	brne	.-22     	; 0x12fc <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
    1312:	d7 01       	movw	r26, r14
    1314:	ed 91       	ld	r30, X+
    1316:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
    1318:	35 97       	sbiw	r30, 0x05	; 5
    131a:	80 81       	ld	r24, Z
    131c:	80 62       	ori	r24, 0x20	; 32
    131e:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
    1320:	80 e0       	ldi	r24, 0x00	; 0
    1322:	03 c0       	rjmp	.+6      	; 0x132a <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
    1324:	82 e0       	ldi	r24, 0x02	; 2
    1326:	01 c0       	rjmp	.+2      	; 0x132a <serial_send_bytes+0x78>
    1328:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
    132a:	df 91       	pop	r29
    132c:	cf 91       	pop	r28
    132e:	1f 91       	pop	r17
    1330:	0f 91       	pop	r16
    1332:	ff 90       	pop	r15
    1334:	ef 90       	pop	r14
    1336:	08 95       	ret

00001338 <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    1338:	1f 92       	push	r1
    133a:	0f 92       	push	r0
    133c:	0f b6       	in	r0, 0x3f	; 63
    133e:	0f 92       	push	r0
    1340:	11 24       	eor	r1, r1
    1342:	2f 93       	push	r18
    1344:	3f 93       	push	r19
    1346:	4f 93       	push	r20
    1348:	5f 93       	push	r21
    134a:	6f 93       	push	r22
    134c:	7f 93       	push	r23
    134e:	8f 93       	push	r24
    1350:	9f 93       	push	r25
    1352:	af 93       	push	r26
    1354:	bf 93       	push	r27
    1356:	cf 93       	push	r28
    1358:	ef 93       	push	r30
    135a:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    135c:	e0 91 5a 08 	lds	r30, 0x085A	; 0x80085a <_ser_handle>
    1360:	f0 91 5b 08 	lds	r31, 0x085B	; 0x80085b <_ser_handle+0x1>
    1364:	30 97       	sbiw	r30, 0x00	; 0
    1366:	a1 f0       	breq	.+40     	; 0x1390 <__vector_20+0x58>
		item = UDR0;
    1368:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
    136c:	6c 2f       	mov	r22, r28
    136e:	84 81       	ldd	r24, Z+4	; 0x04
    1370:	95 81       	ldd	r25, Z+5	; 0x05
    1372:	0e 94 df 06 	call	0xdbe	; 0xdbe <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
    1376:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <_ser_handle>
    137a:	90 91 5b 08 	lds	r25, 0x085B	; 0x80085b <_ser_handle+0x1>
    137e:	dc 01       	movw	r26, r24
    1380:	16 96       	adiw	r26, 0x06	; 6
    1382:	ed 91       	ld	r30, X+
    1384:	fc 91       	ld	r31, X
    1386:	17 97       	sbiw	r26, 0x07	; 7
    1388:	30 97       	sbiw	r30, 0x00	; 0
    138a:	11 f0       	breq	.+4      	; 0x1390 <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
    138c:	6c 2f       	mov	r22, r28
    138e:	09 95       	icall
		}
	}
}
    1390:	ff 91       	pop	r31
    1392:	ef 91       	pop	r30
    1394:	cf 91       	pop	r28
    1396:	bf 91       	pop	r27
    1398:	af 91       	pop	r26
    139a:	9f 91       	pop	r25
    139c:	8f 91       	pop	r24
    139e:	7f 91       	pop	r23
    13a0:	6f 91       	pop	r22
    13a2:	5f 91       	pop	r21
    13a4:	4f 91       	pop	r20
    13a6:	3f 91       	pop	r19
    13a8:	2f 91       	pop	r18
    13aa:	0f 90       	pop	r0
    13ac:	0f be       	out	0x3f, r0	; 63
    13ae:	0f 90       	pop	r0
    13b0:	1f 90       	pop	r1
    13b2:	18 95       	reti

000013b4 <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
    13b4:	1f 92       	push	r1
    13b6:	0f 92       	push	r0
    13b8:	0f b6       	in	r0, 0x3f	; 63
    13ba:	0f 92       	push	r0
    13bc:	11 24       	eor	r1, r1
    13be:	2f 93       	push	r18
    13c0:	3f 93       	push	r19
    13c2:	4f 93       	push	r20
    13c4:	5f 93       	push	r21
    13c6:	6f 93       	push	r22
    13c8:	7f 93       	push	r23
    13ca:	8f 93       	push	r24
    13cc:	9f 93       	push	r25
    13ce:	af 93       	push	r26
    13d0:	bf 93       	push	r27
    13d2:	ef 93       	push	r30
    13d4:	ff 93       	push	r31
    13d6:	cf 93       	push	r28
    13d8:	df 93       	push	r29
    13da:	1f 92       	push	r1
    13dc:	cd b7       	in	r28, 0x3d	; 61
    13de:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    13e0:	e0 91 5a 08 	lds	r30, 0x085A	; 0x80085a <_ser_handle>
    13e4:	f0 91 5b 08 	lds	r31, 0x085B	; 0x80085b <_ser_handle+0x1>
    13e8:	30 97       	sbiw	r30, 0x00	; 0
    13ea:	99 f0       	breq	.+38     	; 0x1412 <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    13ec:	be 01       	movw	r22, r28
    13ee:	6f 5f       	subi	r22, 0xFF	; 255
    13f0:	7f 4f       	sbci	r23, 0xFF	; 255
    13f2:	82 81       	ldd	r24, Z+2	; 0x02
    13f4:	93 81       	ldd	r25, Z+3	; 0x03
    13f6:	0e 94 be 06 	call	0xd7c	; 0xd7c <buffer_get_item>
    13fa:	81 11       	cpse	r24, r1
    13fc:	04 c0       	rjmp	.+8      	; 0x1406 <__vector_21+0x52>
			UDR0 = item;
    13fe:	89 81       	ldd	r24, Y+1	; 0x01
    1400:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1404:	0b c0       	rjmp	.+22     	; 0x141c <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    1406:	e1 ec       	ldi	r30, 0xC1	; 193
    1408:	f0 e0       	ldi	r31, 0x00	; 0
    140a:	80 81       	ld	r24, Z
    140c:	8f 7d       	andi	r24, 0xDF	; 223
    140e:	80 83       	st	Z, r24
    1410:	05 c0       	rjmp	.+10     	; 0x141c <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    1412:	e1 ec       	ldi	r30, 0xC1	; 193
    1414:	f0 e0       	ldi	r31, 0x00	; 0
    1416:	80 81       	ld	r24, Z
    1418:	8f 7d       	andi	r24, 0xDF	; 223
    141a:	80 83       	st	Z, r24
	}
}
    141c:	0f 90       	pop	r0
    141e:	df 91       	pop	r29
    1420:	cf 91       	pop	r28
    1422:	ff 91       	pop	r31
    1424:	ef 91       	pop	r30
    1426:	bf 91       	pop	r27
    1428:	af 91       	pop	r26
    142a:	9f 91       	pop	r25
    142c:	8f 91       	pop	r24
    142e:	7f 91       	pop	r23
    1430:	6f 91       	pop	r22
    1432:	5f 91       	pop	r21
    1434:	4f 91       	pop	r20
    1436:	3f 91       	pop	r19
    1438:	2f 91       	pop	r18
    143a:	0f 90       	pop	r0
    143c:	0f be       	out	0x3f, r0	; 63
    143e:	0f 90       	pop	r0
    1440:	1f 90       	pop	r1
    1442:	18 95       	reti

00001444 <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    1444:	1f 92       	push	r1
    1446:	0f 92       	push	r0
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	0f 92       	push	r0
    144c:	11 24       	eor	r1, r1
    144e:	2f 93       	push	r18
    1450:	3f 93       	push	r19
    1452:	4f 93       	push	r20
    1454:	5f 93       	push	r21
    1456:	6f 93       	push	r22
    1458:	7f 93       	push	r23
    145a:	8f 93       	push	r24
    145c:	9f 93       	push	r25
    145e:	af 93       	push	r26
    1460:	bf 93       	push	r27
    1462:	cf 93       	push	r28
    1464:	ef 93       	push	r30
    1466:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    1468:	e0 91 5c 08 	lds	r30, 0x085C	; 0x80085c <_ser_handle+0x2>
    146c:	f0 91 5d 08 	lds	r31, 0x085D	; 0x80085d <_ser_handle+0x3>
    1470:	30 97       	sbiw	r30, 0x00	; 0
    1472:	a1 f0       	breq	.+40     	; 0x149c <__vector_28+0x58>
		item = UDR1;
    1474:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    1478:	6c 2f       	mov	r22, r28
    147a:	84 81       	ldd	r24, Z+4	; 0x04
    147c:	95 81       	ldd	r25, Z+5	; 0x05
    147e:	0e 94 df 06 	call	0xdbe	; 0xdbe <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    1482:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <_ser_handle+0x2>
    1486:	90 91 5d 08 	lds	r25, 0x085D	; 0x80085d <_ser_handle+0x3>
    148a:	dc 01       	movw	r26, r24
    148c:	16 96       	adiw	r26, 0x06	; 6
    148e:	ed 91       	ld	r30, X+
    1490:	fc 91       	ld	r31, X
    1492:	17 97       	sbiw	r26, 0x07	; 7
    1494:	30 97       	sbiw	r30, 0x00	; 0
    1496:	11 f0       	breq	.+4      	; 0x149c <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    1498:	6c 2f       	mov	r22, r28
    149a:	09 95       	icall
		}
	}
}
    149c:	ff 91       	pop	r31
    149e:	ef 91       	pop	r30
    14a0:	cf 91       	pop	r28
    14a2:	bf 91       	pop	r27
    14a4:	af 91       	pop	r26
    14a6:	9f 91       	pop	r25
    14a8:	8f 91       	pop	r24
    14aa:	7f 91       	pop	r23
    14ac:	6f 91       	pop	r22
    14ae:	5f 91       	pop	r21
    14b0:	4f 91       	pop	r20
    14b2:	3f 91       	pop	r19
    14b4:	2f 91       	pop	r18
    14b6:	0f 90       	pop	r0
    14b8:	0f be       	out	0x3f, r0	; 63
    14ba:	0f 90       	pop	r0
    14bc:	1f 90       	pop	r1
    14be:	18 95       	reti

000014c0 <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    14c0:	1f 92       	push	r1
    14c2:	0f 92       	push	r0
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	0f 92       	push	r0
    14c8:	11 24       	eor	r1, r1
    14ca:	2f 93       	push	r18
    14cc:	3f 93       	push	r19
    14ce:	4f 93       	push	r20
    14d0:	5f 93       	push	r21
    14d2:	6f 93       	push	r22
    14d4:	7f 93       	push	r23
    14d6:	8f 93       	push	r24
    14d8:	9f 93       	push	r25
    14da:	af 93       	push	r26
    14dc:	bf 93       	push	r27
    14de:	ef 93       	push	r30
    14e0:	ff 93       	push	r31
    14e2:	cf 93       	push	r28
    14e4:	df 93       	push	r29
    14e6:	1f 92       	push	r1
    14e8:	cd b7       	in	r28, 0x3d	; 61
    14ea:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    14ec:	e0 91 5c 08 	lds	r30, 0x085C	; 0x80085c <_ser_handle+0x2>
    14f0:	f0 91 5d 08 	lds	r31, 0x085D	; 0x80085d <_ser_handle+0x3>
    14f4:	30 97       	sbiw	r30, 0x00	; 0
    14f6:	99 f0       	breq	.+38     	; 0x151e <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    14f8:	be 01       	movw	r22, r28
    14fa:	6f 5f       	subi	r22, 0xFF	; 255
    14fc:	7f 4f       	sbci	r23, 0xFF	; 255
    14fe:	82 81       	ldd	r24, Z+2	; 0x02
    1500:	93 81       	ldd	r25, Z+3	; 0x03
    1502:	0e 94 be 06 	call	0xd7c	; 0xd7c <buffer_get_item>
    1506:	81 11       	cpse	r24, r1
    1508:	04 c0       	rjmp	.+8      	; 0x1512 <__vector_29+0x52>
			UDR1 = item;
    150a:	89 81       	ldd	r24, Y+1	; 0x01
    150c:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1510:	0b c0       	rjmp	.+22     	; 0x1528 <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    1512:	e9 ec       	ldi	r30, 0xC9	; 201
    1514:	f0 e0       	ldi	r31, 0x00	; 0
    1516:	80 81       	ld	r24, Z
    1518:	8f 7d       	andi	r24, 0xDF	; 223
    151a:	80 83       	st	Z, r24
    151c:	05 c0       	rjmp	.+10     	; 0x1528 <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    151e:	e9 ec       	ldi	r30, 0xC9	; 201
    1520:	f0 e0       	ldi	r31, 0x00	; 0
    1522:	80 81       	ld	r24, Z
    1524:	8f 7d       	andi	r24, 0xDF	; 223
    1526:	80 83       	st	Z, r24
	}
}
    1528:	0f 90       	pop	r0
    152a:	df 91       	pop	r29
    152c:	cf 91       	pop	r28
    152e:	ff 91       	pop	r31
    1530:	ef 91       	pop	r30
    1532:	bf 91       	pop	r27
    1534:	af 91       	pop	r26
    1536:	9f 91       	pop	r25
    1538:	8f 91       	pop	r24
    153a:	7f 91       	pop	r23
    153c:	6f 91       	pop	r22
    153e:	5f 91       	pop	r21
    1540:	4f 91       	pop	r20
    1542:	3f 91       	pop	r19
    1544:	2f 91       	pop	r18
    1546:	0f 90       	pop	r0
    1548:	0f be       	out	0x3f, r0	; 63
    154a:	0f 90       	pop	r0
    154c:	1f 90       	pop	r1
    154e:	18 95       	reti

00001550 <prvCopyDataToQueue>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1550:	0f 93       	push	r16
    1552:	1f 93       	push	r17
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	ec 01       	movw	r28, r24
    155a:	04 2f       	mov	r16, r20
    155c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    155e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1560:	81 11       	cpse	r24, r1
    1562:	0c c0       	rjmp	.+24     	; 0x157c <prvCopyDataToQueue+0x2c>
    1564:	88 81       	ld	r24, Y
    1566:	99 81       	ldd	r25, Y+1	; 0x01
    1568:	89 2b       	or	r24, r25
    156a:	09 f0       	breq	.+2      	; 0x156e <prvCopyDataToQueue+0x1e>
    156c:	44 c0       	rjmp	.+136    	; 0x15f6 <prvCopyDataToQueue+0xa6>
    156e:	8a 81       	ldd	r24, Y+2	; 0x02
    1570:	9b 81       	ldd	r25, Y+3	; 0x03
    1572:	0e 94 63 12 	call	0x24c6	; 0x24c6 <xTaskPriorityDisinherit>
    1576:	1b 82       	std	Y+3, r1	; 0x03
    1578:	1a 82       	std	Y+2, r1	; 0x02
    157a:	44 c0       	rjmp	.+136    	; 0x1604 <prvCopyDataToQueue+0xb4>
    157c:	41 11       	cpse	r20, r1
    157e:	18 c0       	rjmp	.+48     	; 0x15b0 <prvCopyDataToQueue+0x60>
    1580:	48 2f       	mov	r20, r24
    1582:	50 e0       	ldi	r21, 0x00	; 0
    1584:	8c 81       	ldd	r24, Y+4	; 0x04
    1586:	9d 81       	ldd	r25, Y+5	; 0x05
    1588:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <memcpy>
    158c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    158e:	8c 81       	ldd	r24, Y+4	; 0x04
    1590:	9d 81       	ldd	r25, Y+5	; 0x05
    1592:	82 0f       	add	r24, r18
    1594:	91 1d       	adc	r25, r1
    1596:	9d 83       	std	Y+5, r25	; 0x05
    1598:	8c 83       	std	Y+4, r24	; 0x04
    159a:	2a 81       	ldd	r18, Y+2	; 0x02
    159c:	3b 81       	ldd	r19, Y+3	; 0x03
    159e:	82 17       	cp	r24, r18
    15a0:	93 07       	cpc	r25, r19
    15a2:	58 f1       	brcs	.+86     	; 0x15fa <prvCopyDataToQueue+0xaa>
    15a4:	88 81       	ld	r24, Y
    15a6:	99 81       	ldd	r25, Y+1	; 0x01
    15a8:	9d 83       	std	Y+5, r25	; 0x05
    15aa:	8c 83       	std	Y+4, r24	; 0x04
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	2a c0       	rjmp	.+84     	; 0x1604 <prvCopyDataToQueue+0xb4>
    15b0:	48 2f       	mov	r20, r24
    15b2:	50 e0       	ldi	r21, 0x00	; 0
    15b4:	8e 81       	ldd	r24, Y+6	; 0x06
    15b6:	9f 81       	ldd	r25, Y+7	; 0x07
    15b8:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <memcpy>
    15bc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	91 95       	neg	r25
    15c2:	81 95       	neg	r24
    15c4:	91 09       	sbc	r25, r1
    15c6:	2e 81       	ldd	r18, Y+6	; 0x06
    15c8:	3f 81       	ldd	r19, Y+7	; 0x07
    15ca:	28 0f       	add	r18, r24
    15cc:	39 1f       	adc	r19, r25
    15ce:	3f 83       	std	Y+7, r19	; 0x07
    15d0:	2e 83       	std	Y+6, r18	; 0x06
    15d2:	48 81       	ld	r20, Y
    15d4:	59 81       	ldd	r21, Y+1	; 0x01
    15d6:	24 17       	cp	r18, r20
    15d8:	35 07       	cpc	r19, r21
    15da:	30 f4       	brcc	.+12     	; 0x15e8 <prvCopyDataToQueue+0x98>
    15dc:	2a 81       	ldd	r18, Y+2	; 0x02
    15de:	3b 81       	ldd	r19, Y+3	; 0x03
    15e0:	82 0f       	add	r24, r18
    15e2:	93 1f       	adc	r25, r19
    15e4:	9f 83       	std	Y+7, r25	; 0x07
    15e6:	8e 83       	std	Y+6, r24	; 0x06
    15e8:	02 30       	cpi	r16, 0x02	; 2
    15ea:	49 f4       	brne	.+18     	; 0x15fe <prvCopyDataToQueue+0xae>
    15ec:	11 23       	and	r17, r17
    15ee:	49 f0       	breq	.+18     	; 0x1602 <prvCopyDataToQueue+0xb2>
    15f0:	11 50       	subi	r17, 0x01	; 1
    15f2:	80 e0       	ldi	r24, 0x00	; 0
    15f4:	07 c0       	rjmp	.+14     	; 0x1604 <prvCopyDataToQueue+0xb4>
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	05 c0       	rjmp	.+10     	; 0x1604 <prvCopyDataToQueue+0xb4>
    15fa:	80 e0       	ldi	r24, 0x00	; 0
    15fc:	03 c0       	rjmp	.+6      	; 0x1604 <prvCopyDataToQueue+0xb4>
    15fe:	80 e0       	ldi	r24, 0x00	; 0
    1600:	01 c0       	rjmp	.+2      	; 0x1604 <prvCopyDataToQueue+0xb4>
    1602:	80 e0       	ldi	r24, 0x00	; 0
    1604:	1f 5f       	subi	r17, 0xFF	; 255
    1606:	1a 8f       	std	Y+26, r17	; 0x1a
    1608:	df 91       	pop	r29
    160a:	cf 91       	pop	r28
    160c:	1f 91       	pop	r17
    160e:	0f 91       	pop	r16
    1610:	08 95       	ret

00001612 <prvCopyDataFromQueue>:
    1612:	fc 01       	movw	r30, r24
    1614:	44 8d       	ldd	r20, Z+28	; 0x1c
    1616:	44 23       	and	r20, r20
    1618:	a9 f0       	breq	.+42     	; 0x1644 <prvCopyDataFromQueue+0x32>
    161a:	50 e0       	ldi	r21, 0x00	; 0
    161c:	26 81       	ldd	r18, Z+6	; 0x06
    161e:	37 81       	ldd	r19, Z+7	; 0x07
    1620:	24 0f       	add	r18, r20
    1622:	35 1f       	adc	r19, r21
    1624:	37 83       	std	Z+7, r19	; 0x07
    1626:	26 83       	std	Z+6, r18	; 0x06
    1628:	82 81       	ldd	r24, Z+2	; 0x02
    162a:	93 81       	ldd	r25, Z+3	; 0x03
    162c:	28 17       	cp	r18, r24
    162e:	39 07       	cpc	r19, r25
    1630:	20 f0       	brcs	.+8      	; 0x163a <prvCopyDataFromQueue+0x28>
    1632:	80 81       	ld	r24, Z
    1634:	91 81       	ldd	r25, Z+1	; 0x01
    1636:	97 83       	std	Z+7, r25	; 0x07
    1638:	86 83       	std	Z+6, r24	; 0x06
    163a:	cb 01       	movw	r24, r22
    163c:	66 81       	ldd	r22, Z+6	; 0x06
    163e:	77 81       	ldd	r23, Z+7	; 0x07
    1640:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <memcpy>
    1644:	08 95       	ret

00001646 <prvUnlockQueue>:
    1646:	ef 92       	push	r14
    1648:	ff 92       	push	r15
    164a:	0f 93       	push	r16
    164c:	1f 93       	push	r17
    164e:	cf 93       	push	r28
    1650:	8c 01       	movw	r16, r24
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	f8 94       	cli
    1656:	0f 92       	push	r0
    1658:	fc 01       	movw	r30, r24
    165a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    165c:	1c 16       	cp	r1, r28
    165e:	ac f4       	brge	.+42     	; 0x168a <prvUnlockQueue+0x44>
    1660:	81 89       	ldd	r24, Z+17	; 0x11
    1662:	81 11       	cpse	r24, r1
    1664:	06 c0       	rjmp	.+12     	; 0x1672 <prvUnlockQueue+0x2c>
    1666:	11 c0       	rjmp	.+34     	; 0x168a <prvUnlockQueue+0x44>
    1668:	f8 01       	movw	r30, r16
    166a:	91 89       	ldd	r25, Z+17	; 0x11
    166c:	91 11       	cpse	r25, r1
    166e:	05 c0       	rjmp	.+10     	; 0x167a <prvUnlockQueue+0x34>
    1670:	0c c0       	rjmp	.+24     	; 0x168a <prvUnlockQueue+0x44>
    1672:	78 01       	movw	r14, r16
    1674:	f1 e1       	ldi	r31, 0x11	; 17
    1676:	ef 0e       	add	r14, r31
    1678:	f1 1c       	adc	r15, r1
    167a:	c7 01       	movw	r24, r14
    167c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskRemoveFromEventList>
    1680:	81 11       	cpse	r24, r1
    1682:	0e 94 ef 11 	call	0x23de	; 0x23de <vTaskMissedYield>
    1686:	c1 50       	subi	r28, 0x01	; 1
    1688:	79 f7       	brne	.-34     	; 0x1668 <prvUnlockQueue+0x22>
    168a:	8f ef       	ldi	r24, 0xFF	; 255
    168c:	f8 01       	movw	r30, r16
    168e:	86 8f       	std	Z+30, r24	; 0x1e
    1690:	0f 90       	pop	r0
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	0f 92       	push	r0
    169a:	c5 8d       	ldd	r28, Z+29	; 0x1d
    169c:	1c 16       	cp	r1, r28
    169e:	ac f4       	brge	.+42     	; 0x16ca <prvUnlockQueue+0x84>
    16a0:	80 85       	ldd	r24, Z+8	; 0x08
    16a2:	81 11       	cpse	r24, r1
    16a4:	06 c0       	rjmp	.+12     	; 0x16b2 <prvUnlockQueue+0x6c>
    16a6:	11 c0       	rjmp	.+34     	; 0x16ca <prvUnlockQueue+0x84>
    16a8:	f8 01       	movw	r30, r16
    16aa:	90 85       	ldd	r25, Z+8	; 0x08
    16ac:	91 11       	cpse	r25, r1
    16ae:	05 c0       	rjmp	.+10     	; 0x16ba <prvUnlockQueue+0x74>
    16b0:	0c c0       	rjmp	.+24     	; 0x16ca <prvUnlockQueue+0x84>
    16b2:	78 01       	movw	r14, r16
    16b4:	f8 e0       	ldi	r31, 0x08	; 8
    16b6:	ef 0e       	add	r14, r31
    16b8:	f1 1c       	adc	r15, r1
    16ba:	c7 01       	movw	r24, r14
    16bc:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskRemoveFromEventList>
    16c0:	81 11       	cpse	r24, r1
    16c2:	0e 94 ef 11 	call	0x23de	; 0x23de <vTaskMissedYield>
    16c6:	c1 50       	subi	r28, 0x01	; 1
    16c8:	79 f7       	brne	.-34     	; 0x16a8 <prvUnlockQueue+0x62>
    16ca:	8f ef       	ldi	r24, 0xFF	; 255
    16cc:	f8 01       	movw	r30, r16
    16ce:	85 8f       	std	Z+29, r24	; 0x1d
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	cf 91       	pop	r28
    16d6:	1f 91       	pop	r17
    16d8:	0f 91       	pop	r16
    16da:	ff 90       	pop	r15
    16dc:	ef 90       	pop	r14
    16de:	08 95       	ret

000016e0 <xQueueGenericReset>:
    16e0:	cf 93       	push	r28
    16e2:	df 93       	push	r29
    16e4:	ec 01       	movw	r28, r24
    16e6:	0f b6       	in	r0, 0x3f	; 63
    16e8:	f8 94       	cli
    16ea:	0f 92       	push	r0
    16ec:	48 81       	ld	r20, Y
    16ee:	59 81       	ldd	r21, Y+1	; 0x01
    16f0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    16f6:	72 9f       	mul	r23, r18
    16f8:	c0 01       	movw	r24, r0
    16fa:	73 9f       	mul	r23, r19
    16fc:	90 0d       	add	r25, r0
    16fe:	11 24       	eor	r1, r1
    1700:	fa 01       	movw	r30, r20
    1702:	e8 0f       	add	r30, r24
    1704:	f9 1f       	adc	r31, r25
    1706:	fb 83       	std	Y+3, r31	; 0x03
    1708:	ea 83       	std	Y+2, r30	; 0x02
    170a:	1a 8e       	std	Y+26, r1	; 0x1a
    170c:	5d 83       	std	Y+5, r21	; 0x05
    170e:	4c 83       	std	Y+4, r20	; 0x04
    1710:	82 1b       	sub	r24, r18
    1712:	93 0b       	sbc	r25, r19
    1714:	84 0f       	add	r24, r20
    1716:	95 1f       	adc	r25, r21
    1718:	9f 83       	std	Y+7, r25	; 0x07
    171a:	8e 83       	std	Y+6, r24	; 0x06
    171c:	8f ef       	ldi	r24, 0xFF	; 255
    171e:	8d 8f       	std	Y+29, r24	; 0x1d
    1720:	8e 8f       	std	Y+30, r24	; 0x1e
    1722:	61 11       	cpse	r22, r1
    1724:	08 c0       	rjmp	.+16     	; 0x1736 <xQueueGenericReset+0x56>
    1726:	88 85       	ldd	r24, Y+8	; 0x08
    1728:	88 23       	and	r24, r24
    172a:	69 f0       	breq	.+26     	; 0x1746 <xQueueGenericReset+0x66>
    172c:	ce 01       	movw	r24, r28
    172e:	08 96       	adiw	r24, 0x08	; 8
    1730:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskRemoveFromEventList>
    1734:	08 c0       	rjmp	.+16     	; 0x1746 <xQueueGenericReset+0x66>
    1736:	ce 01       	movw	r24, r28
    1738:	08 96       	adiw	r24, 0x08	; 8
    173a:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
    173e:	ce 01       	movw	r24, r28
    1740:	41 96       	adiw	r24, 0x11	; 17
    1742:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
    1746:	0f 90       	pop	r0
    1748:	0f be       	out	0x3f, r0	; 63
    174a:	81 e0       	ldi	r24, 0x01	; 1
    174c:	df 91       	pop	r29
    174e:	cf 91       	pop	r28
    1750:	08 95       	ret

00001752 <xQueueGenericCreate>:
    1752:	ff 92       	push	r15
    1754:	0f 93       	push	r16
    1756:	1f 93       	push	r17
    1758:	cf 93       	push	r28
    175a:	df 93       	push	r29
    175c:	08 2f       	mov	r16, r24
    175e:	16 2f       	mov	r17, r22
    1760:	f4 2e       	mov	r15, r20
    1762:	66 23       	and	r22, r22
    1764:	c9 f0       	breq	.+50     	; 0x1798 <xQueueGenericCreate+0x46>
    1766:	86 9f       	mul	r24, r22
    1768:	c0 01       	movw	r24, r0
    176a:	11 24       	eor	r1, r1
    176c:	81 96       	adiw	r24, 0x21	; 33
    176e:	0e 94 a9 08 	call	0x1152	; 0x1152 <pvPortMalloc>
    1772:	ec 01       	movw	r28, r24
    1774:	00 97       	sbiw	r24, 0x00	; 0
    1776:	49 f4       	brne	.+18     	; 0x178a <xQueueGenericCreate+0x38>
    1778:	16 c0       	rjmp	.+44     	; 0x17a6 <xQueueGenericCreate+0x54>
    177a:	0b 8f       	std	Y+27, r16	; 0x1b
    177c:	1c 8f       	std	Y+28, r17	; 0x1c
    177e:	61 e0       	ldi	r22, 0x01	; 1
    1780:	ce 01       	movw	r24, r28
    1782:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <xQueueGenericReset>
    1786:	f8 a2       	std	Y+32, r15	; 0x20
    1788:	0e c0       	rjmp	.+28     	; 0x17a6 <xQueueGenericCreate+0x54>
    178a:	81 96       	adiw	r24, 0x21	; 33
    178c:	99 83       	std	Y+1, r25	; 0x01
    178e:	88 83       	st	Y, r24
    1790:	f4 cf       	rjmp	.-24     	; 0x177a <xQueueGenericCreate+0x28>
    1792:	d9 83       	std	Y+1, r29	; 0x01
    1794:	c8 83       	st	Y, r28
    1796:	f1 cf       	rjmp	.-30     	; 0x177a <xQueueGenericCreate+0x28>
    1798:	81 e2       	ldi	r24, 0x21	; 33
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	0e 94 a9 08 	call	0x1152	; 0x1152 <pvPortMalloc>
    17a0:	ec 01       	movw	r28, r24
    17a2:	89 2b       	or	r24, r25
    17a4:	b1 f7       	brne	.-20     	; 0x1792 <xQueueGenericCreate+0x40>
    17a6:	ce 01       	movw	r24, r28
    17a8:	df 91       	pop	r29
    17aa:	cf 91       	pop	r28
    17ac:	1f 91       	pop	r17
    17ae:	0f 91       	pop	r16
    17b0:	ff 90       	pop	r15
    17b2:	08 95       	ret

000017b4 <xQueueGenericSend>:
    17b4:	9f 92       	push	r9
    17b6:	af 92       	push	r10
    17b8:	bf 92       	push	r11
    17ba:	cf 92       	push	r12
    17bc:	df 92       	push	r13
    17be:	ef 92       	push	r14
    17c0:	ff 92       	push	r15
    17c2:	0f 93       	push	r16
    17c4:	1f 93       	push	r17
    17c6:	cf 93       	push	r28
    17c8:	df 93       	push	r29
    17ca:	00 d0       	rcall	.+0      	; 0x17cc <xQueueGenericSend+0x18>
    17cc:	00 d0       	rcall	.+0      	; 0x17ce <xQueueGenericSend+0x1a>
    17ce:	1f 92       	push	r1
    17d0:	cd b7       	in	r28, 0x3d	; 61
    17d2:	de b7       	in	r29, 0x3e	; 62
    17d4:	8c 01       	movw	r16, r24
    17d6:	6b 01       	movw	r12, r22
    17d8:	5d 83       	std	Y+5, r21	; 0x05
    17da:	4c 83       	std	Y+4, r20	; 0x04
    17dc:	a2 2e       	mov	r10, r18
    17de:	b1 2c       	mov	r11, r1
    17e0:	99 24       	eor	r9, r9
    17e2:	93 94       	inc	r9
    17e4:	7c 01       	movw	r14, r24
    17e6:	88 e0       	ldi	r24, 0x08	; 8
    17e8:	e8 0e       	add	r14, r24
    17ea:	f1 1c       	adc	r15, r1
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	f8 94       	cli
    17f0:	0f 92       	push	r0
    17f2:	f8 01       	movw	r30, r16
    17f4:	32 8d       	ldd	r19, Z+26	; 0x1a
    17f6:	93 8d       	ldd	r25, Z+27	; 0x1b
    17f8:	39 17       	cp	r19, r25
    17fa:	18 f0       	brcs	.+6      	; 0x1802 <xQueueGenericSend+0x4e>
    17fc:	f2 e0       	ldi	r31, 0x02	; 2
    17fe:	af 12       	cpse	r10, r31
    1800:	11 c0       	rjmp	.+34     	; 0x1824 <xQueueGenericSend+0x70>
    1802:	4a 2d       	mov	r20, r10
    1804:	b6 01       	movw	r22, r12
    1806:	c8 01       	movw	r24, r16
    1808:	0e 94 a8 0a 	call	0x1550	; 0x1550 <prvCopyDataToQueue>
    180c:	f8 01       	movw	r30, r16
    180e:	81 89       	ldd	r24, Z+17	; 0x11
    1810:	88 23       	and	r24, r24
    1812:	21 f0       	breq	.+8      	; 0x181c <xQueueGenericSend+0x68>
    1814:	c8 01       	movw	r24, r16
    1816:	41 96       	adiw	r24, 0x11	; 17
    1818:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskRemoveFromEventList>
    181c:	0f 90       	pop	r0
    181e:	0f be       	out	0x3f, r0	; 63
    1820:	81 e0       	ldi	r24, 0x01	; 1
    1822:	50 c0       	rjmp	.+160    	; 0x18c4 <xQueueGenericSend+0x110>
    1824:	ec 81       	ldd	r30, Y+4	; 0x04
    1826:	fd 81       	ldd	r31, Y+5	; 0x05
    1828:	ef 2b       	or	r30, r31
    182a:	21 f4       	brne	.+8      	; 0x1834 <xQueueGenericSend+0x80>
    182c:	0f 90       	pop	r0
    182e:	0f be       	out	0x3f, r0	; 63
    1830:	80 e0       	ldi	r24, 0x00	; 0
    1832:	48 c0       	rjmp	.+144    	; 0x18c4 <xQueueGenericSend+0x110>
    1834:	b1 10       	cpse	r11, r1
    1836:	05 c0       	rjmp	.+10     	; 0x1842 <xQueueGenericSend+0x8e>
    1838:	ce 01       	movw	r24, r28
    183a:	01 96       	adiw	r24, 0x01	; 1
    183c:	0e 94 b2 11 	call	0x2364	; 0x2364 <vTaskSetTimeOutState>
    1840:	b9 2c       	mov	r11, r9
    1842:	0f 90       	pop	r0
    1844:	0f be       	out	0x3f, r0	; 63
    1846:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskSuspendAll>
    184a:	0f b6       	in	r0, 0x3f	; 63
    184c:	f8 94       	cli
    184e:	0f 92       	push	r0
    1850:	f8 01       	movw	r30, r16
    1852:	85 8d       	ldd	r24, Z+29	; 0x1d
    1854:	8f 3f       	cpi	r24, 0xFF	; 255
    1856:	09 f4       	brne	.+2      	; 0x185a <xQueueGenericSend+0xa6>
    1858:	15 8e       	std	Z+29, r1	; 0x1d
    185a:	f8 01       	movw	r30, r16
    185c:	86 8d       	ldd	r24, Z+30	; 0x1e
    185e:	8f 3f       	cpi	r24, 0xFF	; 255
    1860:	09 f4       	brne	.+2      	; 0x1864 <xQueueGenericSend+0xb0>
    1862:	16 8e       	std	Z+30, r1	; 0x1e
    1864:	0f 90       	pop	r0
    1866:	0f be       	out	0x3f, r0	; 63
    1868:	be 01       	movw	r22, r28
    186a:	6c 5f       	subi	r22, 0xFC	; 252
    186c:	7f 4f       	sbci	r23, 0xFF	; 255
    186e:	ce 01       	movw	r24, r28
    1870:	01 96       	adiw	r24, 0x01	; 1
    1872:	0e 94 bd 11 	call	0x237a	; 0x237a <xTaskCheckForTimeOut>
    1876:	81 11       	cpse	r24, r1
    1878:	1f c0       	rjmp	.+62     	; 0x18b8 <xQueueGenericSend+0x104>
    187a:	0f b6       	in	r0, 0x3f	; 63
    187c:	f8 94       	cli
    187e:	0f 92       	push	r0
    1880:	f8 01       	movw	r30, r16
    1882:	92 8d       	ldd	r25, Z+26	; 0x1a
    1884:	0f 90       	pop	r0
    1886:	0f be       	out	0x3f, r0	; 63
    1888:	83 8d       	ldd	r24, Z+27	; 0x1b
    188a:	98 13       	cpse	r25, r24
    188c:	0f c0       	rjmp	.+30     	; 0x18ac <xQueueGenericSend+0xf8>
    188e:	6c 81       	ldd	r22, Y+4	; 0x04
    1890:	7d 81       	ldd	r23, Y+5	; 0x05
    1892:	c7 01       	movw	r24, r14
    1894:	0e 94 3d 11 	call	0x227a	; 0x227a <vTaskPlaceOnEventList>
    1898:	c8 01       	movw	r24, r16
    189a:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvUnlockQueue>
    189e:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    18a2:	81 11       	cpse	r24, r1
    18a4:	a3 cf       	rjmp	.-186    	; 0x17ec <xQueueGenericSend+0x38>
    18a6:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    18aa:	a0 cf       	rjmp	.-192    	; 0x17ec <xQueueGenericSend+0x38>
    18ac:	c8 01       	movw	r24, r16
    18ae:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvUnlockQueue>
    18b2:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    18b6:	9a cf       	rjmp	.-204    	; 0x17ec <xQueueGenericSend+0x38>
    18b8:	c8 01       	movw	r24, r16
    18ba:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvUnlockQueue>
    18be:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	0f 90       	pop	r0
    18c6:	0f 90       	pop	r0
    18c8:	0f 90       	pop	r0
    18ca:	0f 90       	pop	r0
    18cc:	0f 90       	pop	r0
    18ce:	df 91       	pop	r29
    18d0:	cf 91       	pop	r28
    18d2:	1f 91       	pop	r17
    18d4:	0f 91       	pop	r16
    18d6:	ff 90       	pop	r15
    18d8:	ef 90       	pop	r14
    18da:	df 90       	pop	r13
    18dc:	cf 90       	pop	r12
    18de:	bf 90       	pop	r11
    18e0:	af 90       	pop	r10
    18e2:	9f 90       	pop	r9
    18e4:	08 95       	ret

000018e6 <xQueueCreateMutex>:
    18e6:	cf 93       	push	r28
    18e8:	df 93       	push	r29
    18ea:	48 2f       	mov	r20, r24
    18ec:	60 e0       	ldi	r22, 0x00	; 0
    18ee:	81 e0       	ldi	r24, 0x01	; 1
    18f0:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericCreate>
    18f4:	ec 01       	movw	r28, r24
    18f6:	00 97       	sbiw	r24, 0x00	; 0
    18f8:	61 f0       	breq	.+24     	; 0x1912 <xQueueCreateMutex+0x2c>
    18fa:	1b 82       	std	Y+3, r1	; 0x03
    18fc:	1a 82       	std	Y+2, r1	; 0x02
    18fe:	19 82       	std	Y+1, r1	; 0x01
    1900:	18 82       	st	Y, r1
    1902:	1e 82       	std	Y+6, r1	; 0x06
    1904:	20 e0       	ldi	r18, 0x00	; 0
    1906:	40 e0       	ldi	r20, 0x00	; 0
    1908:	50 e0       	ldi	r21, 0x00	; 0
    190a:	60 e0       	ldi	r22, 0x00	; 0
    190c:	70 e0       	ldi	r23, 0x00	; 0
    190e:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
    1912:	ce 01       	movw	r24, r28
    1914:	df 91       	pop	r29
    1916:	cf 91       	pop	r28
    1918:	08 95       	ret

0000191a <xQueueGenericSendFromISR>:
    191a:	ef 92       	push	r14
    191c:	ff 92       	push	r15
    191e:	0f 93       	push	r16
    1920:	1f 93       	push	r17
    1922:	cf 93       	push	r28
    1924:	df 93       	push	r29
    1926:	8a 01       	movw	r16, r20
    1928:	fc 01       	movw	r30, r24
    192a:	52 8d       	ldd	r21, Z+26	; 0x1a
    192c:	33 8d       	ldd	r19, Z+27	; 0x1b
    192e:	53 17       	cp	r21, r19
    1930:	10 f0       	brcs	.+4      	; 0x1936 <xQueueGenericSendFromISR+0x1c>
    1932:	22 30       	cpi	r18, 0x02	; 2
    1934:	f1 f4       	brne	.+60     	; 0x1972 <xQueueGenericSendFromISR+0x58>
    1936:	42 2f       	mov	r20, r18
    1938:	78 01       	movw	r14, r16
    193a:	ec 01       	movw	r28, r24
    193c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    193e:	0e 94 a8 0a 	call	0x1550	; 0x1550 <prvCopyDataToQueue>
    1942:	1f 3f       	cpi	r17, 0xFF	; 255
    1944:	81 f4       	brne	.+32     	; 0x1966 <xQueueGenericSendFromISR+0x4c>
    1946:	89 89       	ldd	r24, Y+17	; 0x11
    1948:	88 23       	and	r24, r24
    194a:	a9 f0       	breq	.+42     	; 0x1976 <xQueueGenericSendFromISR+0x5c>
    194c:	ce 01       	movw	r24, r28
    194e:	41 96       	adiw	r24, 0x11	; 17
    1950:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskRemoveFromEventList>
    1954:	88 23       	and	r24, r24
    1956:	89 f0       	breq	.+34     	; 0x197a <xQueueGenericSendFromISR+0x60>
    1958:	e1 14       	cp	r14, r1
    195a:	f1 04       	cpc	r15, r1
    195c:	81 f0       	breq	.+32     	; 0x197e <xQueueGenericSendFromISR+0x64>
    195e:	81 e0       	ldi	r24, 0x01	; 1
    1960:	f7 01       	movw	r30, r14
    1962:	80 83       	st	Z, r24
    1964:	0d c0       	rjmp	.+26     	; 0x1980 <xQueueGenericSendFromISR+0x66>
    1966:	ff 24       	eor	r15, r15
    1968:	f3 94       	inc	r15
    196a:	f1 0e       	add	r15, r17
    196c:	fe 8e       	std	Y+30, r15	; 0x1e
    196e:	81 e0       	ldi	r24, 0x01	; 1
    1970:	07 c0       	rjmp	.+14     	; 0x1980 <xQueueGenericSendFromISR+0x66>
    1972:	80 e0       	ldi	r24, 0x00	; 0
    1974:	05 c0       	rjmp	.+10     	; 0x1980 <xQueueGenericSendFromISR+0x66>
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	03 c0       	rjmp	.+6      	; 0x1980 <xQueueGenericSendFromISR+0x66>
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	01 c0       	rjmp	.+2      	; 0x1980 <xQueueGenericSendFromISR+0x66>
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	df 91       	pop	r29
    1982:	cf 91       	pop	r28
    1984:	1f 91       	pop	r17
    1986:	0f 91       	pop	r16
    1988:	ff 90       	pop	r15
    198a:	ef 90       	pop	r14
    198c:	08 95       	ret

0000198e <xQueueGenericReceive>:
    198e:	8f 92       	push	r8
    1990:	9f 92       	push	r9
    1992:	af 92       	push	r10
    1994:	bf 92       	push	r11
    1996:	cf 92       	push	r12
    1998:	df 92       	push	r13
    199a:	ef 92       	push	r14
    199c:	ff 92       	push	r15
    199e:	0f 93       	push	r16
    19a0:	1f 93       	push	r17
    19a2:	cf 93       	push	r28
    19a4:	df 93       	push	r29
    19a6:	00 d0       	rcall	.+0      	; 0x19a8 <xQueueGenericReceive+0x1a>
    19a8:	00 d0       	rcall	.+0      	; 0x19aa <xQueueGenericReceive+0x1c>
    19aa:	1f 92       	push	r1
    19ac:	cd b7       	in	r28, 0x3d	; 61
    19ae:	de b7       	in	r29, 0x3e	; 62
    19b0:	8c 01       	movw	r16, r24
    19b2:	5b 01       	movw	r10, r22
    19b4:	5d 83       	std	Y+5, r21	; 0x05
    19b6:	4c 83       	std	Y+4, r20	; 0x04
    19b8:	82 2e       	mov	r8, r18
    19ba:	e1 2c       	mov	r14, r1
    19bc:	99 24       	eor	r9, r9
    19be:	93 94       	inc	r9
    19c0:	6c 01       	movw	r12, r24
    19c2:	81 e1       	ldi	r24, 0x11	; 17
    19c4:	c8 0e       	add	r12, r24
    19c6:	d1 1c       	adc	r13, r1
    19c8:	0f b6       	in	r0, 0x3f	; 63
    19ca:	f8 94       	cli
    19cc:	0f 92       	push	r0
    19ce:	f8 01       	movw	r30, r16
    19d0:	f2 8c       	ldd	r15, Z+26	; 0x1a
    19d2:	ff 20       	and	r15, r15
    19d4:	59 f1       	breq	.+86     	; 0x1a2c <xQueueGenericReceive+0x9e>
    19d6:	c6 80       	ldd	r12, Z+6	; 0x06
    19d8:	d7 80       	ldd	r13, Z+7	; 0x07
    19da:	b5 01       	movw	r22, r10
    19dc:	c8 01       	movw	r24, r16
    19de:	0e 94 09 0b 	call	0x1612	; 0x1612 <prvCopyDataFromQueue>
    19e2:	81 10       	cpse	r8, r1
    19e4:	15 c0       	rjmp	.+42     	; 0x1a10 <xQueueGenericReceive+0x82>
    19e6:	fa 94       	dec	r15
    19e8:	f8 01       	movw	r30, r16
    19ea:	f2 8e       	std	Z+26, r15	; 0x1a
    19ec:	80 81       	ld	r24, Z
    19ee:	91 81       	ldd	r25, Z+1	; 0x01
    19f0:	89 2b       	or	r24, r25
    19f2:	29 f4       	brne	.+10     	; 0x19fe <xQueueGenericReceive+0x70>
    19f4:	0e 94 a3 12 	call	0x2546	; 0x2546 <pvTaskIncrementMutexHeldCount>
    19f8:	f8 01       	movw	r30, r16
    19fa:	93 83       	std	Z+3, r25	; 0x03
    19fc:	82 83       	std	Z+2, r24	; 0x02
    19fe:	f8 01       	movw	r30, r16
    1a00:	80 85       	ldd	r24, Z+8	; 0x08
    1a02:	88 23       	and	r24, r24
    1a04:	79 f0       	breq	.+30     	; 0x1a24 <xQueueGenericReceive+0x96>
    1a06:	c8 01       	movw	r24, r16
    1a08:	08 96       	adiw	r24, 0x08	; 8
    1a0a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskRemoveFromEventList>
    1a0e:	0a c0       	rjmp	.+20     	; 0x1a24 <xQueueGenericReceive+0x96>
    1a10:	f8 01       	movw	r30, r16
    1a12:	d7 82       	std	Z+7, r13	; 0x07
    1a14:	c6 82       	std	Z+6, r12	; 0x06
    1a16:	81 89       	ldd	r24, Z+17	; 0x11
    1a18:	88 23       	and	r24, r24
    1a1a:	21 f0       	breq	.+8      	; 0x1a24 <xQueueGenericReceive+0x96>
    1a1c:	c8 01       	movw	r24, r16
    1a1e:	41 96       	adiw	r24, 0x11	; 17
    1a20:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskRemoveFromEventList>
    1a24:	0f 90       	pop	r0
    1a26:	0f be       	out	0x3f, r0	; 63
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	64 c0       	rjmp	.+200    	; 0x1af4 <xQueueGenericReceive+0x166>
    1a2c:	4c 81       	ldd	r20, Y+4	; 0x04
    1a2e:	5d 81       	ldd	r21, Y+5	; 0x05
    1a30:	45 2b       	or	r20, r21
    1a32:	21 f4       	brne	.+8      	; 0x1a3c <xQueueGenericReceive+0xae>
    1a34:	0f 90       	pop	r0
    1a36:	0f be       	out	0x3f, r0	; 63
    1a38:	80 e0       	ldi	r24, 0x00	; 0
    1a3a:	5c c0       	rjmp	.+184    	; 0x1af4 <xQueueGenericReceive+0x166>
    1a3c:	e1 10       	cpse	r14, r1
    1a3e:	05 c0       	rjmp	.+10     	; 0x1a4a <xQueueGenericReceive+0xbc>
    1a40:	ce 01       	movw	r24, r28
    1a42:	01 96       	adiw	r24, 0x01	; 1
    1a44:	0e 94 b2 11 	call	0x2364	; 0x2364 <vTaskSetTimeOutState>
    1a48:	e9 2c       	mov	r14, r9
    1a4a:	0f 90       	pop	r0
    1a4c:	0f be       	out	0x3f, r0	; 63
    1a4e:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskSuspendAll>
    1a52:	0f b6       	in	r0, 0x3f	; 63
    1a54:	f8 94       	cli
    1a56:	0f 92       	push	r0
    1a58:	f8 01       	movw	r30, r16
    1a5a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a5c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a5e:	09 f4       	brne	.+2      	; 0x1a62 <xQueueGenericReceive+0xd4>
    1a60:	15 8e       	std	Z+29, r1	; 0x1d
    1a62:	f8 01       	movw	r30, r16
    1a64:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a66:	9f 3f       	cpi	r25, 0xFF	; 255
    1a68:	09 f4       	brne	.+2      	; 0x1a6c <xQueueGenericReceive+0xde>
    1a6a:	16 8e       	std	Z+30, r1	; 0x1e
    1a6c:	0f 90       	pop	r0
    1a6e:	0f be       	out	0x3f, r0	; 63
    1a70:	be 01       	movw	r22, r28
    1a72:	6c 5f       	subi	r22, 0xFC	; 252
    1a74:	7f 4f       	sbci	r23, 0xFF	; 255
    1a76:	ce 01       	movw	r24, r28
    1a78:	01 96       	adiw	r24, 0x01	; 1
    1a7a:	0e 94 bd 11 	call	0x237a	; 0x237a <xTaskCheckForTimeOut>
    1a7e:	81 11       	cpse	r24, r1
    1a80:	2b c0       	rjmp	.+86     	; 0x1ad8 <xQueueGenericReceive+0x14a>
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	f8 94       	cli
    1a86:	0f 92       	push	r0
    1a88:	f8 01       	movw	r30, r16
    1a8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a8c:	0f 90       	pop	r0
    1a8e:	0f be       	out	0x3f, r0	; 63
    1a90:	81 11       	cpse	r24, r1
    1a92:	1c c0       	rjmp	.+56     	; 0x1acc <xQueueGenericReceive+0x13e>
    1a94:	80 81       	ld	r24, Z
    1a96:	91 81       	ldd	r25, Z+1	; 0x01
    1a98:	89 2b       	or	r24, r25
    1a9a:	49 f4       	brne	.+18     	; 0x1aae <xQueueGenericReceive+0x120>
    1a9c:	0f b6       	in	r0, 0x3f	; 63
    1a9e:	f8 94       	cli
    1aa0:	0f 92       	push	r0
    1aa2:	82 81       	ldd	r24, Z+2	; 0x02
    1aa4:	93 81       	ldd	r25, Z+3	; 0x03
    1aa6:	0e 94 01 12 	call	0x2402	; 0x2402 <vTaskPriorityInherit>
    1aaa:	0f 90       	pop	r0
    1aac:	0f be       	out	0x3f, r0	; 63
    1aae:	6c 81       	ldd	r22, Y+4	; 0x04
    1ab0:	7d 81       	ldd	r23, Y+5	; 0x05
    1ab2:	c6 01       	movw	r24, r12
    1ab4:	0e 94 3d 11 	call	0x227a	; 0x227a <vTaskPlaceOnEventList>
    1ab8:	c8 01       	movw	r24, r16
    1aba:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvUnlockQueue>
    1abe:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    1ac2:	81 11       	cpse	r24, r1
    1ac4:	81 cf       	rjmp	.-254    	; 0x19c8 <xQueueGenericReceive+0x3a>
    1ac6:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    1aca:	7e cf       	rjmp	.-260    	; 0x19c8 <xQueueGenericReceive+0x3a>
    1acc:	c8 01       	movw	r24, r16
    1ace:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvUnlockQueue>
    1ad2:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    1ad6:	78 cf       	rjmp	.-272    	; 0x19c8 <xQueueGenericReceive+0x3a>
    1ad8:	c8 01       	movw	r24, r16
    1ada:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvUnlockQueue>
    1ade:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    1ae2:	0f b6       	in	r0, 0x3f	; 63
    1ae4:	f8 94       	cli
    1ae6:	0f 92       	push	r0
    1ae8:	f8 01       	movw	r30, r16
    1aea:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aec:	0f 90       	pop	r0
    1aee:	0f be       	out	0x3f, r0	; 63
    1af0:	81 11       	cpse	r24, r1
    1af2:	6a cf       	rjmp	.-300    	; 0x19c8 <xQueueGenericReceive+0x3a>
    1af4:	0f 90       	pop	r0
    1af6:	0f 90       	pop	r0
    1af8:	0f 90       	pop	r0
    1afa:	0f 90       	pop	r0
    1afc:	0f 90       	pop	r0
    1afe:	df 91       	pop	r29
    1b00:	cf 91       	pop	r28
    1b02:	1f 91       	pop	r17
    1b04:	0f 91       	pop	r16
    1b06:	ff 90       	pop	r15
    1b08:	ef 90       	pop	r14
    1b0a:	df 90       	pop	r13
    1b0c:	cf 90       	pop	r12
    1b0e:	bf 90       	pop	r11
    1b10:	af 90       	pop	r10
    1b12:	9f 90       	pop	r9
    1b14:	8f 90       	pop	r8
    1b16:	08 95       	ret

00001b18 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    1b18:	cf 93       	push	r28
    1b1a:	df 93       	push	r29
    1b1c:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1b1e:	0f b6       	in	r0, 0x3f	; 63
    1b20:	f8 94       	cli
    1b22:	0f 92       	push	r0
    1b24:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1b26:	8f 3f       	cpi	r24, 0xFF	; 255
    1b28:	09 f4       	brne	.+2      	; 0x1b2c <vQueueWaitForMessageRestricted+0x14>
    1b2a:	1d 8e       	std	Y+29, r1	; 0x1d
    1b2c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b2e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b30:	09 f4       	brne	.+2      	; 0x1b34 <vQueueWaitForMessageRestricted+0x1c>
    1b32:	1e 8e       	std	Y+30, r1	; 0x1e
    1b34:	0f 90       	pop	r0
    1b36:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1b38:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b3a:	81 11       	cpse	r24, r1
    1b3c:	04 c0       	rjmp	.+8      	; 0x1b46 <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1b3e:	ce 01       	movw	r24, r28
    1b40:	41 96       	adiw	r24, 0x11	; 17
    1b42:	0e 94 50 11 	call	0x22a0	; 0x22a0 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1b46:	ce 01       	movw	r24, r28
    1b48:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvUnlockQueue>
	}
    1b4c:	df 91       	pop	r29
    1b4e:	cf 91       	pop	r28
    1b50:	08 95       	ret

00001b52 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1b52:	e0 91 81 08 	lds	r30, 0x0881	; 0x800881 <pxDelayedTaskList>
    1b56:	f0 91 82 08 	lds	r31, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1b5a:	80 81       	ld	r24, Z
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	07 c0       	rjmp	.+14     	; 0x1b6e <prvResetNextTaskUnblockTime+0x1c>
    1b60:	8f ef       	ldi	r24, 0xFF	; 255
    1b62:	9f ef       	ldi	r25, 0xFF	; 255
    1b64:	90 93 62 08 	sts	0x0862, r25	; 0x800862 <xNextTaskUnblockTime+0x1>
    1b68:	80 93 61 08 	sts	0x0861, r24	; 0x800861 <xNextTaskUnblockTime>
    1b6c:	08 95       	ret
    1b6e:	e0 91 81 08 	lds	r30, 0x0881	; 0x800881 <pxDelayedTaskList>
    1b72:	f0 91 82 08 	lds	r31, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1b76:	05 80       	ldd	r0, Z+5	; 0x05
    1b78:	f6 81       	ldd	r31, Z+6	; 0x06
    1b7a:	e0 2d       	mov	r30, r0
    1b7c:	06 80       	ldd	r0, Z+6	; 0x06
    1b7e:	f7 81       	ldd	r31, Z+7	; 0x07
    1b80:	e0 2d       	mov	r30, r0
    1b82:	82 81       	ldd	r24, Z+2	; 0x02
    1b84:	93 81       	ldd	r25, Z+3	; 0x03
    1b86:	90 93 62 08 	sts	0x0862, r25	; 0x800862 <xNextTaskUnblockTime+0x1>
    1b8a:	80 93 61 08 	sts	0x0861, r24	; 0x800861 <xNextTaskUnblockTime>
    1b8e:	08 95       	ret

00001b90 <prvAddCurrentTaskToDelayedList>:
    1b90:	0f 93       	push	r16
    1b92:	1f 93       	push	r17
    1b94:	cf 93       	push	r28
    1b96:	df 93       	push	r29
    1b98:	ec 01       	movw	r28, r24
    1b9a:	00 91 69 08 	lds	r16, 0x0869	; 0x800869 <xTickCount>
    1b9e:	10 91 6a 08 	lds	r17, 0x086A	; 0x80086a <xTickCount+0x1>
    1ba2:	80 91 cb 08 	lds	r24, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1ba6:	90 91 cc 08 	lds	r25, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1baa:	02 96       	adiw	r24, 0x02	; 2
    1bac:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    1bb0:	c0 0f       	add	r28, r16
    1bb2:	d1 1f       	adc	r29, r17
    1bb4:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1bb8:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1bbc:	d3 83       	std	Z+3, r29	; 0x03
    1bbe:	c2 83       	std	Z+2, r28	; 0x02
    1bc0:	c0 17       	cp	r28, r16
    1bc2:	d1 07       	cpc	r29, r17
    1bc4:	68 f4       	brcc	.+26     	; 0x1be0 <prvAddCurrentTaskToDelayedList+0x50>
    1bc6:	60 91 cb 08 	lds	r22, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1bca:	70 91 cc 08 	lds	r23, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1bce:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <pxOverflowDelayedTaskList>
    1bd2:	90 91 80 08 	lds	r25, 0x0880	; 0x800880 <pxOverflowDelayedTaskList+0x1>
    1bd6:	6e 5f       	subi	r22, 0xFE	; 254
    1bd8:	7f 4f       	sbci	r23, 0xFF	; 255
    1bda:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
    1bde:	17 c0       	rjmp	.+46     	; 0x1c0e <prvAddCurrentTaskToDelayedList+0x7e>
    1be0:	60 91 cb 08 	lds	r22, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1be4:	70 91 cc 08 	lds	r23, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1be8:	80 91 81 08 	lds	r24, 0x0881	; 0x800881 <pxDelayedTaskList>
    1bec:	90 91 82 08 	lds	r25, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1bf0:	6e 5f       	subi	r22, 0xFE	; 254
    1bf2:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf4:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
    1bf8:	80 91 61 08 	lds	r24, 0x0861	; 0x800861 <xNextTaskUnblockTime>
    1bfc:	90 91 62 08 	lds	r25, 0x0862	; 0x800862 <xNextTaskUnblockTime+0x1>
    1c00:	c8 17       	cp	r28, r24
    1c02:	d9 07       	cpc	r29, r25
    1c04:	20 f4       	brcc	.+8      	; 0x1c0e <prvAddCurrentTaskToDelayedList+0x7e>
    1c06:	d0 93 62 08 	sts	0x0862, r29	; 0x800862 <xNextTaskUnblockTime+0x1>
    1c0a:	c0 93 61 08 	sts	0x0861, r28	; 0x800861 <xNextTaskUnblockTime>
    1c0e:	df 91       	pop	r29
    1c10:	cf 91       	pop	r28
    1c12:	1f 91       	pop	r17
    1c14:	0f 91       	pop	r16
    1c16:	08 95       	ret

00001c18 <xTaskCreate>:
    1c18:	4f 92       	push	r4
    1c1a:	5f 92       	push	r5
    1c1c:	6f 92       	push	r6
    1c1e:	7f 92       	push	r7
    1c20:	8f 92       	push	r8
    1c22:	9f 92       	push	r9
    1c24:	af 92       	push	r10
    1c26:	bf 92       	push	r11
    1c28:	cf 92       	push	r12
    1c2a:	df 92       	push	r13
    1c2c:	ef 92       	push	r14
    1c2e:	ff 92       	push	r15
    1c30:	0f 93       	push	r16
    1c32:	1f 93       	push	r17
    1c34:	cf 93       	push	r28
    1c36:	df 93       	push	r29
    1c38:	4c 01       	movw	r8, r24
    1c3a:	eb 01       	movw	r28, r22
    1c3c:	6a 01       	movw	r12, r20
    1c3e:	29 01       	movw	r4, r18
    1c40:	ca 01       	movw	r24, r20
    1c42:	0e 94 a9 08 	call	0x1152	; 0x1152 <pvPortMalloc>
    1c46:	5c 01       	movw	r10, r24
    1c48:	89 2b       	or	r24, r25
    1c4a:	09 f4       	brne	.+2      	; 0x1c4e <xTaskCreate+0x36>
    1c4c:	e3 c0       	rjmp	.+454    	; 0x1e14 <xTaskCreate+0x1fc>
    1c4e:	8c e2       	ldi	r24, 0x2C	; 44
    1c50:	90 e0       	ldi	r25, 0x00	; 0
    1c52:	0e 94 a9 08 	call	0x1152	; 0x1152 <pvPortMalloc>
    1c56:	3c 01       	movw	r6, r24
    1c58:	00 97       	sbiw	r24, 0x00	; 0
    1c5a:	b9 f0       	breq	.+46     	; 0x1c8a <xTaskCreate+0x72>
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	b0 8e       	std	Z+24, r11	; 0x18
    1c60:	a7 8a       	std	Z+23, r10	; 0x17
    1c62:	a6 01       	movw	r20, r12
    1c64:	65 ea       	ldi	r22, 0xA5	; 165
    1c66:	70 e0       	ldi	r23, 0x00	; 0
    1c68:	c5 01       	movw	r24, r10
    1c6a:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <memset>
    1c6e:	f1 e0       	ldi	r31, 0x01	; 1
    1c70:	cf 1a       	sub	r12, r31
    1c72:	d1 08       	sbc	r13, r1
    1c74:	f3 01       	movw	r30, r6
    1c76:	87 89       	ldd	r24, Z+23	; 0x17
    1c78:	90 8d       	ldd	r25, Z+24	; 0x18
    1c7a:	c8 0e       	add	r12, r24
    1c7c:	d9 1e       	adc	r13, r25
    1c7e:	88 81       	ld	r24, Y
    1c80:	81 8f       	std	Z+25, r24	; 0x19
    1c82:	88 81       	ld	r24, Y
    1c84:	81 11       	cpse	r24, r1
    1c86:	05 c0       	rjmp	.+10     	; 0x1c92 <xTaskCreate+0x7a>
    1c88:	14 c0       	rjmp	.+40     	; 0x1cb2 <xTaskCreate+0x9a>
    1c8a:	c5 01       	movw	r24, r10
    1c8c:	0e 94 de 08 	call	0x11bc	; 0x11bc <vPortFree>
    1c90:	c1 c0       	rjmp	.+386    	; 0x1e14 <xTaskCreate+0x1fc>
    1c92:	d3 01       	movw	r26, r6
    1c94:	5a 96       	adiw	r26, 0x1a	; 26
    1c96:	fe 01       	movw	r30, r28
    1c98:	31 96       	adiw	r30, 0x01	; 1
    1c9a:	9e 01       	movw	r18, r28
    1c9c:	28 5f       	subi	r18, 0xF8	; 248
    1c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca0:	ef 01       	movw	r28, r30
    1ca2:	81 91       	ld	r24, Z+
    1ca4:	8d 93       	st	X+, r24
    1ca6:	88 81       	ld	r24, Y
    1ca8:	88 23       	and	r24, r24
    1caa:	19 f0       	breq	.+6      	; 0x1cb2 <xTaskCreate+0x9a>
    1cac:	e2 17       	cp	r30, r18
    1cae:	f3 07       	cpc	r31, r19
    1cb0:	b9 f7       	brne	.-18     	; 0x1ca0 <xTaskCreate+0x88>
    1cb2:	f3 01       	movw	r30, r6
    1cb4:	10 a2       	std	Z+32, r1	; 0x20
    1cb6:	06 30       	cpi	r16, 0x06	; 6
    1cb8:	08 f0       	brcs	.+2      	; 0x1cbc <xTaskCreate+0xa4>
    1cba:	05 e0       	ldi	r16, 0x05	; 5
    1cbc:	f3 01       	movw	r30, r6
    1cbe:	06 8b       	std	Z+22, r16	; 0x16
    1cc0:	03 a3       	std	Z+35, r16	; 0x23
    1cc2:	14 a2       	std	Z+36, r1	; 0x24
    1cc4:	e3 01       	movw	r28, r6
    1cc6:	22 96       	adiw	r28, 0x02	; 2
    1cc8:	ce 01       	movw	r24, r28
    1cca:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialiseItem>
    1cce:	c3 01       	movw	r24, r6
    1cd0:	0c 96       	adiw	r24, 0x0c	; 12
    1cd2:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialiseItem>
    1cd6:	f3 01       	movw	r30, r6
    1cd8:	71 86       	std	Z+9, r7	; 0x09
    1cda:	60 86       	std	Z+8, r6	; 0x08
    1cdc:	86 e0       	ldi	r24, 0x06	; 6
    1cde:	90 e0       	ldi	r25, 0x00	; 0
    1ce0:	80 1b       	sub	r24, r16
    1ce2:	91 09       	sbc	r25, r1
    1ce4:	95 87       	std	Z+13, r25	; 0x0d
    1ce6:	84 87       	std	Z+12, r24	; 0x0c
    1ce8:	73 8a       	std	Z+19, r7	; 0x13
    1cea:	62 8a       	std	Z+18, r6	; 0x12
    1cec:	16 a2       	std	Z+38, r1	; 0x26
    1cee:	15 a2       	std	Z+37, r1	; 0x25
    1cf0:	17 a2       	std	Z+39, r1	; 0x27
    1cf2:	10 a6       	std	Z+40, r1	; 0x28
    1cf4:	11 a6       	std	Z+41, r1	; 0x29
    1cf6:	12 a6       	std	Z+42, r1	; 0x2a
    1cf8:	13 a6       	std	Z+43, r1	; 0x2b
    1cfa:	a2 01       	movw	r20, r4
    1cfc:	b4 01       	movw	r22, r8
    1cfe:	c6 01       	movw	r24, r12
    1d00:	0e 94 86 07 	call	0xf0c	; 0xf0c <pxPortInitialiseStack>
    1d04:	f3 01       	movw	r30, r6
    1d06:	91 83       	std	Z+1, r25	; 0x01
    1d08:	80 83       	st	Z, r24
    1d0a:	e1 14       	cp	r14, r1
    1d0c:	f1 04       	cpc	r15, r1
    1d0e:	19 f0       	breq	.+6      	; 0x1d16 <xTaskCreate+0xfe>
    1d10:	f7 01       	movw	r30, r14
    1d12:	71 82       	std	Z+1, r7	; 0x01
    1d14:	60 82       	st	Z, r6
    1d16:	0f b6       	in	r0, 0x3f	; 63
    1d18:	f8 94       	cli
    1d1a:	0f 92       	push	r0
    1d1c:	80 91 6b 08 	lds	r24, 0x086B	; 0x80086b <uxCurrentNumberOfTasks>
    1d20:	8f 5f       	subi	r24, 0xFF	; 255
    1d22:	80 93 6b 08 	sts	0x086B, r24	; 0x80086b <uxCurrentNumberOfTasks>
    1d26:	80 91 cb 08 	lds	r24, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1d2a:	90 91 cc 08 	lds	r25, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1d2e:	89 2b       	or	r24, r25
    1d30:	a9 f5       	brne	.+106    	; 0x1d9c <xTaskCreate+0x184>
    1d32:	70 92 cc 08 	sts	0x08CC, r7	; 0x8008cc <pxCurrentTCB+0x1>
    1d36:	60 92 cb 08 	sts	0x08CB, r6	; 0x8008cb <pxCurrentTCB>
    1d3a:	80 91 6b 08 	lds	r24, 0x086B	; 0x80086b <uxCurrentNumberOfTasks>
    1d3e:	81 30       	cpi	r24, 0x01	; 1
    1d40:	f1 f5       	brne	.+124    	; 0x1dbe <xTaskCreate+0x1a6>
    1d42:	05 e9       	ldi	r16, 0x95	; 149
    1d44:	18 e0       	ldi	r17, 0x08	; 8
    1d46:	0f 2e       	mov	r0, r31
    1d48:	fb ec       	ldi	r31, 0xCB	; 203
    1d4a:	ef 2e       	mov	r14, r31
    1d4c:	f8 e0       	ldi	r31, 0x08	; 8
    1d4e:	ff 2e       	mov	r15, r31
    1d50:	f0 2d       	mov	r31, r0
    1d52:	c8 01       	movw	r24, r16
    1d54:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
    1d58:	07 5f       	subi	r16, 0xF7	; 247
    1d5a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d5c:	0e 15       	cp	r16, r14
    1d5e:	1f 05       	cpc	r17, r15
    1d60:	c1 f7       	brne	.-16     	; 0x1d52 <xTaskCreate+0x13a>
    1d62:	8c e8       	ldi	r24, 0x8C	; 140
    1d64:	98 e0       	ldi	r25, 0x08	; 8
    1d66:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
    1d6a:	83 e8       	ldi	r24, 0x83	; 131
    1d6c:	98 e0       	ldi	r25, 0x08	; 8
    1d6e:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
    1d72:	86 e7       	ldi	r24, 0x76	; 118
    1d74:	98 e0       	ldi	r25, 0x08	; 8
    1d76:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
    1d7a:	8d e6       	ldi	r24, 0x6D	; 109
    1d7c:	98 e0       	ldi	r25, 0x08	; 8
    1d7e:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
    1d82:	8c e8       	ldi	r24, 0x8C	; 140
    1d84:	98 e0       	ldi	r25, 0x08	; 8
    1d86:	90 93 82 08 	sts	0x0882, r25	; 0x800882 <pxDelayedTaskList+0x1>
    1d8a:	80 93 81 08 	sts	0x0881, r24	; 0x800881 <pxDelayedTaskList>
    1d8e:	83 e8       	ldi	r24, 0x83	; 131
    1d90:	98 e0       	ldi	r25, 0x08	; 8
    1d92:	90 93 80 08 	sts	0x0880, r25	; 0x800880 <pxOverflowDelayedTaskList+0x1>
    1d96:	80 93 7f 08 	sts	0x087F, r24	; 0x80087f <pxOverflowDelayedTaskList>
    1d9a:	11 c0       	rjmp	.+34     	; 0x1dbe <xTaskCreate+0x1a6>
    1d9c:	80 91 67 08 	lds	r24, 0x0867	; 0x800867 <xSchedulerRunning>
    1da0:	81 11       	cpse	r24, r1
    1da2:	0d c0       	rjmp	.+26     	; 0x1dbe <xTaskCreate+0x1a6>
    1da4:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1da8:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1dac:	96 89       	ldd	r25, Z+22	; 0x16
    1dae:	f3 01       	movw	r30, r6
    1db0:	86 89       	ldd	r24, Z+22	; 0x16
    1db2:	89 17       	cp	r24, r25
    1db4:	20 f0       	brcs	.+8      	; 0x1dbe <xTaskCreate+0x1a6>
    1db6:	70 92 cc 08 	sts	0x08CC, r7	; 0x8008cc <pxCurrentTCB+0x1>
    1dba:	60 92 cb 08 	sts	0x08CB, r6	; 0x8008cb <pxCurrentTCB>
    1dbe:	80 91 63 08 	lds	r24, 0x0863	; 0x800863 <uxTaskNumber>
    1dc2:	8f 5f       	subi	r24, 0xFF	; 255
    1dc4:	80 93 63 08 	sts	0x0863, r24	; 0x800863 <uxTaskNumber>
    1dc8:	f3 01       	movw	r30, r6
    1dca:	81 a3       	std	Z+33, r24	; 0x21
    1dcc:	86 89       	ldd	r24, Z+22	; 0x16
    1dce:	90 91 68 08 	lds	r25, 0x0868	; 0x800868 <uxTopReadyPriority>
    1dd2:	98 17       	cp	r25, r24
    1dd4:	10 f4       	brcc	.+4      	; 0x1dda <xTaskCreate+0x1c2>
    1dd6:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <uxTopReadyPriority>
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	9c 01       	movw	r18, r24
    1dde:	22 0f       	add	r18, r18
    1de0:	33 1f       	adc	r19, r19
    1de2:	22 0f       	add	r18, r18
    1de4:	33 1f       	adc	r19, r19
    1de6:	22 0f       	add	r18, r18
    1de8:	33 1f       	adc	r19, r19
    1dea:	82 0f       	add	r24, r18
    1dec:	93 1f       	adc	r25, r19
    1dee:	be 01       	movw	r22, r28
    1df0:	8b 56       	subi	r24, 0x6B	; 107
    1df2:	97 4f       	sbci	r25, 0xF7	; 247
    1df4:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    1df8:	0f 90       	pop	r0
    1dfa:	0f be       	out	0x3f, r0	; 63
    1dfc:	80 91 67 08 	lds	r24, 0x0867	; 0x800867 <xSchedulerRunning>
    1e00:	88 23       	and	r24, r24
    1e02:	31 f0       	breq	.+12     	; 0x1e10 <xTaskCreate+0x1f8>
    1e04:	80 91 cb 08 	lds	r24, 0x08CB	; 0x8008cb <pxCurrentTCB>
    1e08:	90 91 cc 08 	lds	r25, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	03 c0       	rjmp	.+6      	; 0x1e16 <xTaskCreate+0x1fe>
    1e10:	81 e0       	ldi	r24, 0x01	; 1
    1e12:	01 c0       	rjmp	.+2      	; 0x1e16 <xTaskCreate+0x1fe>
    1e14:	8f ef       	ldi	r24, 0xFF	; 255
    1e16:	df 91       	pop	r29
    1e18:	cf 91       	pop	r28
    1e1a:	1f 91       	pop	r17
    1e1c:	0f 91       	pop	r16
    1e1e:	ff 90       	pop	r15
    1e20:	ef 90       	pop	r14
    1e22:	df 90       	pop	r13
    1e24:	cf 90       	pop	r12
    1e26:	bf 90       	pop	r11
    1e28:	af 90       	pop	r10
    1e2a:	9f 90       	pop	r9
    1e2c:	8f 90       	pop	r8
    1e2e:	7f 90       	pop	r7
    1e30:	6f 90       	pop	r6
    1e32:	5f 90       	pop	r5
    1e34:	4f 90       	pop	r4
    1e36:	08 95       	ret

00001e38 <vTaskStartScheduler>:
    1e38:	ef 92       	push	r14
    1e3a:	ff 92       	push	r15
    1e3c:	0f 93       	push	r16
    1e3e:	0f 2e       	mov	r0, r31
    1e40:	ff e5       	ldi	r31, 0x5F	; 95
    1e42:	ef 2e       	mov	r14, r31
    1e44:	f8 e0       	ldi	r31, 0x08	; 8
    1e46:	ff 2e       	mov	r15, r31
    1e48:	f0 2d       	mov	r31, r0
    1e4a:	00 e0       	ldi	r16, 0x00	; 0
    1e4c:	20 e0       	ldi	r18, 0x00	; 0
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	4b e3       	ldi	r20, 0x3B	; 59
    1e52:	50 e0       	ldi	r21, 0x00	; 0
    1e54:	6a e7       	ldi	r22, 0x7A	; 122
    1e56:	71 e0       	ldi	r23, 0x01	; 1
    1e58:	85 e8       	ldi	r24, 0x85	; 133
    1e5a:	90 e1       	ldi	r25, 0x10	; 16
    1e5c:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
    1e60:	81 30       	cpi	r24, 0x01	; 1
    1e62:	a1 f4       	brne	.+40     	; 0x1e8c <vTaskStartScheduler+0x54>
    1e64:	0e 94 0d 13 	call	0x261a	; 0x261a <xTimerCreateTimerTask>
    1e68:	81 30       	cpi	r24, 0x01	; 1
    1e6a:	81 f4       	brne	.+32     	; 0x1e8c <vTaskStartScheduler+0x54>
    1e6c:	f8 94       	cli
    1e6e:	8f ef       	ldi	r24, 0xFF	; 255
    1e70:	9f ef       	ldi	r25, 0xFF	; 255
    1e72:	90 93 62 08 	sts	0x0862, r25	; 0x800862 <xNextTaskUnblockTime+0x1>
    1e76:	80 93 61 08 	sts	0x0861, r24	; 0x800861 <xNextTaskUnblockTime>
    1e7a:	81 e0       	ldi	r24, 0x01	; 1
    1e7c:	80 93 67 08 	sts	0x0867, r24	; 0x800867 <xSchedulerRunning>
    1e80:	10 92 6a 08 	sts	0x086A, r1	; 0x80086a <xTickCount+0x1>
    1e84:	10 92 69 08 	sts	0x0869, r1	; 0x800869 <xTickCount>
    1e88:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <xPortStartScheduler>
    1e8c:	0f 91       	pop	r16
    1e8e:	ff 90       	pop	r15
    1e90:	ef 90       	pop	r14
    1e92:	08 95       	ret

00001e94 <vTaskSuspendAll>:
    1e94:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxSchedulerSuspended>
    1e98:	8f 5f       	subi	r24, 0xFF	; 255
    1e9a:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <uxSchedulerSuspended>
    1e9e:	08 95       	ret

00001ea0 <xTaskGetTickCount>:
    1ea0:	0f b6       	in	r0, 0x3f	; 63
    1ea2:	f8 94       	cli
    1ea4:	0f 92       	push	r0
    1ea6:	80 91 69 08 	lds	r24, 0x0869	; 0x800869 <xTickCount>
    1eaa:	90 91 6a 08 	lds	r25, 0x086A	; 0x80086a <xTickCount+0x1>
    1eae:	0f 90       	pop	r0
    1eb0:	0f be       	out	0x3f, r0	; 63
    1eb2:	08 95       	ret

00001eb4 <xTaskIncrementTick>:
    1eb4:	ef 92       	push	r14
    1eb6:	ff 92       	push	r15
    1eb8:	0f 93       	push	r16
    1eba:	1f 93       	push	r17
    1ebc:	cf 93       	push	r28
    1ebe:	df 93       	push	r29
    1ec0:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxSchedulerSuspended>
    1ec4:	81 11       	cpse	r24, r1
    1ec6:	89 c0       	rjmp	.+274    	; 0x1fda <xTaskIncrementTick+0x126>
    1ec8:	e0 90 69 08 	lds	r14, 0x0869	; 0x800869 <xTickCount>
    1ecc:	f0 90 6a 08 	lds	r15, 0x086A	; 0x80086a <xTickCount+0x1>
    1ed0:	8f ef       	ldi	r24, 0xFF	; 255
    1ed2:	e8 1a       	sub	r14, r24
    1ed4:	f8 0a       	sbc	r15, r24
    1ed6:	f0 92 6a 08 	sts	0x086A, r15	; 0x80086a <xTickCount+0x1>
    1eda:	e0 92 69 08 	sts	0x0869, r14	; 0x800869 <xTickCount>
    1ede:	e1 14       	cp	r14, r1
    1ee0:	f1 04       	cpc	r15, r1
    1ee2:	b9 f4       	brne	.+46     	; 0x1f12 <xTaskIncrementTick+0x5e>
    1ee4:	80 91 81 08 	lds	r24, 0x0881	; 0x800881 <pxDelayedTaskList>
    1ee8:	90 91 82 08 	lds	r25, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1eec:	20 91 7f 08 	lds	r18, 0x087F	; 0x80087f <pxOverflowDelayedTaskList>
    1ef0:	30 91 80 08 	lds	r19, 0x0880	; 0x800880 <pxOverflowDelayedTaskList+0x1>
    1ef4:	30 93 82 08 	sts	0x0882, r19	; 0x800882 <pxDelayedTaskList+0x1>
    1ef8:	20 93 81 08 	sts	0x0881, r18	; 0x800881 <pxDelayedTaskList>
    1efc:	90 93 80 08 	sts	0x0880, r25	; 0x800880 <pxOverflowDelayedTaskList+0x1>
    1f00:	80 93 7f 08 	sts	0x087F, r24	; 0x80087f <pxOverflowDelayedTaskList>
    1f04:	80 91 64 08 	lds	r24, 0x0864	; 0x800864 <xNumOfOverflows>
    1f08:	8f 5f       	subi	r24, 0xFF	; 255
    1f0a:	80 93 64 08 	sts	0x0864, r24	; 0x800864 <xNumOfOverflows>
    1f0e:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <prvResetNextTaskUnblockTime>
    1f12:	80 91 61 08 	lds	r24, 0x0861	; 0x800861 <xNextTaskUnblockTime>
    1f16:	90 91 62 08 	lds	r25, 0x0862	; 0x800862 <xNextTaskUnblockTime+0x1>
    1f1a:	e8 16       	cp	r14, r24
    1f1c:	f9 06       	cpc	r15, r25
    1f1e:	08 f4       	brcc	.+2      	; 0x1f22 <xTaskIncrementTick+0x6e>
    1f20:	61 c0       	rjmp	.+194    	; 0x1fe4 <xTaskIncrementTick+0x130>
    1f22:	e0 91 81 08 	lds	r30, 0x0881	; 0x800881 <pxDelayedTaskList>
    1f26:	f0 91 82 08 	lds	r31, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1f2a:	80 81       	ld	r24, Z
    1f2c:	88 23       	and	r24, r24
    1f2e:	79 f0       	breq	.+30     	; 0x1f4e <xTaskIncrementTick+0x9a>
    1f30:	e0 91 81 08 	lds	r30, 0x0881	; 0x800881 <pxDelayedTaskList>
    1f34:	f0 91 82 08 	lds	r31, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1f38:	05 80       	ldd	r0, Z+5	; 0x05
    1f3a:	f6 81       	ldd	r31, Z+6	; 0x06
    1f3c:	e0 2d       	mov	r30, r0
    1f3e:	c6 81       	ldd	r28, Z+6	; 0x06
    1f40:	d7 81       	ldd	r29, Z+7	; 0x07
    1f42:	8a 81       	ldd	r24, Y+2	; 0x02
    1f44:	9b 81       	ldd	r25, Y+3	; 0x03
    1f46:	e8 16       	cp	r14, r24
    1f48:	f9 06       	cpc	r15, r25
    1f4a:	d8 f4       	brcc	.+54     	; 0x1f82 <xTaskIncrementTick+0xce>
    1f4c:	15 c0       	rjmp	.+42     	; 0x1f78 <xTaskIncrementTick+0xc4>
    1f4e:	8f ef       	ldi	r24, 0xFF	; 255
    1f50:	9f ef       	ldi	r25, 0xFF	; 255
    1f52:	90 93 62 08 	sts	0x0862, r25	; 0x800862 <xNextTaskUnblockTime+0x1>
    1f56:	80 93 61 08 	sts	0x0861, r24	; 0x800861 <xNextTaskUnblockTime>
    1f5a:	44 c0       	rjmp	.+136    	; 0x1fe4 <xTaskIncrementTick+0x130>
    1f5c:	e0 91 81 08 	lds	r30, 0x0881	; 0x800881 <pxDelayedTaskList>
    1f60:	f0 91 82 08 	lds	r31, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1f64:	05 80       	ldd	r0, Z+5	; 0x05
    1f66:	f6 81       	ldd	r31, Z+6	; 0x06
    1f68:	e0 2d       	mov	r30, r0
    1f6a:	c6 81       	ldd	r28, Z+6	; 0x06
    1f6c:	d7 81       	ldd	r29, Z+7	; 0x07
    1f6e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f70:	9b 81       	ldd	r25, Y+3	; 0x03
    1f72:	e8 16       	cp	r14, r24
    1f74:	f9 06       	cpc	r15, r25
    1f76:	28 f4       	brcc	.+10     	; 0x1f82 <xTaskIncrementTick+0xce>
    1f78:	90 93 62 08 	sts	0x0862, r25	; 0x800862 <xNextTaskUnblockTime+0x1>
    1f7c:	80 93 61 08 	sts	0x0861, r24	; 0x800861 <xNextTaskUnblockTime>
    1f80:	31 c0       	rjmp	.+98     	; 0x1fe4 <xTaskIncrementTick+0x130>
    1f82:	8e 01       	movw	r16, r28
    1f84:	0e 5f       	subi	r16, 0xFE	; 254
    1f86:	1f 4f       	sbci	r17, 0xFF	; 255
    1f88:	c8 01       	movw	r24, r16
    1f8a:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    1f8e:	8c 89       	ldd	r24, Y+20	; 0x14
    1f90:	9d 89       	ldd	r25, Y+21	; 0x15
    1f92:	89 2b       	or	r24, r25
    1f94:	21 f0       	breq	.+8      	; 0x1f9e <xTaskIncrementTick+0xea>
    1f96:	ce 01       	movw	r24, r28
    1f98:	0c 96       	adiw	r24, 0x0c	; 12
    1f9a:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    1f9e:	2e 89       	ldd	r18, Y+22	; 0x16
    1fa0:	80 91 68 08 	lds	r24, 0x0868	; 0x800868 <uxTopReadyPriority>
    1fa4:	82 17       	cp	r24, r18
    1fa6:	10 f4       	brcc	.+4      	; 0x1fac <xTaskIncrementTick+0xf8>
    1fa8:	20 93 68 08 	sts	0x0868, r18	; 0x800868 <uxTopReadyPriority>
    1fac:	30 e0       	ldi	r19, 0x00	; 0
    1fae:	c9 01       	movw	r24, r18
    1fb0:	88 0f       	add	r24, r24
    1fb2:	99 1f       	adc	r25, r25
    1fb4:	88 0f       	add	r24, r24
    1fb6:	99 1f       	adc	r25, r25
    1fb8:	88 0f       	add	r24, r24
    1fba:	99 1f       	adc	r25, r25
    1fbc:	82 0f       	add	r24, r18
    1fbe:	93 1f       	adc	r25, r19
    1fc0:	b8 01       	movw	r22, r16
    1fc2:	8b 56       	subi	r24, 0x6B	; 107
    1fc4:	97 4f       	sbci	r25, 0xF7	; 247
    1fc6:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    1fca:	e0 91 81 08 	lds	r30, 0x0881	; 0x800881 <pxDelayedTaskList>
    1fce:	f0 91 82 08 	lds	r31, 0x0882	; 0x800882 <pxDelayedTaskList+0x1>
    1fd2:	80 81       	ld	r24, Z
    1fd4:	81 11       	cpse	r24, r1
    1fd6:	c2 cf       	rjmp	.-124    	; 0x1f5c <xTaskIncrementTick+0xa8>
    1fd8:	ba cf       	rjmp	.-140    	; 0x1f4e <xTaskIncrementTick+0x9a>
    1fda:	80 91 66 08 	lds	r24, 0x0866	; 0x800866 <uxPendedTicks>
    1fde:	8f 5f       	subi	r24, 0xFF	; 255
    1fe0:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <uxPendedTicks>
    1fe4:	80 e0       	ldi	r24, 0x00	; 0
    1fe6:	df 91       	pop	r29
    1fe8:	cf 91       	pop	r28
    1fea:	1f 91       	pop	r17
    1fec:	0f 91       	pop	r16
    1fee:	ff 90       	pop	r15
    1ff0:	ef 90       	pop	r14
    1ff2:	08 95       	ret

00001ff4 <xTaskResumeAll>:
    1ff4:	df 92       	push	r13
    1ff6:	ef 92       	push	r14
    1ff8:	ff 92       	push	r15
    1ffa:	0f 93       	push	r16
    1ffc:	1f 93       	push	r17
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
    2002:	0f b6       	in	r0, 0x3f	; 63
    2004:	f8 94       	cli
    2006:	0f 92       	push	r0
    2008:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxSchedulerSuspended>
    200c:	81 50       	subi	r24, 0x01	; 1
    200e:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <uxSchedulerSuspended>
    2012:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxSchedulerSuspended>
    2016:	81 11       	cpse	r24, r1
    2018:	59 c0       	rjmp	.+178    	; 0x20cc <xTaskResumeAll+0xd8>
    201a:	80 91 6b 08 	lds	r24, 0x086B	; 0x80086b <uxCurrentNumberOfTasks>
    201e:	81 11       	cpse	r24, r1
    2020:	33 c0       	rjmp	.+102    	; 0x2088 <xTaskResumeAll+0x94>
    2022:	54 c0       	rjmp	.+168    	; 0x20cc <xTaskResumeAll+0xd8>
    2024:	d7 01       	movw	r26, r14
    2026:	15 96       	adiw	r26, 0x05	; 5
    2028:	ed 91       	ld	r30, X+
    202a:	fc 91       	ld	r31, X
    202c:	16 97       	sbiw	r26, 0x06	; 6
    202e:	c6 81       	ldd	r28, Z+6	; 0x06
    2030:	d7 81       	ldd	r29, Z+7	; 0x07
    2032:	ce 01       	movw	r24, r28
    2034:	0c 96       	adiw	r24, 0x0c	; 12
    2036:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    203a:	8e 01       	movw	r16, r28
    203c:	0e 5f       	subi	r16, 0xFE	; 254
    203e:	1f 4f       	sbci	r17, 0xFF	; 255
    2040:	c8 01       	movw	r24, r16
    2042:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    2046:	2e 89       	ldd	r18, Y+22	; 0x16
    2048:	80 91 68 08 	lds	r24, 0x0868	; 0x800868 <uxTopReadyPriority>
    204c:	82 17       	cp	r24, r18
    204e:	10 f4       	brcc	.+4      	; 0x2054 <xTaskResumeAll+0x60>
    2050:	20 93 68 08 	sts	0x0868, r18	; 0x800868 <uxTopReadyPriority>
    2054:	30 e0       	ldi	r19, 0x00	; 0
    2056:	c9 01       	movw	r24, r18
    2058:	88 0f       	add	r24, r24
    205a:	99 1f       	adc	r25, r25
    205c:	88 0f       	add	r24, r24
    205e:	99 1f       	adc	r25, r25
    2060:	88 0f       	add	r24, r24
    2062:	99 1f       	adc	r25, r25
    2064:	82 0f       	add	r24, r18
    2066:	93 1f       	adc	r25, r19
    2068:	b8 01       	movw	r22, r16
    206a:	8b 56       	subi	r24, 0x6B	; 107
    206c:	97 4f       	sbci	r25, 0xF7	; 247
    206e:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    2072:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2076:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    207a:	9e 89       	ldd	r25, Y+22	; 0x16
    207c:	86 89       	ldd	r24, Z+22	; 0x16
    207e:	98 17       	cp	r25, r24
    2080:	68 f0       	brcs	.+26     	; 0x209c <xTaskResumeAll+0xa8>
    2082:	d0 92 65 08 	sts	0x0865, r13	; 0x800865 <xYieldPending>
    2086:	0a c0       	rjmp	.+20     	; 0x209c <xTaskResumeAll+0xa8>
    2088:	c0 e0       	ldi	r28, 0x00	; 0
    208a:	d0 e0       	ldi	r29, 0x00	; 0
    208c:	0f 2e       	mov	r0, r31
    208e:	f6 e7       	ldi	r31, 0x76	; 118
    2090:	ef 2e       	mov	r14, r31
    2092:	f8 e0       	ldi	r31, 0x08	; 8
    2094:	ff 2e       	mov	r15, r31
    2096:	f0 2d       	mov	r31, r0
    2098:	dd 24       	eor	r13, r13
    209a:	d3 94       	inc	r13
    209c:	f7 01       	movw	r30, r14
    209e:	80 81       	ld	r24, Z
    20a0:	81 11       	cpse	r24, r1
    20a2:	c0 cf       	rjmp	.-128    	; 0x2024 <xTaskResumeAll+0x30>
    20a4:	cd 2b       	or	r28, r29
    20a6:	11 f0       	breq	.+4      	; 0x20ac <xTaskResumeAll+0xb8>
    20a8:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <prvResetNextTaskUnblockTime>
    20ac:	c0 91 66 08 	lds	r28, 0x0866	; 0x800866 <uxPendedTicks>
    20b0:	cc 23       	and	r28, r28
    20b2:	51 f0       	breq	.+20     	; 0x20c8 <xTaskResumeAll+0xd4>
    20b4:	d1 e0       	ldi	r29, 0x01	; 1
    20b6:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xTaskIncrementTick>
    20ba:	81 11       	cpse	r24, r1
    20bc:	d0 93 65 08 	sts	0x0865, r29	; 0x800865 <xYieldPending>
    20c0:	c1 50       	subi	r28, 0x01	; 1
    20c2:	c9 f7       	brne	.-14     	; 0x20b6 <xTaskResumeAll+0xc2>
    20c4:	10 92 66 08 	sts	0x0866, r1	; 0x800866 <uxPendedTicks>
    20c8:	80 91 65 08 	lds	r24, 0x0865	; 0x800865 <xYieldPending>
    20cc:	0f 90       	pop	r0
    20ce:	0f be       	out	0x3f, r0	; 63
    20d0:	80 e0       	ldi	r24, 0x00	; 0
    20d2:	df 91       	pop	r29
    20d4:	cf 91       	pop	r28
    20d6:	1f 91       	pop	r17
    20d8:	0f 91       	pop	r16
    20da:	ff 90       	pop	r15
    20dc:	ef 90       	pop	r14
    20de:	df 90       	pop	r13
    20e0:	08 95       	ret

000020e2 <vTaskDelay>:
    20e2:	cf 93       	push	r28
    20e4:	df 93       	push	r29
    20e6:	ec 01       	movw	r28, r24
    20e8:	89 2b       	or	r24, r25
    20ea:	51 f0       	breq	.+20     	; 0x2100 <vTaskDelay+0x1e>
    20ec:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskSuspendAll>
    20f0:	60 e0       	ldi	r22, 0x00	; 0
    20f2:	ce 01       	movw	r24, r28
    20f4:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <prvAddCurrentTaskToDelayedList>
    20f8:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    20fc:	81 11       	cpse	r24, r1
    20fe:	02 c0       	rjmp	.+4      	; 0x2104 <vTaskDelay+0x22>
    2100:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    2104:	df 91       	pop	r29
    2106:	cf 91       	pop	r28
    2108:	08 95       	ret

0000210a <prvIdleTask>:
    210a:	0d e6       	ldi	r16, 0x6D	; 109
    210c:	18 e0       	ldi	r17, 0x08	; 8
    210e:	29 c0       	rjmp	.+82     	; 0x2162 <prvIdleTask+0x58>
    2110:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskSuspendAll>
    2114:	d8 01       	movw	r26, r16
    2116:	cc 91       	ld	r28, X
    2118:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    211c:	cc 23       	and	r28, r28
    211e:	09 f1       	breq	.+66     	; 0x2162 <prvIdleTask+0x58>
    2120:	0f b6       	in	r0, 0x3f	; 63
    2122:	f8 94       	cli
    2124:	0f 92       	push	r0
    2126:	d8 01       	movw	r26, r16
    2128:	15 96       	adiw	r26, 0x05	; 5
    212a:	ed 91       	ld	r30, X+
    212c:	fc 91       	ld	r31, X
    212e:	16 97       	sbiw	r26, 0x06	; 6
    2130:	c6 81       	ldd	r28, Z+6	; 0x06
    2132:	d7 81       	ldd	r29, Z+7	; 0x07
    2134:	ce 01       	movw	r24, r28
    2136:	02 96       	adiw	r24, 0x02	; 2
    2138:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    213c:	80 91 6b 08 	lds	r24, 0x086B	; 0x80086b <uxCurrentNumberOfTasks>
    2140:	81 50       	subi	r24, 0x01	; 1
    2142:	80 93 6b 08 	sts	0x086B, r24	; 0x80086b <uxCurrentNumberOfTasks>
    2146:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <uxDeletedTasksWaitingCleanUp>
    214a:	81 50       	subi	r24, 0x01	; 1
    214c:	80 93 6c 08 	sts	0x086C, r24	; 0x80086c <uxDeletedTasksWaitingCleanUp>
    2150:	0f 90       	pop	r0
    2152:	0f be       	out	0x3f, r0	; 63
    2154:	8f 89       	ldd	r24, Y+23	; 0x17
    2156:	98 8d       	ldd	r25, Y+24	; 0x18
    2158:	0e 94 de 08 	call	0x11bc	; 0x11bc <vPortFree>
    215c:	ce 01       	movw	r24, r28
    215e:	0e 94 de 08 	call	0x11bc	; 0x11bc <vPortFree>
    2162:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <uxDeletedTasksWaitingCleanUp>
    2166:	81 11       	cpse	r24, r1
    2168:	d3 cf       	rjmp	.-90     	; 0x2110 <prvIdleTask+0x6>
    216a:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    216e:	0e 94 6a 05 	call	0xad4	; 0xad4 <vApplicationIdleHook>
    2172:	f7 cf       	rjmp	.-18     	; 0x2162 <prvIdleTask+0x58>

00002174 <vTaskSetApplicationTaskTag>:
    2174:	00 97       	sbiw	r24, 0x00	; 0
    2176:	21 f4       	brne	.+8      	; 0x2180 <vTaskSetApplicationTaskTag+0xc>
    2178:	80 91 cb 08 	lds	r24, 0x08CB	; 0x8008cb <pxCurrentTCB>
    217c:	90 91 cc 08 	lds	r25, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	f8 94       	cli
    2184:	0f 92       	push	r0
    2186:	fc 01       	movw	r30, r24
    2188:	76 a3       	std	Z+38, r23	; 0x26
    218a:	65 a3       	std	Z+37, r22	; 0x25
    218c:	0f 90       	pop	r0
    218e:	0f be       	out	0x3f, r0	; 63
    2190:	08 95       	ret

00002192 <vTaskSwitchContext>:
    2192:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxSchedulerSuspended>
    2196:	88 23       	and	r24, r24
    2198:	21 f0       	breq	.+8      	; 0x21a2 <vTaskSwitchContext+0x10>
    219a:	81 e0       	ldi	r24, 0x01	; 1
    219c:	80 93 65 08 	sts	0x0865, r24	; 0x800865 <xYieldPending>
    21a0:	08 95       	ret
    21a2:	10 92 65 08 	sts	0x0865, r1	; 0x800865 <xYieldPending>
    21a6:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    21aa:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    21ae:	85 a1       	ldd	r24, Z+37	; 0x25
    21b0:	0e 94 b5 06 	call	0xd6a	; 0xd6a <switch_out>
    21b4:	20 91 68 08 	lds	r18, 0x0868	; 0x800868 <uxTopReadyPriority>
    21b8:	82 2f       	mov	r24, r18
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	fc 01       	movw	r30, r24
    21be:	ee 0f       	add	r30, r30
    21c0:	ff 1f       	adc	r31, r31
    21c2:	ee 0f       	add	r30, r30
    21c4:	ff 1f       	adc	r31, r31
    21c6:	ee 0f       	add	r30, r30
    21c8:	ff 1f       	adc	r31, r31
    21ca:	e8 0f       	add	r30, r24
    21cc:	f9 1f       	adc	r31, r25
    21ce:	eb 56       	subi	r30, 0x6B	; 107
    21d0:	f7 4f       	sbci	r31, 0xF7	; 247
    21d2:	30 81       	ld	r19, Z
    21d4:	31 11       	cpse	r19, r1
    21d6:	11 c0       	rjmp	.+34     	; 0x21fa <vTaskSwitchContext+0x68>
    21d8:	21 50       	subi	r18, 0x01	; 1
    21da:	82 2f       	mov	r24, r18
    21dc:	90 e0       	ldi	r25, 0x00	; 0
    21de:	fc 01       	movw	r30, r24
    21e0:	ee 0f       	add	r30, r30
    21e2:	ff 1f       	adc	r31, r31
    21e4:	ee 0f       	add	r30, r30
    21e6:	ff 1f       	adc	r31, r31
    21e8:	ee 0f       	add	r30, r30
    21ea:	ff 1f       	adc	r31, r31
    21ec:	e8 0f       	add	r30, r24
    21ee:	f9 1f       	adc	r31, r25
    21f0:	eb 56       	subi	r30, 0x6B	; 107
    21f2:	f7 4f       	sbci	r31, 0xF7	; 247
    21f4:	30 81       	ld	r19, Z
    21f6:	33 23       	and	r19, r19
    21f8:	79 f3       	breq	.-34     	; 0x21d8 <vTaskSwitchContext+0x46>
    21fa:	ac 01       	movw	r20, r24
    21fc:	44 0f       	add	r20, r20
    21fe:	55 1f       	adc	r21, r21
    2200:	44 0f       	add	r20, r20
    2202:	55 1f       	adc	r21, r21
    2204:	44 0f       	add	r20, r20
    2206:	55 1f       	adc	r21, r21
    2208:	48 0f       	add	r20, r24
    220a:	59 1f       	adc	r21, r25
    220c:	da 01       	movw	r26, r20
    220e:	ab 56       	subi	r26, 0x6B	; 107
    2210:	b7 4f       	sbci	r27, 0xF7	; 247
    2212:	11 96       	adiw	r26, 0x01	; 1
    2214:	ed 91       	ld	r30, X+
    2216:	fc 91       	ld	r31, X
    2218:	12 97       	sbiw	r26, 0x02	; 2
    221a:	02 80       	ldd	r0, Z+2	; 0x02
    221c:	f3 81       	ldd	r31, Z+3	; 0x03
    221e:	e0 2d       	mov	r30, r0
    2220:	12 96       	adiw	r26, 0x02	; 2
    2222:	fc 93       	st	X, r31
    2224:	ee 93       	st	-X, r30
    2226:	11 97       	sbiw	r26, 0x01	; 1
    2228:	48 56       	subi	r20, 0x68	; 104
    222a:	57 4f       	sbci	r21, 0xF7	; 247
    222c:	e4 17       	cp	r30, r20
    222e:	f5 07       	cpc	r31, r21
    2230:	29 f4       	brne	.+10     	; 0x223c <vTaskSwitchContext+0xaa>
    2232:	42 81       	ldd	r20, Z+2	; 0x02
    2234:	53 81       	ldd	r21, Z+3	; 0x03
    2236:	fd 01       	movw	r30, r26
    2238:	52 83       	std	Z+2, r21	; 0x02
    223a:	41 83       	std	Z+1, r20	; 0x01
    223c:	fc 01       	movw	r30, r24
    223e:	ee 0f       	add	r30, r30
    2240:	ff 1f       	adc	r31, r31
    2242:	ee 0f       	add	r30, r30
    2244:	ff 1f       	adc	r31, r31
    2246:	ee 0f       	add	r30, r30
    2248:	ff 1f       	adc	r31, r31
    224a:	8e 0f       	add	r24, r30
    224c:	9f 1f       	adc	r25, r31
    224e:	fc 01       	movw	r30, r24
    2250:	eb 56       	subi	r30, 0x6B	; 107
    2252:	f7 4f       	sbci	r31, 0xF7	; 247
    2254:	01 80       	ldd	r0, Z+1	; 0x01
    2256:	f2 81       	ldd	r31, Z+2	; 0x02
    2258:	e0 2d       	mov	r30, r0
    225a:	86 81       	ldd	r24, Z+6	; 0x06
    225c:	97 81       	ldd	r25, Z+7	; 0x07
    225e:	90 93 cc 08 	sts	0x08CC, r25	; 0x8008cc <pxCurrentTCB+0x1>
    2262:	80 93 cb 08 	sts	0x08CB, r24	; 0x8008cb <pxCurrentTCB>
    2266:	20 93 68 08 	sts	0x0868, r18	; 0x800868 <uxTopReadyPriority>
    226a:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    226e:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    2272:	85 a1       	ldd	r24, Z+37	; 0x25
    2274:	0e 94 aa 06 	call	0xd54	; 0xd54 <switch_in>
    2278:	08 95       	ret

0000227a <vTaskPlaceOnEventList>:
    227a:	cf 93       	push	r28
    227c:	df 93       	push	r29
    227e:	eb 01       	movw	r28, r22
    2280:	20 91 cb 08 	lds	r18, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2284:	30 91 cc 08 	lds	r19, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    2288:	b9 01       	movw	r22, r18
    228a:	64 5f       	subi	r22, 0xF4	; 244
    228c:	7f 4f       	sbci	r23, 0xFF	; 255
    228e:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
    2292:	61 e0       	ldi	r22, 0x01	; 1
    2294:	ce 01       	movw	r24, r28
    2296:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <prvAddCurrentTaskToDelayedList>
    229a:	df 91       	pop	r29
    229c:	cf 91       	pop	r28
    229e:	08 95       	ret

000022a0 <vTaskPlaceOnEventListRestricted>:
    22a0:	0f 93       	push	r16
    22a2:	1f 93       	push	r17
    22a4:	cf 93       	push	r28
    22a6:	8b 01       	movw	r16, r22
    22a8:	c4 2f       	mov	r28, r20
    22aa:	20 91 cb 08 	lds	r18, 0x08CB	; 0x8008cb <pxCurrentTCB>
    22ae:	30 91 cc 08 	lds	r19, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    22b2:	b9 01       	movw	r22, r18
    22b4:	64 5f       	subi	r22, 0xF4	; 244
    22b6:	7f 4f       	sbci	r23, 0xFF	; 255
    22b8:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    22bc:	cc 23       	and	r28, r28
    22be:	11 f0       	breq	.+4      	; 0x22c4 <vTaskPlaceOnEventListRestricted+0x24>
    22c0:	0f ef       	ldi	r16, 0xFF	; 255
    22c2:	1f ef       	ldi	r17, 0xFF	; 255
    22c4:	6c 2f       	mov	r22, r28
    22c6:	c8 01       	movw	r24, r16
    22c8:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <prvAddCurrentTaskToDelayedList>
    22cc:	cf 91       	pop	r28
    22ce:	1f 91       	pop	r17
    22d0:	0f 91       	pop	r16
    22d2:	08 95       	ret

000022d4 <xTaskRemoveFromEventList>:
    22d4:	0f 93       	push	r16
    22d6:	1f 93       	push	r17
    22d8:	cf 93       	push	r28
    22da:	df 93       	push	r29
    22dc:	dc 01       	movw	r26, r24
    22de:	15 96       	adiw	r26, 0x05	; 5
    22e0:	ed 91       	ld	r30, X+
    22e2:	fc 91       	ld	r31, X
    22e4:	16 97       	sbiw	r26, 0x06	; 6
    22e6:	c6 81       	ldd	r28, Z+6	; 0x06
    22e8:	d7 81       	ldd	r29, Z+7	; 0x07
    22ea:	8e 01       	movw	r16, r28
    22ec:	04 5f       	subi	r16, 0xF4	; 244
    22ee:	1f 4f       	sbci	r17, 0xFF	; 255
    22f0:	c8 01       	movw	r24, r16
    22f2:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    22f6:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxSchedulerSuspended>
    22fa:	81 11       	cpse	r24, r1
    22fc:	1c c0       	rjmp	.+56     	; 0x2336 <xTaskRemoveFromEventList+0x62>
    22fe:	0a 50       	subi	r16, 0x0A	; 10
    2300:	11 09       	sbc	r17, r1
    2302:	c8 01       	movw	r24, r16
    2304:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    2308:	2e 89       	ldd	r18, Y+22	; 0x16
    230a:	80 91 68 08 	lds	r24, 0x0868	; 0x800868 <uxTopReadyPriority>
    230e:	82 17       	cp	r24, r18
    2310:	10 f4       	brcc	.+4      	; 0x2316 <xTaskRemoveFromEventList+0x42>
    2312:	20 93 68 08 	sts	0x0868, r18	; 0x800868 <uxTopReadyPriority>
    2316:	30 e0       	ldi	r19, 0x00	; 0
    2318:	c9 01       	movw	r24, r18
    231a:	88 0f       	add	r24, r24
    231c:	99 1f       	adc	r25, r25
    231e:	88 0f       	add	r24, r24
    2320:	99 1f       	adc	r25, r25
    2322:	88 0f       	add	r24, r24
    2324:	99 1f       	adc	r25, r25
    2326:	82 0f       	add	r24, r18
    2328:	93 1f       	adc	r25, r19
    232a:	b8 01       	movw	r22, r16
    232c:	8b 56       	subi	r24, 0x6B	; 107
    232e:	97 4f       	sbci	r25, 0xF7	; 247
    2330:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    2334:	05 c0       	rjmp	.+10     	; 0x2340 <xTaskRemoveFromEventList+0x6c>
    2336:	b8 01       	movw	r22, r16
    2338:	86 e7       	ldi	r24, 0x76	; 118
    233a:	98 e0       	ldi	r25, 0x08	; 8
    233c:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    2340:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2344:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    2348:	9e 89       	ldd	r25, Y+22	; 0x16
    234a:	86 89       	ldd	r24, Z+22	; 0x16
    234c:	89 17       	cp	r24, r25
    234e:	20 f4       	brcc	.+8      	; 0x2358 <xTaskRemoveFromEventList+0x84>
    2350:	81 e0       	ldi	r24, 0x01	; 1
    2352:	80 93 65 08 	sts	0x0865, r24	; 0x800865 <xYieldPending>
    2356:	01 c0       	rjmp	.+2      	; 0x235a <xTaskRemoveFromEventList+0x86>
    2358:	80 e0       	ldi	r24, 0x00	; 0
    235a:	df 91       	pop	r29
    235c:	cf 91       	pop	r28
    235e:	1f 91       	pop	r17
    2360:	0f 91       	pop	r16
    2362:	08 95       	ret

00002364 <vTaskSetTimeOutState>:
    2364:	20 91 64 08 	lds	r18, 0x0864	; 0x800864 <xNumOfOverflows>
    2368:	fc 01       	movw	r30, r24
    236a:	20 83       	st	Z, r18
    236c:	20 91 69 08 	lds	r18, 0x0869	; 0x800869 <xTickCount>
    2370:	30 91 6a 08 	lds	r19, 0x086A	; 0x80086a <xTickCount+0x1>
    2374:	32 83       	std	Z+2, r19	; 0x02
    2376:	21 83       	std	Z+1, r18	; 0x01
    2378:	08 95       	ret

0000237a <xTaskCheckForTimeOut>:
    237a:	cf 93       	push	r28
    237c:	df 93       	push	r29
    237e:	fc 01       	movw	r30, r24
    2380:	0f b6       	in	r0, 0x3f	; 63
    2382:	f8 94       	cli
    2384:	0f 92       	push	r0
    2386:	20 91 69 08 	lds	r18, 0x0869	; 0x800869 <xTickCount>
    238a:	30 91 6a 08 	lds	r19, 0x086A	; 0x80086a <xTickCount+0x1>
    238e:	80 91 64 08 	lds	r24, 0x0864	; 0x800864 <xNumOfOverflows>
    2392:	90 81       	ld	r25, Z
    2394:	98 17       	cp	r25, r24
    2396:	29 f0       	breq	.+10     	; 0x23a2 <xTaskCheckForTimeOut+0x28>
    2398:	81 81       	ldd	r24, Z+1	; 0x01
    239a:	92 81       	ldd	r25, Z+2	; 0x02
    239c:	28 17       	cp	r18, r24
    239e:	39 07       	cpc	r19, r25
    23a0:	b0 f4       	brcc	.+44     	; 0x23ce <xTaskCheckForTimeOut+0x54>
    23a2:	a1 81       	ldd	r26, Z+1	; 0x01
    23a4:	b2 81       	ldd	r27, Z+2	; 0x02
    23a6:	eb 01       	movw	r28, r22
    23a8:	48 81       	ld	r20, Y
    23aa:	59 81       	ldd	r21, Y+1	; 0x01
    23ac:	c9 01       	movw	r24, r18
    23ae:	8a 1b       	sub	r24, r26
    23b0:	9b 0b       	sbc	r25, r27
    23b2:	84 17       	cp	r24, r20
    23b4:	95 07       	cpc	r25, r21
    23b6:	68 f4       	brcc	.+26     	; 0x23d2 <xTaskCheckForTimeOut+0x58>
    23b8:	cf 01       	movw	r24, r30
    23ba:	a2 1b       	sub	r26, r18
    23bc:	b3 0b       	sbc	r27, r19
    23be:	4a 0f       	add	r20, r26
    23c0:	5b 1f       	adc	r21, r27
    23c2:	59 83       	std	Y+1, r21	; 0x01
    23c4:	48 83       	st	Y, r20
    23c6:	0e 94 b2 11 	call	0x2364	; 0x2364 <vTaskSetTimeOutState>
    23ca:	80 e0       	ldi	r24, 0x00	; 0
    23cc:	03 c0       	rjmp	.+6      	; 0x23d4 <xTaskCheckForTimeOut+0x5a>
    23ce:	81 e0       	ldi	r24, 0x01	; 1
    23d0:	01 c0       	rjmp	.+2      	; 0x23d4 <xTaskCheckForTimeOut+0x5a>
    23d2:	81 e0       	ldi	r24, 0x01	; 1
    23d4:	0f 90       	pop	r0
    23d6:	0f be       	out	0x3f, r0	; 63
    23d8:	df 91       	pop	r29
    23da:	cf 91       	pop	r28
    23dc:	08 95       	ret

000023de <vTaskMissedYield>:
    23de:	81 e0       	ldi	r24, 0x01	; 1
    23e0:	80 93 65 08 	sts	0x0865, r24	; 0x800865 <xYieldPending>
    23e4:	08 95       	ret

000023e6 <xTaskGetSchedulerState>:
    23e6:	80 91 67 08 	lds	r24, 0x0867	; 0x800867 <xSchedulerRunning>
    23ea:	88 23       	and	r24, r24
    23ec:	31 f0       	breq	.+12     	; 0x23fa <xTaskGetSchedulerState+0x14>
    23ee:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxSchedulerSuspended>
    23f2:	88 23       	and	r24, r24
    23f4:	21 f0       	breq	.+8      	; 0x23fe <xTaskGetSchedulerState+0x18>
    23f6:	80 e0       	ldi	r24, 0x00	; 0
    23f8:	08 95       	ret
    23fa:	81 e0       	ldi	r24, 0x01	; 1
    23fc:	08 95       	ret
    23fe:	82 e0       	ldi	r24, 0x02	; 2
    2400:	08 95       	ret

00002402 <vTaskPriorityInherit>:
    2402:	0f 93       	push	r16
    2404:	1f 93       	push	r17
    2406:	cf 93       	push	r28
    2408:	df 93       	push	r29
    240a:	fc 01       	movw	r30, r24
    240c:	89 2b       	or	r24, r25
    240e:	09 f4       	brne	.+2      	; 0x2412 <vTaskPriorityInherit+0x10>
    2410:	55 c0       	rjmp	.+170    	; 0x24bc <vTaskPriorityInherit+0xba>
    2412:	26 89       	ldd	r18, Z+22	; 0x16
    2414:	a0 91 cb 08 	lds	r26, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2418:	b0 91 cc 08 	lds	r27, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    241c:	56 96       	adiw	r26, 0x16	; 22
    241e:	8c 91       	ld	r24, X
    2420:	28 17       	cp	r18, r24
    2422:	08 f0       	brcs	.+2      	; 0x2426 <vTaskPriorityInherit+0x24>
    2424:	4b c0       	rjmp	.+150    	; 0x24bc <vTaskPriorityInherit+0xba>
    2426:	84 85       	ldd	r24, Z+12	; 0x0c
    2428:	95 85       	ldd	r25, Z+13	; 0x0d
    242a:	99 23       	and	r25, r25
    242c:	64 f0       	brlt	.+24     	; 0x2446 <vTaskPriorityInherit+0x44>
    242e:	a0 91 cb 08 	lds	r26, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2432:	b0 91 cc 08 	lds	r27, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    2436:	56 96       	adiw	r26, 0x16	; 22
    2438:	3c 91       	ld	r19, X
    243a:	86 e0       	ldi	r24, 0x06	; 6
    243c:	90 e0       	ldi	r25, 0x00	; 0
    243e:	83 1b       	sub	r24, r19
    2440:	91 09       	sbc	r25, r1
    2442:	95 87       	std	Z+13, r25	; 0x0d
    2444:	84 87       	std	Z+12, r24	; 0x0c
    2446:	30 e0       	ldi	r19, 0x00	; 0
    2448:	c9 01       	movw	r24, r18
    244a:	88 0f       	add	r24, r24
    244c:	99 1f       	adc	r25, r25
    244e:	88 0f       	add	r24, r24
    2450:	99 1f       	adc	r25, r25
    2452:	88 0f       	add	r24, r24
    2454:	99 1f       	adc	r25, r25
    2456:	28 0f       	add	r18, r24
    2458:	39 1f       	adc	r19, r25
    245a:	2b 56       	subi	r18, 0x6B	; 107
    245c:	37 4f       	sbci	r19, 0xF7	; 247
    245e:	82 85       	ldd	r24, Z+10	; 0x0a
    2460:	93 85       	ldd	r25, Z+11	; 0x0b
    2462:	82 17       	cp	r24, r18
    2464:	93 07       	cpc	r25, r19
    2466:	19 f5       	brne	.+70     	; 0x24ae <vTaskPriorityInherit+0xac>
    2468:	8f 01       	movw	r16, r30
    246a:	ef 01       	movw	r28, r30
    246c:	22 96       	adiw	r28, 0x02	; 2
    246e:	ce 01       	movw	r24, r28
    2470:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    2474:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2478:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    247c:	26 89       	ldd	r18, Z+22	; 0x16
    247e:	f8 01       	movw	r30, r16
    2480:	26 8b       	std	Z+22, r18	; 0x16
    2482:	80 91 68 08 	lds	r24, 0x0868	; 0x800868 <uxTopReadyPriority>
    2486:	82 17       	cp	r24, r18
    2488:	10 f4       	brcc	.+4      	; 0x248e <vTaskPriorityInherit+0x8c>
    248a:	20 93 68 08 	sts	0x0868, r18	; 0x800868 <uxTopReadyPriority>
    248e:	30 e0       	ldi	r19, 0x00	; 0
    2490:	c9 01       	movw	r24, r18
    2492:	88 0f       	add	r24, r24
    2494:	99 1f       	adc	r25, r25
    2496:	88 0f       	add	r24, r24
    2498:	99 1f       	adc	r25, r25
    249a:	88 0f       	add	r24, r24
    249c:	99 1f       	adc	r25, r25
    249e:	82 0f       	add	r24, r18
    24a0:	93 1f       	adc	r25, r19
    24a2:	be 01       	movw	r22, r28
    24a4:	8b 56       	subi	r24, 0x6B	; 107
    24a6:	97 4f       	sbci	r25, 0xF7	; 247
    24a8:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    24ac:	07 c0       	rjmp	.+14     	; 0x24bc <vTaskPriorityInherit+0xba>
    24ae:	a0 91 cb 08 	lds	r26, 0x08CB	; 0x8008cb <pxCurrentTCB>
    24b2:	b0 91 cc 08 	lds	r27, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    24b6:	56 96       	adiw	r26, 0x16	; 22
    24b8:	8c 91       	ld	r24, X
    24ba:	86 8b       	std	Z+22, r24	; 0x16
    24bc:	df 91       	pop	r29
    24be:	cf 91       	pop	r28
    24c0:	1f 91       	pop	r17
    24c2:	0f 91       	pop	r16
    24c4:	08 95       	ret

000024c6 <xTaskPriorityDisinherit>:
    24c6:	0f 93       	push	r16
    24c8:	1f 93       	push	r17
    24ca:	cf 93       	push	r28
    24cc:	df 93       	push	r29
    24ce:	fc 01       	movw	r30, r24
    24d0:	89 2b       	or	r24, r25
    24d2:	79 f1       	breq	.+94     	; 0x2532 <xTaskPriorityDisinherit+0x6c>
    24d4:	84 a1       	ldd	r24, Z+36	; 0x24
    24d6:	81 50       	subi	r24, 0x01	; 1
    24d8:	84 a3       	std	Z+36, r24	; 0x24
    24da:	26 89       	ldd	r18, Z+22	; 0x16
    24dc:	93 a1       	ldd	r25, Z+35	; 0x23
    24de:	29 17       	cp	r18, r25
    24e0:	51 f1       	breq	.+84     	; 0x2536 <xTaskPriorityDisinherit+0x70>
    24e2:	81 11       	cpse	r24, r1
    24e4:	2a c0       	rjmp	.+84     	; 0x253a <xTaskPriorityDisinherit+0x74>
    24e6:	ef 01       	movw	r28, r30
    24e8:	8f 01       	movw	r16, r30
    24ea:	0e 5f       	subi	r16, 0xFE	; 254
    24ec:	1f 4f       	sbci	r17, 0xFF	; 255
    24ee:	c8 01       	movw	r24, r16
    24f0:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
    24f4:	2b a1       	ldd	r18, Y+35	; 0x23
    24f6:	2e 8b       	std	Y+22, r18	; 0x16
    24f8:	46 e0       	ldi	r20, 0x06	; 6
    24fa:	50 e0       	ldi	r21, 0x00	; 0
    24fc:	42 1b       	sub	r20, r18
    24fe:	51 09       	sbc	r21, r1
    2500:	5d 87       	std	Y+13, r21	; 0x0d
    2502:	4c 87       	std	Y+12, r20	; 0x0c
    2504:	80 91 68 08 	lds	r24, 0x0868	; 0x800868 <uxTopReadyPriority>
    2508:	82 17       	cp	r24, r18
    250a:	10 f4       	brcc	.+4      	; 0x2510 <xTaskPriorityDisinherit+0x4a>
    250c:	20 93 68 08 	sts	0x0868, r18	; 0x800868 <uxTopReadyPriority>
    2510:	30 e0       	ldi	r19, 0x00	; 0
    2512:	c9 01       	movw	r24, r18
    2514:	88 0f       	add	r24, r24
    2516:	99 1f       	adc	r25, r25
    2518:	88 0f       	add	r24, r24
    251a:	99 1f       	adc	r25, r25
    251c:	88 0f       	add	r24, r24
    251e:	99 1f       	adc	r25, r25
    2520:	82 0f       	add	r24, r18
    2522:	93 1f       	adc	r25, r19
    2524:	b8 01       	movw	r22, r16
    2526:	8b 56       	subi	r24, 0x6B	; 107
    2528:	97 4f       	sbci	r25, 0xF7	; 247
    252a:	0e 94 0e 07 	call	0xe1c	; 0xe1c <vListInsertEnd>
    252e:	81 e0       	ldi	r24, 0x01	; 1
    2530:	05 c0       	rjmp	.+10     	; 0x253c <xTaskPriorityDisinherit+0x76>
    2532:	80 e0       	ldi	r24, 0x00	; 0
    2534:	03 c0       	rjmp	.+6      	; 0x253c <xTaskPriorityDisinherit+0x76>
    2536:	80 e0       	ldi	r24, 0x00	; 0
    2538:	01 c0       	rjmp	.+2      	; 0x253c <xTaskPriorityDisinherit+0x76>
    253a:	80 e0       	ldi	r24, 0x00	; 0
    253c:	df 91       	pop	r29
    253e:	cf 91       	pop	r28
    2540:	1f 91       	pop	r17
    2542:	0f 91       	pop	r16
    2544:	08 95       	ret

00002546 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2546:	80 91 cb 08 	lds	r24, 0x08CB	; 0x8008cb <pxCurrentTCB>
    254a:	90 91 cc 08 	lds	r25, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    254e:	89 2b       	or	r24, r25
    2550:	39 f0       	breq	.+14     	; 0x2560 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2552:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2556:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
    255a:	84 a1       	ldd	r24, Z+36	; 0x24
    255c:	8f 5f       	subi	r24, 0xFF	; 255
    255e:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    2560:	80 91 cb 08 	lds	r24, 0x08CB	; 0x8008cb <pxCurrentTCB>
    2564:	90 91 cc 08 	lds	r25, 0x08CC	; 0x8008cc <pxCurrentTCB+0x1>
	}
    2568:	08 95       	ret

0000256a <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    256a:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    256c:	73 83       	std	Z+3, r23	; 0x03
    256e:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2570:	91 87       	std	Z+9, r25	; 0x09
    2572:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    2574:	46 17       	cp	r20, r22
    2576:	57 07       	cpc	r21, r23
    2578:	90 f0       	brcs	.+36     	; 0x259e <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    257a:	42 1b       	sub	r20, r18
    257c:	53 0b       	sbc	r21, r19
    257e:	84 85       	ldd	r24, Z+12	; 0x0c
    2580:	95 85       	ldd	r25, Z+13	; 0x0d
    2582:	48 17       	cp	r20, r24
    2584:	59 07       	cpc	r21, r25
    2586:	e0 f4       	brcc	.+56     	; 0x25c0 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2588:	bf 01       	movw	r22, r30
    258a:	6e 5f       	subi	r22, 0xFE	; 254
    258c:	7f 4f       	sbci	r23, 0xFF	; 255
    258e:	80 91 d3 08 	lds	r24, 0x08D3	; 0x8008d3 <pxOverflowTimerList>
    2592:	90 91 d4 08 	lds	r25, 0x08D4	; 0x8008d4 <pxOverflowTimerList+0x1>
    2596:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    259a:	80 e0       	ldi	r24, 0x00	; 0
    259c:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    259e:	42 17       	cp	r20, r18
    25a0:	53 07       	cpc	r21, r19
    25a2:	18 f4       	brcc	.+6      	; 0x25aa <prvInsertTimerInActiveList+0x40>
    25a4:	62 17       	cp	r22, r18
    25a6:	73 07       	cpc	r23, r19
    25a8:	68 f4       	brcc	.+26     	; 0x25c4 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    25aa:	bf 01       	movw	r22, r30
    25ac:	6e 5f       	subi	r22, 0xFE	; 254
    25ae:	7f 4f       	sbci	r23, 0xFF	; 255
    25b0:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <pxCurrentTimerList>
    25b4:	90 91 d6 08 	lds	r25, 0x08D6	; 0x8008d6 <pxCurrentTimerList+0x1>
    25b8:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    25bc:	80 e0       	ldi	r24, 0x00	; 0
    25be:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    25c0:	81 e0       	ldi	r24, 0x01	; 1
    25c2:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    25c4:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    25c6:	08 95       	ret

000025c8 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	f8 94       	cli
    25cc:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    25ce:	80 91 d1 08 	lds	r24, 0x08D1	; 0x8008d1 <xTimerQueue>
    25d2:	90 91 d2 08 	lds	r25, 0x08D2	; 0x8008d2 <xTimerQueue+0x1>
    25d6:	89 2b       	or	r24, r25
    25d8:	e9 f4       	brne	.+58     	; 0x2614 <prvCheckForValidListAndQueue+0x4c>
		{
			vListInitialise( &xActiveTimerList1 );
    25da:	80 ee       	ldi	r24, 0xE0	; 224
    25dc:	98 e0       	ldi	r25, 0x08	; 8
    25de:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    25e2:	87 ed       	ldi	r24, 0xD7	; 215
    25e4:	98 e0       	ldi	r25, 0x08	; 8
    25e6:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    25ea:	80 ee       	ldi	r24, 0xE0	; 224
    25ec:	98 e0       	ldi	r25, 0x08	; 8
    25ee:	90 93 d6 08 	sts	0x08D6, r25	; 0x8008d6 <pxCurrentTimerList+0x1>
    25f2:	80 93 d5 08 	sts	0x08D5, r24	; 0x8008d5 <pxCurrentTimerList>
			pxOverflowTimerList = &xActiveTimerList2;
    25f6:	87 ed       	ldi	r24, 0xD7	; 215
    25f8:	98 e0       	ldi	r25, 0x08	; 8
    25fa:	90 93 d4 08 	sts	0x08D4, r25	; 0x8008d4 <pxOverflowTimerList+0x1>
    25fe:	80 93 d3 08 	sts	0x08D3, r24	; 0x8008d3 <pxOverflowTimerList>

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2602:	40 e0       	ldi	r20, 0x00	; 0
    2604:	65 e0       	ldi	r22, 0x05	; 5
    2606:	82 e0       	ldi	r24, 0x02	; 2
    2608:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericCreate>
    260c:	90 93 d2 08 	sts	0x08D2, r25	; 0x8008d2 <xTimerQueue+0x1>
    2610:	80 93 d1 08 	sts	0x08D1, r24	; 0x8008d1 <xTimerQueue>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2614:	0f 90       	pop	r0
    2616:	0f be       	out	0x3f, r0	; 63
    2618:	08 95       	ret

0000261a <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    261a:	ef 92       	push	r14
    261c:	ff 92       	push	r15
    261e:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    2620:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    2624:	80 91 d1 08 	lds	r24, 0x08D1	; 0x8008d1 <xTimerQueue>
    2628:	90 91 d2 08 	lds	r25, 0x08D2	; 0x8008d2 <xTimerQueue+0x1>
    262c:	89 2b       	or	r24, r25
    262e:	91 f0       	breq	.+36     	; 0x2654 <xTimerCreateTimerTask+0x3a>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    2630:	0f 2e       	mov	r0, r31
    2632:	ff ec       	ldi	r31, 0xCF	; 207
    2634:	ef 2e       	mov	r14, r31
    2636:	f8 e0       	ldi	r31, 0x08	; 8
    2638:	ff 2e       	mov	r15, r31
    263a:	f0 2d       	mov	r31, r0
    263c:	05 e0       	ldi	r16, 0x05	; 5
    263e:	20 e0       	ldi	r18, 0x00	; 0
    2640:	30 e0       	ldi	r19, 0x00	; 0
    2642:	42 e3       	ldi	r20, 0x32	; 50
    2644:	50 e0       	ldi	r21, 0x00	; 0
    2646:	6f e7       	ldi	r22, 0x7F	; 127
    2648:	71 e0       	ldi	r23, 0x01	; 1
    264a:	89 e1       	ldi	r24, 0x19	; 25
    264c:	94 e1       	ldi	r25, 0x14	; 20
    264e:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <xTaskCreate>
    2652:	01 c0       	rjmp	.+2      	; 0x2656 <xTimerCreateTimerTask+0x3c>
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2654:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2656:	0f 91       	pop	r16
    2658:	ff 90       	pop	r15
    265a:	ef 90       	pop	r14
    265c:	08 95       	ret

0000265e <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    265e:	9f 92       	push	r9
    2660:	af 92       	push	r10
    2662:	bf 92       	push	r11
    2664:	cf 92       	push	r12
    2666:	df 92       	push	r13
    2668:	ef 92       	push	r14
    266a:	ff 92       	push	r15
    266c:	0f 93       	push	r16
    266e:	1f 93       	push	r17
    2670:	cf 93       	push	r28
    2672:	df 93       	push	r29
    2674:	5c 01       	movw	r10, r24
    2676:	6b 01       	movw	r12, r22
    2678:	94 2e       	mov	r9, r20
    267a:	79 01       	movw	r14, r18
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    267c:	84 e1       	ldi	r24, 0x14	; 20
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	0e 94 a9 08 	call	0x1152	; 0x1152 <pvPortMalloc>
    2684:	ec 01       	movw	r28, r24
									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
    2686:	89 2b       	or	r24, r25
    2688:	79 f0       	breq	.+30     	; 0x26a8 <xTimerCreate+0x4a>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
    268a:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
    268e:	b9 82       	std	Y+1, r11	; 0x01
    2690:	a8 82       	st	Y, r10
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2692:	dd 86       	std	Y+13, r13	; 0x0d
    2694:	cc 86       	std	Y+12, r12	; 0x0c
		pxNewTimer->uxAutoReload = uxAutoReload;
    2696:	9e 86       	std	Y+14, r9	; 0x0e
		pxNewTimer->pvTimerID = pvTimerID;
    2698:	f8 8a       	std	Y+16, r15	; 0x10
    269a:	ef 86       	std	Y+15, r14	; 0x0f
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    269c:	1a 8b       	std	Y+18, r17	; 0x12
    269e:	09 8b       	std	Y+17, r16	; 0x11
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    26a0:	ce 01       	movw	r24, r28
    26a2:	02 96       	adiw	r24, 0x02	; 2
    26a4:	0e 94 0a 07 	call	0xe14	; 0xe14 <vListInitialiseItem>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    26a8:	ce 01       	movw	r24, r28
    26aa:	df 91       	pop	r29
    26ac:	cf 91       	pop	r28
    26ae:	1f 91       	pop	r17
    26b0:	0f 91       	pop	r16
    26b2:	ff 90       	pop	r15
    26b4:	ef 90       	pop	r14
    26b6:	df 90       	pop	r13
    26b8:	cf 90       	pop	r12
    26ba:	bf 90       	pop	r11
    26bc:	af 90       	pop	r10
    26be:	9f 90       	pop	r9
    26c0:	08 95       	ret

000026c2 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    26c2:	0f 93       	push	r16
    26c4:	1f 93       	push	r17
    26c6:	cf 93       	push	r28
    26c8:	df 93       	push	r29
    26ca:	00 d0       	rcall	.+0      	; 0x26cc <xTimerGenericCommand+0xa>
    26cc:	00 d0       	rcall	.+0      	; 0x26ce <xTimerGenericCommand+0xc>
    26ce:	1f 92       	push	r1
    26d0:	cd b7       	in	r28, 0x3d	; 61
    26d2:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    26d4:	e0 91 d1 08 	lds	r30, 0x08D1	; 0x8008d1 <xTimerQueue>
    26d8:	f0 91 d2 08 	lds	r31, 0x08D2	; 0x8008d2 <xTimerQueue+0x1>
    26dc:	30 97       	sbiw	r30, 0x00	; 0
    26de:	71 f1       	breq	.+92     	; 0x273c <xTimerGenericCommand+0x7a>
    26e0:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    26e2:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    26e4:	5b 83       	std	Y+3, r21	; 0x03
    26e6:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    26e8:	9d 83       	std	Y+5, r25	; 0x05
    26ea:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    26ec:	66 30       	cpi	r22, 0x06	; 6
    26ee:	ec f4       	brge	.+58     	; 0x272a <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    26f0:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <xTaskGetSchedulerState>
    26f4:	82 30       	cpi	r24, 0x02	; 2
    26f6:	61 f4       	brne	.+24     	; 0x2710 <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    26f8:	20 e0       	ldi	r18, 0x00	; 0
    26fa:	a8 01       	movw	r20, r16
    26fc:	be 01       	movw	r22, r28
    26fe:	6f 5f       	subi	r22, 0xFF	; 255
    2700:	7f 4f       	sbci	r23, 0xFF	; 255
    2702:	80 91 d1 08 	lds	r24, 0x08D1	; 0x8008d1 <xTimerQueue>
    2706:	90 91 d2 08 	lds	r25, 0x08D2	; 0x8008d2 <xTimerQueue+0x1>
    270a:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
    270e:	17 c0       	rjmp	.+46     	; 0x273e <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2710:	20 e0       	ldi	r18, 0x00	; 0
    2712:	40 e0       	ldi	r20, 0x00	; 0
    2714:	50 e0       	ldi	r21, 0x00	; 0
    2716:	be 01       	movw	r22, r28
    2718:	6f 5f       	subi	r22, 0xFF	; 255
    271a:	7f 4f       	sbci	r23, 0xFF	; 255
    271c:	80 91 d1 08 	lds	r24, 0x08D1	; 0x8008d1 <xTimerQueue>
    2720:	90 91 d2 08 	lds	r25, 0x08D2	; 0x8008d2 <xTimerQueue+0x1>
    2724:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
    2728:	0a c0       	rjmp	.+20     	; 0x273e <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    272a:	20 e0       	ldi	r18, 0x00	; 0
    272c:	ad 01       	movw	r20, r26
    272e:	be 01       	movw	r22, r28
    2730:	6f 5f       	subi	r22, 0xFF	; 255
    2732:	7f 4f       	sbci	r23, 0xFF	; 255
    2734:	cf 01       	movw	r24, r30
    2736:	0e 94 8d 0c 	call	0x191a	; 0x191a <xQueueGenericSendFromISR>
    273a:	01 c0       	rjmp	.+2      	; 0x273e <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    273c:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    273e:	0f 90       	pop	r0
    2740:	0f 90       	pop	r0
    2742:	0f 90       	pop	r0
    2744:	0f 90       	pop	r0
    2746:	0f 90       	pop	r0
    2748:	df 91       	pop	r29
    274a:	cf 91       	pop	r28
    274c:	1f 91       	pop	r17
    274e:	0f 91       	pop	r16
    2750:	08 95       	ret

00002752 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2752:	af 92       	push	r10
    2754:	bf 92       	push	r11
    2756:	cf 92       	push	r12
    2758:	df 92       	push	r13
    275a:	ef 92       	push	r14
    275c:	ff 92       	push	r15
    275e:	0f 93       	push	r16
    2760:	1f 93       	push	r17
    2762:	cf 93       	push	r28
    2764:	df 93       	push	r29
    2766:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2768:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <xTaskGetTickCount>
    276c:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    276e:	80 91 cd 08 	lds	r24, 0x08CD	; 0x8008cd <xLastTime.2242>
    2772:	90 91 ce 08 	lds	r25, 0x08CE	; 0x8008ce <xLastTime.2242+0x1>
    2776:	e8 16       	cp	r14, r24
    2778:	f9 06       	cpc	r15, r25
    277a:	08 f0       	brcs	.+2      	; 0x277e <prvSampleTimeNow+0x2c>
    277c:	48 c0       	rjmp	.+144    	; 0x280e <prvSampleTimeNow+0xbc>
    277e:	30 c0       	rjmp	.+96     	; 0x27e0 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2780:	05 80       	ldd	r0, Z+5	; 0x05
    2782:	f6 81       	ldd	r31, Z+6	; 0x06
    2784:	e0 2d       	mov	r30, r0
    2786:	a0 80       	ld	r10, Z
    2788:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    278a:	c6 81       	ldd	r28, Z+6	; 0x06
    278c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    278e:	8e 01       	movw	r16, r28
    2790:	0e 5f       	subi	r16, 0xFE	; 254
    2792:	1f 4f       	sbci	r17, 0xFF	; 255
    2794:	c8 01       	movw	r24, r16
    2796:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    279a:	e9 89       	ldd	r30, Y+17	; 0x11
    279c:	fa 89       	ldd	r31, Y+18	; 0x12
    279e:	ce 01       	movw	r24, r28
    27a0:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    27a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    27a4:	81 30       	cpi	r24, 0x01	; 1
    27a6:	e1 f4       	brne	.+56     	; 0x27e0 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    27a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    27aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    27ac:	8a 0d       	add	r24, r10
    27ae:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    27b0:	a8 16       	cp	r10, r24
    27b2:	b9 06       	cpc	r11, r25
    27b4:	60 f4       	brcc	.+24     	; 0x27ce <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    27b6:	9b 83       	std	Y+3, r25	; 0x03
    27b8:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    27ba:	d9 87       	std	Y+9, r29	; 0x09
    27bc:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    27be:	b8 01       	movw	r22, r16
    27c0:	80 91 d5 08 	lds	r24, 0x08D5	; 0x8008d5 <pxCurrentTimerList>
    27c4:	90 91 d6 08 	lds	r25, 0x08D6	; 0x8008d6 <pxCurrentTimerList+0x1>
    27c8:	0e 94 2f 07 	call	0xe5e	; 0xe5e <vListInsert>
    27cc:	09 c0       	rjmp	.+18     	; 0x27e0 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    27ce:	00 e0       	ldi	r16, 0x00	; 0
    27d0:	10 e0       	ldi	r17, 0x00	; 0
    27d2:	20 e0       	ldi	r18, 0x00	; 0
    27d4:	30 e0       	ldi	r19, 0x00	; 0
    27d6:	a5 01       	movw	r20, r10
    27d8:	60 e0       	ldi	r22, 0x00	; 0
    27da:	ce 01       	movw	r24, r28
    27dc:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    27e0:	e0 91 d5 08 	lds	r30, 0x08D5	; 0x8008d5 <pxCurrentTimerList>
    27e4:	f0 91 d6 08 	lds	r31, 0x08D6	; 0x8008d6 <pxCurrentTimerList+0x1>
    27e8:	90 81       	ld	r25, Z
    27ea:	91 11       	cpse	r25, r1
    27ec:	c9 cf       	rjmp	.-110    	; 0x2780 <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    27ee:	80 91 d3 08 	lds	r24, 0x08D3	; 0x8008d3 <pxOverflowTimerList>
    27f2:	90 91 d4 08 	lds	r25, 0x08D4	; 0x8008d4 <pxOverflowTimerList+0x1>
    27f6:	90 93 d6 08 	sts	0x08D6, r25	; 0x8008d6 <pxCurrentTimerList+0x1>
    27fa:	80 93 d5 08 	sts	0x08D5, r24	; 0x8008d5 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    27fe:	f0 93 d4 08 	sts	0x08D4, r31	; 0x8008d4 <pxOverflowTimerList+0x1>
    2802:	e0 93 d3 08 	sts	0x08D3, r30	; 0x8008d3 <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2806:	81 e0       	ldi	r24, 0x01	; 1
    2808:	f6 01       	movw	r30, r12
    280a:	80 83       	st	Z, r24
    280c:	02 c0       	rjmp	.+4      	; 0x2812 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    280e:	f6 01       	movw	r30, r12
    2810:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2812:	f0 92 ce 08 	sts	0x08CE, r15	; 0x8008ce <xLastTime.2242+0x1>
    2816:	e0 92 cd 08 	sts	0x08CD, r14	; 0x8008cd <xLastTime.2242>

	return xTimeNow;
}
    281a:	c7 01       	movw	r24, r14
    281c:	df 91       	pop	r29
    281e:	cf 91       	pop	r28
    2820:	1f 91       	pop	r17
    2822:	0f 91       	pop	r16
    2824:	ff 90       	pop	r15
    2826:	ef 90       	pop	r14
    2828:	df 90       	pop	r13
    282a:	cf 90       	pop	r12
    282c:	bf 90       	pop	r11
    282e:	af 90       	pop	r10
    2830:	08 95       	ret

00002832 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2832:	cf 93       	push	r28
    2834:	df 93       	push	r29
    2836:	00 d0       	rcall	.+0      	; 0x2838 <prvTimerTask+0x6>
    2838:	00 d0       	rcall	.+0      	; 0x283a <prvTimerTask+0x8>
    283a:	00 d0       	rcall	.+0      	; 0x283c <prvTimerTask+0xa>
    283c:	cd b7       	in	r28, 0x3d	; 61
    283e:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2840:	ce 01       	movw	r24, r28
    2842:	01 96       	adiw	r24, 0x01	; 1
    2844:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2846:	44 24       	eor	r4, r4
    2848:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    284a:	e1 2c       	mov	r14, r1
    284c:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    284e:	d1 2c       	mov	r13, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2850:	58 2e       	mov	r5, r24
    2852:	c9 2c       	mov	r12, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2854:	e0 91 d5 08 	lds	r30, 0x08D5	; 0x8008d5 <pxCurrentTimerList>
    2858:	f0 91 d6 08 	lds	r31, 0x08D6	; 0x8008d6 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    285c:	80 81       	ld	r24, Z
    285e:	88 23       	and	r24, r24
    2860:	79 f0       	breq	.+30     	; 0x2880 <prvTimerTask+0x4e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2862:	05 80       	ldd	r0, Z+5	; 0x05
    2864:	f6 81       	ldd	r31, Z+6	; 0x06
    2866:	e0 2d       	mov	r30, r0
    2868:	a0 80       	ld	r10, Z
    286a:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    286c:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2870:	c4 01       	movw	r24, r8
    2872:	0e 94 a9 13 	call	0x2752	; 0x2752 <prvSampleTimeNow>
    2876:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2878:	89 81       	ldd	r24, Y+1	; 0x01
    287a:	88 23       	and	r24, r24
    287c:	59 f0       	breq	.+22     	; 0x2894 <prvTimerTask+0x62>
    287e:	5d c0       	rjmp	.+186    	; 0x293a <prvTimerTask+0x108>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2880:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2884:	c4 01       	movw	r24, r8
    2886:	0e 94 a9 13 	call	0x2752	; 0x2752 <prvSampleTimeNow>
    288a:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    288c:	89 81       	ldd	r24, Y+1	; 0x01
    288e:	88 23       	and	r24, r24
    2890:	c1 f1       	breq	.+112    	; 0x2902 <prvTimerTask+0xd0>
    2892:	53 c0       	rjmp	.+166    	; 0x293a <prvTimerTask+0x108>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2894:	0a 15       	cp	r16, r10
    2896:	1b 05       	cpc	r17, r11
    2898:	08 f4       	brcc	.+2      	; 0x289c <prvTimerTask+0x6a>
    289a:	3e c0       	rjmp	.+124    	; 0x2918 <prvTimerTask+0xe6>
			{
				( void ) xTaskResumeAll();
    289c:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    28a0:	e0 91 d5 08 	lds	r30, 0x08D5	; 0x8008d5 <pxCurrentTimerList>
    28a4:	f0 91 d6 08 	lds	r31, 0x08D6	; 0x8008d6 <pxCurrentTimerList+0x1>
    28a8:	05 80       	ldd	r0, Z+5	; 0x05
    28aa:	f6 81       	ldd	r31, Z+6	; 0x06
    28ac:	e0 2d       	mov	r30, r0
    28ae:	66 80       	ldd	r6, Z+6	; 0x06
    28b0:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    28b2:	c3 01       	movw	r24, r6
    28b4:	02 96       	adiw	r24, 0x02	; 2
    28b6:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    28ba:	d3 01       	movw	r26, r6
    28bc:	1e 96       	adiw	r26, 0x0e	; 14
    28be:	8c 91       	ld	r24, X
    28c0:	1e 97       	sbiw	r26, 0x0e	; 14
    28c2:	81 30       	cpi	r24, 0x01	; 1
    28c4:	b1 f4       	brne	.+44     	; 0x28f2 <prvTimerTask+0xc0>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    28c6:	1c 96       	adiw	r26, 0x0c	; 12
    28c8:	6d 91       	ld	r22, X+
    28ca:	7c 91       	ld	r23, X
    28cc:	1d 97       	sbiw	r26, 0x0d	; 13
    28ce:	6a 0d       	add	r22, r10
    28d0:	7b 1d       	adc	r23, r11
    28d2:	95 01       	movw	r18, r10
    28d4:	a8 01       	movw	r20, r16
    28d6:	c3 01       	movw	r24, r6
    28d8:	0e 94 b5 12 	call	0x256a	; 0x256a <prvInsertTimerInActiveList>
    28dc:	88 23       	and	r24, r24
    28de:	49 f0       	breq	.+18     	; 0x28f2 <prvTimerTask+0xc0>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    28e0:	0e 2d       	mov	r16, r14
    28e2:	1f 2d       	mov	r17, r15
    28e4:	2e 2d       	mov	r18, r14
    28e6:	3f 2d       	mov	r19, r15
    28e8:	a5 01       	movw	r20, r10
    28ea:	6d 2d       	mov	r22, r13
    28ec:	c3 01       	movw	r24, r6
    28ee:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    28f2:	d3 01       	movw	r26, r6
    28f4:	51 96       	adiw	r26, 0x11	; 17
    28f6:	ed 91       	ld	r30, X+
    28f8:	fc 91       	ld	r31, X
    28fa:	52 97       	sbiw	r26, 0x12	; 18
    28fc:	c3 01       	movw	r24, r6
    28fe:	09 95       	icall
    2900:	7c c0       	rjmp	.+248    	; 0x29fa <prvTimerTask+0x1c8>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2902:	e0 91 d3 08 	lds	r30, 0x08D3	; 0x8008d3 <pxOverflowTimerList>
    2906:	f0 91 d4 08 	lds	r31, 0x08D4	; 0x8008d4 <pxOverflowTimerList+0x1>
    290a:	44 2d       	mov	r20, r4
    290c:	80 81       	ld	r24, Z
    290e:	81 11       	cpse	r24, r1
    2910:	4d 2d       	mov	r20, r13
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2912:	ae 2c       	mov	r10, r14
    2914:	bf 2c       	mov	r11, r15
    2916:	01 c0       	rjmp	.+2      	; 0x291a <prvTimerTask+0xe8>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2918:	4d 2d       	mov	r20, r13
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    291a:	b5 01       	movw	r22, r10
    291c:	60 1b       	sub	r22, r16
    291e:	71 0b       	sbc	r23, r17
    2920:	80 91 d1 08 	lds	r24, 0x08D1	; 0x8008d1 <xTimerQueue>
    2924:	90 91 d2 08 	lds	r25, 0x08D2	; 0x8008d2 <xTimerQueue+0x1>
    2928:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    292c:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    2930:	81 11       	cpse	r24, r1
    2932:	63 c0       	rjmp	.+198    	; 0x29fa <prvTimerTask+0x1c8>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2934:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    2938:	60 c0       	rjmp	.+192    	; 0x29fa <prvTimerTask+0x1c8>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    293a:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
    293e:	5d c0       	rjmp	.+186    	; 0x29fa <prvTimerTask+0x1c8>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2940:	89 81       	ldd	r24, Y+1	; 0x01
    2942:	88 23       	and	r24, r24
    2944:	0c f4       	brge	.+2      	; 0x2948 <prvTimerTask+0x116>
    2946:	59 c0       	rjmp	.+178    	; 0x29fa <prvTimerTask+0x1c8>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2948:	ac 80       	ldd	r10, Y+4	; 0x04
    294a:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    294c:	f5 01       	movw	r30, r10
    294e:	82 85       	ldd	r24, Z+10	; 0x0a
    2950:	93 85       	ldd	r25, Z+11	; 0x0b
    2952:	89 2b       	or	r24, r25
    2954:	21 f0       	breq	.+8      	; 0x295e <prvTimerTask+0x12c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2956:	c5 01       	movw	r24, r10
    2958:	02 96       	adiw	r24, 0x02	; 2
    295a:	0e 94 60 07 	call	0xec0	; 0xec0 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    295e:	ce 01       	movw	r24, r28
    2960:	06 96       	adiw	r24, 0x06	; 6
    2962:	0e 94 a9 13 	call	0x2752	; 0x2752 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    2966:	e9 81       	ldd	r30, Y+1	; 0x01
    2968:	0e 2f       	mov	r16, r30
    296a:	ee 0f       	add	r30, r30
    296c:	11 0b       	sbc	r17, r17
    296e:	22 0b       	sbc	r18, r18
    2970:	33 0b       	sbc	r19, r19
    2972:	0a 30       	cpi	r16, 0x0A	; 10
    2974:	11 05       	cpc	r17, r1
    2976:	08 f0       	brcs	.+2      	; 0x297a <prvTimerTask+0x148>
    2978:	40 c0       	rjmp	.+128    	; 0x29fa <prvTimerTask+0x1c8>
    297a:	f8 01       	movw	r30, r16
    297c:	e2 5c       	subi	r30, 0xC2	; 194
    297e:	ff 4f       	sbci	r31, 0xFF	; 255
    2980:	0c 94 2d 15 	jmp	0x2a5a	; 0x2a5a <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2984:	2a 81       	ldd	r18, Y+2	; 0x02
    2986:	3b 81       	ldd	r19, Y+3	; 0x03
    2988:	d5 01       	movw	r26, r10
    298a:	1c 96       	adiw	r26, 0x0c	; 12
    298c:	6d 91       	ld	r22, X+
    298e:	7c 91       	ld	r23, X
    2990:	1d 97       	sbiw	r26, 0x0d	; 13
    2992:	62 0f       	add	r22, r18
    2994:	73 1f       	adc	r23, r19
    2996:	ac 01       	movw	r20, r24
    2998:	c5 01       	movw	r24, r10
    299a:	0e 94 b5 12 	call	0x256a	; 0x256a <prvInsertTimerInActiveList>
    299e:	88 23       	and	r24, r24
    29a0:	61 f1       	breq	.+88     	; 0x29fa <prvTimerTask+0x1c8>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    29a2:	d5 01       	movw	r26, r10
    29a4:	51 96       	adiw	r26, 0x11	; 17
    29a6:	ed 91       	ld	r30, X+
    29a8:	fc 91       	ld	r31, X
    29aa:	52 97       	sbiw	r26, 0x12	; 18
    29ac:	c5 01       	movw	r24, r10
    29ae:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    29b0:	f5 01       	movw	r30, r10
    29b2:	86 85       	ldd	r24, Z+14	; 0x0e
    29b4:	81 30       	cpi	r24, 0x01	; 1
    29b6:	09 f5       	brne	.+66     	; 0x29fa <prvTimerTask+0x1c8>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    29b8:	44 85       	ldd	r20, Z+12	; 0x0c
    29ba:	55 85       	ldd	r21, Z+13	; 0x0d
    29bc:	8a 81       	ldd	r24, Y+2	; 0x02
    29be:	9b 81       	ldd	r25, Y+3	; 0x03
    29c0:	48 0f       	add	r20, r24
    29c2:	59 1f       	adc	r21, r25
    29c4:	0e 2d       	mov	r16, r14
    29c6:	1f 2d       	mov	r17, r15
    29c8:	2e 2d       	mov	r18, r14
    29ca:	3f 2d       	mov	r19, r15
    29cc:	6d 2d       	mov	r22, r13
    29ce:	c5 01       	movw	r24, r10
    29d0:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTimerGenericCommand>
    29d4:	12 c0       	rjmp	.+36     	; 0x29fa <prvTimerTask+0x1c8>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    29d6:	6a 81       	ldd	r22, Y+2	; 0x02
    29d8:	7b 81       	ldd	r23, Y+3	; 0x03
    29da:	d5 01       	movw	r26, r10
    29dc:	1d 96       	adiw	r26, 0x0d	; 13
    29de:	7c 93       	st	X, r23
    29e0:	6e 93       	st	-X, r22
    29e2:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    29e4:	68 0f       	add	r22, r24
    29e6:	79 1f       	adc	r23, r25
    29e8:	9c 01       	movw	r18, r24
    29ea:	ac 01       	movw	r20, r24
    29ec:	c5 01       	movw	r24, r10
    29ee:	0e 94 b5 12 	call	0x256a	; 0x256a <prvInsertTimerInActiveList>
    29f2:	03 c0       	rjmp	.+6      	; 0x29fa <prvTimerTask+0x1c8>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    29f4:	c5 01       	movw	r24, r10
    29f6:	0e 94 de 08 	call	0x11bc	; 0x11bc <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    29fa:	2d 2d       	mov	r18, r13
    29fc:	4e 2d       	mov	r20, r14
    29fe:	5f 2d       	mov	r21, r15
    2a00:	65 2d       	mov	r22, r5
    2a02:	7c 2d       	mov	r23, r12
    2a04:	80 91 d1 08 	lds	r24, 0x08D1	; 0x8008d1 <xTimerQueue>
    2a08:	90 91 d2 08 	lds	r25, 0x08D2	; 0x8008d2 <xTimerQueue+0x1>
    2a0c:	0e 94 c7 0c 	call	0x198e	; 0x198e <xQueueGenericReceive>
    2a10:	81 11       	cpse	r24, r1
    2a12:	96 cf       	rjmp	.-212    	; 0x2940 <prvTimerTask+0x10e>
    2a14:	1f cf       	rjmp	.-450    	; 0x2854 <prvTimerTask+0x22>

00002a16 <__udivmodsi4>:
    2a16:	a1 e2       	ldi	r26, 0x21	; 33
    2a18:	1a 2e       	mov	r1, r26
    2a1a:	aa 1b       	sub	r26, r26
    2a1c:	bb 1b       	sub	r27, r27
    2a1e:	fd 01       	movw	r30, r26
    2a20:	0d c0       	rjmp	.+26     	; 0x2a3c <__udivmodsi4_ep>

00002a22 <__udivmodsi4_loop>:
    2a22:	aa 1f       	adc	r26, r26
    2a24:	bb 1f       	adc	r27, r27
    2a26:	ee 1f       	adc	r30, r30
    2a28:	ff 1f       	adc	r31, r31
    2a2a:	a2 17       	cp	r26, r18
    2a2c:	b3 07       	cpc	r27, r19
    2a2e:	e4 07       	cpc	r30, r20
    2a30:	f5 07       	cpc	r31, r21
    2a32:	20 f0       	brcs	.+8      	; 0x2a3c <__udivmodsi4_ep>
    2a34:	a2 1b       	sub	r26, r18
    2a36:	b3 0b       	sbc	r27, r19
    2a38:	e4 0b       	sbc	r30, r20
    2a3a:	f5 0b       	sbc	r31, r21

00002a3c <__udivmodsi4_ep>:
    2a3c:	66 1f       	adc	r22, r22
    2a3e:	77 1f       	adc	r23, r23
    2a40:	88 1f       	adc	r24, r24
    2a42:	99 1f       	adc	r25, r25
    2a44:	1a 94       	dec	r1
    2a46:	69 f7       	brne	.-38     	; 0x2a22 <__udivmodsi4_loop>
    2a48:	60 95       	com	r22
    2a4a:	70 95       	com	r23
    2a4c:	80 95       	com	r24
    2a4e:	90 95       	com	r25
    2a50:	9b 01       	movw	r18, r22
    2a52:	ac 01       	movw	r20, r24
    2a54:	bd 01       	movw	r22, r26
    2a56:	cf 01       	movw	r24, r30
    2a58:	08 95       	ret

00002a5a <__tablejump2__>:
    2a5a:	ee 0f       	add	r30, r30
    2a5c:	ff 1f       	adc	r31, r31
    2a5e:	05 90       	lpm	r0, Z+
    2a60:	f4 91       	lpm	r31, Z
    2a62:	e0 2d       	mov	r30, r0
    2a64:	09 94       	ijmp

00002a66 <malloc>:
    2a66:	cf 93       	push	r28
    2a68:	df 93       	push	r29
    2a6a:	82 30       	cpi	r24, 0x02	; 2
    2a6c:	91 05       	cpc	r25, r1
    2a6e:	10 f4       	brcc	.+4      	; 0x2a74 <malloc+0xe>
    2a70:	82 e0       	ldi	r24, 0x02	; 2
    2a72:	90 e0       	ldi	r25, 0x00	; 0
    2a74:	e0 91 eb 08 	lds	r30, 0x08EB	; 0x8008eb <__flp>
    2a78:	f0 91 ec 08 	lds	r31, 0x08EC	; 0x8008ec <__flp+0x1>
    2a7c:	20 e0       	ldi	r18, 0x00	; 0
    2a7e:	30 e0       	ldi	r19, 0x00	; 0
    2a80:	c0 e0       	ldi	r28, 0x00	; 0
    2a82:	d0 e0       	ldi	r29, 0x00	; 0
    2a84:	30 97       	sbiw	r30, 0x00	; 0
    2a86:	11 f1       	breq	.+68     	; 0x2acc <malloc+0x66>
    2a88:	40 81       	ld	r20, Z
    2a8a:	51 81       	ldd	r21, Z+1	; 0x01
    2a8c:	48 17       	cp	r20, r24
    2a8e:	59 07       	cpc	r21, r25
    2a90:	c0 f0       	brcs	.+48     	; 0x2ac2 <malloc+0x5c>
    2a92:	48 17       	cp	r20, r24
    2a94:	59 07       	cpc	r21, r25
    2a96:	61 f4       	brne	.+24     	; 0x2ab0 <malloc+0x4a>
    2a98:	82 81       	ldd	r24, Z+2	; 0x02
    2a9a:	93 81       	ldd	r25, Z+3	; 0x03
    2a9c:	20 97       	sbiw	r28, 0x00	; 0
    2a9e:	19 f0       	breq	.+6      	; 0x2aa6 <malloc+0x40>
    2aa0:	9b 83       	std	Y+3, r25	; 0x03
    2aa2:	8a 83       	std	Y+2, r24	; 0x02
    2aa4:	2b c0       	rjmp	.+86     	; 0x2afc <malloc+0x96>
    2aa6:	90 93 ec 08 	sts	0x08EC, r25	; 0x8008ec <__flp+0x1>
    2aaa:	80 93 eb 08 	sts	0x08EB, r24	; 0x8008eb <__flp>
    2aae:	26 c0       	rjmp	.+76     	; 0x2afc <malloc+0x96>
    2ab0:	21 15       	cp	r18, r1
    2ab2:	31 05       	cpc	r19, r1
    2ab4:	19 f0       	breq	.+6      	; 0x2abc <malloc+0x56>
    2ab6:	42 17       	cp	r20, r18
    2ab8:	53 07       	cpc	r21, r19
    2aba:	18 f4       	brcc	.+6      	; 0x2ac2 <malloc+0x5c>
    2abc:	9a 01       	movw	r18, r20
    2abe:	be 01       	movw	r22, r28
    2ac0:	df 01       	movw	r26, r30
    2ac2:	ef 01       	movw	r28, r30
    2ac4:	02 80       	ldd	r0, Z+2	; 0x02
    2ac6:	f3 81       	ldd	r31, Z+3	; 0x03
    2ac8:	e0 2d       	mov	r30, r0
    2aca:	dc cf       	rjmp	.-72     	; 0x2a84 <malloc+0x1e>
    2acc:	21 15       	cp	r18, r1
    2ace:	31 05       	cpc	r19, r1
    2ad0:	09 f1       	breq	.+66     	; 0x2b14 <malloc+0xae>
    2ad2:	28 1b       	sub	r18, r24
    2ad4:	39 0b       	sbc	r19, r25
    2ad6:	24 30       	cpi	r18, 0x04	; 4
    2ad8:	31 05       	cpc	r19, r1
    2ada:	90 f4       	brcc	.+36     	; 0x2b00 <malloc+0x9a>
    2adc:	12 96       	adiw	r26, 0x02	; 2
    2ade:	8d 91       	ld	r24, X+
    2ae0:	9c 91       	ld	r25, X
    2ae2:	13 97       	sbiw	r26, 0x03	; 3
    2ae4:	61 15       	cp	r22, r1
    2ae6:	71 05       	cpc	r23, r1
    2ae8:	21 f0       	breq	.+8      	; 0x2af2 <malloc+0x8c>
    2aea:	fb 01       	movw	r30, r22
    2aec:	93 83       	std	Z+3, r25	; 0x03
    2aee:	82 83       	std	Z+2, r24	; 0x02
    2af0:	04 c0       	rjmp	.+8      	; 0x2afa <malloc+0x94>
    2af2:	90 93 ec 08 	sts	0x08EC, r25	; 0x8008ec <__flp+0x1>
    2af6:	80 93 eb 08 	sts	0x08EB, r24	; 0x8008eb <__flp>
    2afa:	fd 01       	movw	r30, r26
    2afc:	32 96       	adiw	r30, 0x02	; 2
    2afe:	44 c0       	rjmp	.+136    	; 0x2b88 <malloc+0x122>
    2b00:	fd 01       	movw	r30, r26
    2b02:	e2 0f       	add	r30, r18
    2b04:	f3 1f       	adc	r31, r19
    2b06:	81 93       	st	Z+, r24
    2b08:	91 93       	st	Z+, r25
    2b0a:	22 50       	subi	r18, 0x02	; 2
    2b0c:	31 09       	sbc	r19, r1
    2b0e:	2d 93       	st	X+, r18
    2b10:	3c 93       	st	X, r19
    2b12:	3a c0       	rjmp	.+116    	; 0x2b88 <malloc+0x122>
    2b14:	20 91 e9 08 	lds	r18, 0x08E9	; 0x8008e9 <__brkval>
    2b18:	30 91 ea 08 	lds	r19, 0x08EA	; 0x8008ea <__brkval+0x1>
    2b1c:	23 2b       	or	r18, r19
    2b1e:	41 f4       	brne	.+16     	; 0x2b30 <malloc+0xca>
    2b20:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    2b24:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    2b28:	30 93 ea 08 	sts	0x08EA, r19	; 0x8008ea <__brkval+0x1>
    2b2c:	20 93 e9 08 	sts	0x08E9, r18	; 0x8008e9 <__brkval>
    2b30:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    2b34:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    2b38:	21 15       	cp	r18, r1
    2b3a:	31 05       	cpc	r19, r1
    2b3c:	41 f4       	brne	.+16     	; 0x2b4e <malloc+0xe8>
    2b3e:	2d b7       	in	r18, 0x3d	; 61
    2b40:	3e b7       	in	r19, 0x3e	; 62
    2b42:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    2b46:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    2b4a:	24 1b       	sub	r18, r20
    2b4c:	35 0b       	sbc	r19, r21
    2b4e:	e0 91 e9 08 	lds	r30, 0x08E9	; 0x8008e9 <__brkval>
    2b52:	f0 91 ea 08 	lds	r31, 0x08EA	; 0x8008ea <__brkval+0x1>
    2b56:	e2 17       	cp	r30, r18
    2b58:	f3 07       	cpc	r31, r19
    2b5a:	a0 f4       	brcc	.+40     	; 0x2b84 <malloc+0x11e>
    2b5c:	2e 1b       	sub	r18, r30
    2b5e:	3f 0b       	sbc	r19, r31
    2b60:	28 17       	cp	r18, r24
    2b62:	39 07       	cpc	r19, r25
    2b64:	78 f0       	brcs	.+30     	; 0x2b84 <malloc+0x11e>
    2b66:	ac 01       	movw	r20, r24
    2b68:	4e 5f       	subi	r20, 0xFE	; 254
    2b6a:	5f 4f       	sbci	r21, 0xFF	; 255
    2b6c:	24 17       	cp	r18, r20
    2b6e:	35 07       	cpc	r19, r21
    2b70:	48 f0       	brcs	.+18     	; 0x2b84 <malloc+0x11e>
    2b72:	4e 0f       	add	r20, r30
    2b74:	5f 1f       	adc	r21, r31
    2b76:	50 93 ea 08 	sts	0x08EA, r21	; 0x8008ea <__brkval+0x1>
    2b7a:	40 93 e9 08 	sts	0x08E9, r20	; 0x8008e9 <__brkval>
    2b7e:	81 93       	st	Z+, r24
    2b80:	91 93       	st	Z+, r25
    2b82:	02 c0       	rjmp	.+4      	; 0x2b88 <malloc+0x122>
    2b84:	e0 e0       	ldi	r30, 0x00	; 0
    2b86:	f0 e0       	ldi	r31, 0x00	; 0
    2b88:	cf 01       	movw	r24, r30
    2b8a:	df 91       	pop	r29
    2b8c:	cf 91       	pop	r28
    2b8e:	08 95       	ret

00002b90 <free>:
    2b90:	0f 93       	push	r16
    2b92:	1f 93       	push	r17
    2b94:	cf 93       	push	r28
    2b96:	df 93       	push	r29
    2b98:	00 97       	sbiw	r24, 0x00	; 0
    2b9a:	09 f4       	brne	.+2      	; 0x2b9e <free+0xe>
    2b9c:	8c c0       	rjmp	.+280    	; 0x2cb6 <free+0x126>
    2b9e:	fc 01       	movw	r30, r24
    2ba0:	32 97       	sbiw	r30, 0x02	; 2
    2ba2:	13 82       	std	Z+3, r1	; 0x03
    2ba4:	12 82       	std	Z+2, r1	; 0x02
    2ba6:	00 91 eb 08 	lds	r16, 0x08EB	; 0x8008eb <__flp>
    2baa:	10 91 ec 08 	lds	r17, 0x08EC	; 0x8008ec <__flp+0x1>
    2bae:	01 15       	cp	r16, r1
    2bb0:	11 05       	cpc	r17, r1
    2bb2:	81 f4       	brne	.+32     	; 0x2bd4 <free+0x44>
    2bb4:	20 81       	ld	r18, Z
    2bb6:	31 81       	ldd	r19, Z+1	; 0x01
    2bb8:	82 0f       	add	r24, r18
    2bba:	93 1f       	adc	r25, r19
    2bbc:	20 91 e9 08 	lds	r18, 0x08E9	; 0x8008e9 <__brkval>
    2bc0:	30 91 ea 08 	lds	r19, 0x08EA	; 0x8008ea <__brkval+0x1>
    2bc4:	28 17       	cp	r18, r24
    2bc6:	39 07       	cpc	r19, r25
    2bc8:	79 f5       	brne	.+94     	; 0x2c28 <free+0x98>
    2bca:	f0 93 ea 08 	sts	0x08EA, r31	; 0x8008ea <__brkval+0x1>
    2bce:	e0 93 e9 08 	sts	0x08E9, r30	; 0x8008e9 <__brkval>
    2bd2:	71 c0       	rjmp	.+226    	; 0x2cb6 <free+0x126>
    2bd4:	d8 01       	movw	r26, r16
    2bd6:	40 e0       	ldi	r20, 0x00	; 0
    2bd8:	50 e0       	ldi	r21, 0x00	; 0
    2bda:	ae 17       	cp	r26, r30
    2bdc:	bf 07       	cpc	r27, r31
    2bde:	50 f4       	brcc	.+20     	; 0x2bf4 <free+0x64>
    2be0:	12 96       	adiw	r26, 0x02	; 2
    2be2:	2d 91       	ld	r18, X+
    2be4:	3c 91       	ld	r19, X
    2be6:	13 97       	sbiw	r26, 0x03	; 3
    2be8:	ad 01       	movw	r20, r26
    2bea:	21 15       	cp	r18, r1
    2bec:	31 05       	cpc	r19, r1
    2bee:	09 f1       	breq	.+66     	; 0x2c32 <free+0xa2>
    2bf0:	d9 01       	movw	r26, r18
    2bf2:	f3 cf       	rjmp	.-26     	; 0x2bda <free+0x4a>
    2bf4:	9d 01       	movw	r18, r26
    2bf6:	da 01       	movw	r26, r20
    2bf8:	33 83       	std	Z+3, r19	; 0x03
    2bfa:	22 83       	std	Z+2, r18	; 0x02
    2bfc:	60 81       	ld	r22, Z
    2bfe:	71 81       	ldd	r23, Z+1	; 0x01
    2c00:	86 0f       	add	r24, r22
    2c02:	97 1f       	adc	r25, r23
    2c04:	82 17       	cp	r24, r18
    2c06:	93 07       	cpc	r25, r19
    2c08:	69 f4       	brne	.+26     	; 0x2c24 <free+0x94>
    2c0a:	ec 01       	movw	r28, r24
    2c0c:	28 81       	ld	r18, Y
    2c0e:	39 81       	ldd	r19, Y+1	; 0x01
    2c10:	26 0f       	add	r18, r22
    2c12:	37 1f       	adc	r19, r23
    2c14:	2e 5f       	subi	r18, 0xFE	; 254
    2c16:	3f 4f       	sbci	r19, 0xFF	; 255
    2c18:	31 83       	std	Z+1, r19	; 0x01
    2c1a:	20 83       	st	Z, r18
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c20:	93 83       	std	Z+3, r25	; 0x03
    2c22:	82 83       	std	Z+2, r24	; 0x02
    2c24:	45 2b       	or	r20, r21
    2c26:	29 f4       	brne	.+10     	; 0x2c32 <free+0xa2>
    2c28:	f0 93 ec 08 	sts	0x08EC, r31	; 0x8008ec <__flp+0x1>
    2c2c:	e0 93 eb 08 	sts	0x08EB, r30	; 0x8008eb <__flp>
    2c30:	42 c0       	rjmp	.+132    	; 0x2cb6 <free+0x126>
    2c32:	13 96       	adiw	r26, 0x03	; 3
    2c34:	fc 93       	st	X, r31
    2c36:	ee 93       	st	-X, r30
    2c38:	12 97       	sbiw	r26, 0x02	; 2
    2c3a:	ed 01       	movw	r28, r26
    2c3c:	49 91       	ld	r20, Y+
    2c3e:	59 91       	ld	r21, Y+
    2c40:	9e 01       	movw	r18, r28
    2c42:	24 0f       	add	r18, r20
    2c44:	35 1f       	adc	r19, r21
    2c46:	e2 17       	cp	r30, r18
    2c48:	f3 07       	cpc	r31, r19
    2c4a:	71 f4       	brne	.+28     	; 0x2c68 <free+0xd8>
    2c4c:	80 81       	ld	r24, Z
    2c4e:	91 81       	ldd	r25, Z+1	; 0x01
    2c50:	84 0f       	add	r24, r20
    2c52:	95 1f       	adc	r25, r21
    2c54:	02 96       	adiw	r24, 0x02	; 2
    2c56:	11 96       	adiw	r26, 0x01	; 1
    2c58:	9c 93       	st	X, r25
    2c5a:	8e 93       	st	-X, r24
    2c5c:	82 81       	ldd	r24, Z+2	; 0x02
    2c5e:	93 81       	ldd	r25, Z+3	; 0x03
    2c60:	13 96       	adiw	r26, 0x03	; 3
    2c62:	9c 93       	st	X, r25
    2c64:	8e 93       	st	-X, r24
    2c66:	12 97       	sbiw	r26, 0x02	; 2
    2c68:	e0 e0       	ldi	r30, 0x00	; 0
    2c6a:	f0 e0       	ldi	r31, 0x00	; 0
    2c6c:	d8 01       	movw	r26, r16
    2c6e:	12 96       	adiw	r26, 0x02	; 2
    2c70:	8d 91       	ld	r24, X+
    2c72:	9c 91       	ld	r25, X
    2c74:	13 97       	sbiw	r26, 0x03	; 3
    2c76:	00 97       	sbiw	r24, 0x00	; 0
    2c78:	19 f0       	breq	.+6      	; 0x2c80 <free+0xf0>
    2c7a:	f8 01       	movw	r30, r16
    2c7c:	8c 01       	movw	r16, r24
    2c7e:	f6 cf       	rjmp	.-20     	; 0x2c6c <free+0xdc>
    2c80:	8d 91       	ld	r24, X+
    2c82:	9c 91       	ld	r25, X
    2c84:	98 01       	movw	r18, r16
    2c86:	2e 5f       	subi	r18, 0xFE	; 254
    2c88:	3f 4f       	sbci	r19, 0xFF	; 255
    2c8a:	82 0f       	add	r24, r18
    2c8c:	93 1f       	adc	r25, r19
    2c8e:	20 91 e9 08 	lds	r18, 0x08E9	; 0x8008e9 <__brkval>
    2c92:	30 91 ea 08 	lds	r19, 0x08EA	; 0x8008ea <__brkval+0x1>
    2c96:	28 17       	cp	r18, r24
    2c98:	39 07       	cpc	r19, r25
    2c9a:	69 f4       	brne	.+26     	; 0x2cb6 <free+0x126>
    2c9c:	30 97       	sbiw	r30, 0x00	; 0
    2c9e:	29 f4       	brne	.+10     	; 0x2caa <free+0x11a>
    2ca0:	10 92 ec 08 	sts	0x08EC, r1	; 0x8008ec <__flp+0x1>
    2ca4:	10 92 eb 08 	sts	0x08EB, r1	; 0x8008eb <__flp>
    2ca8:	02 c0       	rjmp	.+4      	; 0x2cae <free+0x11e>
    2caa:	13 82       	std	Z+3, r1	; 0x03
    2cac:	12 82       	std	Z+2, r1	; 0x02
    2cae:	10 93 ea 08 	sts	0x08EA, r17	; 0x8008ea <__brkval+0x1>
    2cb2:	00 93 e9 08 	sts	0x08E9, r16	; 0x8008e9 <__brkval>
    2cb6:	df 91       	pop	r29
    2cb8:	cf 91       	pop	r28
    2cba:	1f 91       	pop	r17
    2cbc:	0f 91       	pop	r16
    2cbe:	08 95       	ret

00002cc0 <do_rand>:
    2cc0:	8f 92       	push	r8
    2cc2:	9f 92       	push	r9
    2cc4:	af 92       	push	r10
    2cc6:	bf 92       	push	r11
    2cc8:	cf 92       	push	r12
    2cca:	df 92       	push	r13
    2ccc:	ef 92       	push	r14
    2cce:	ff 92       	push	r15
    2cd0:	cf 93       	push	r28
    2cd2:	df 93       	push	r29
    2cd4:	ec 01       	movw	r28, r24
    2cd6:	68 81       	ld	r22, Y
    2cd8:	79 81       	ldd	r23, Y+1	; 0x01
    2cda:	8a 81       	ldd	r24, Y+2	; 0x02
    2cdc:	9b 81       	ldd	r25, Y+3	; 0x03
    2cde:	61 15       	cp	r22, r1
    2ce0:	71 05       	cpc	r23, r1
    2ce2:	81 05       	cpc	r24, r1
    2ce4:	91 05       	cpc	r25, r1
    2ce6:	21 f4       	brne	.+8      	; 0x2cf0 <do_rand+0x30>
    2ce8:	64 e2       	ldi	r22, 0x24	; 36
    2cea:	79 ed       	ldi	r23, 0xD9	; 217
    2cec:	8b e5       	ldi	r24, 0x5B	; 91
    2cee:	97 e0       	ldi	r25, 0x07	; 7
    2cf0:	2d e1       	ldi	r18, 0x1D	; 29
    2cf2:	33 ef       	ldi	r19, 0xF3	; 243
    2cf4:	41 e0       	ldi	r20, 0x01	; 1
    2cf6:	50 e0       	ldi	r21, 0x00	; 0
    2cf8:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <__divmodsi4>
    2cfc:	49 01       	movw	r8, r18
    2cfe:	5a 01       	movw	r10, r20
    2d00:	9b 01       	movw	r18, r22
    2d02:	ac 01       	movw	r20, r24
    2d04:	a7 ea       	ldi	r26, 0xA7	; 167
    2d06:	b1 e4       	ldi	r27, 0x41	; 65
    2d08:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <__muluhisi3>
    2d0c:	6b 01       	movw	r12, r22
    2d0e:	7c 01       	movw	r14, r24
    2d10:	ac ee       	ldi	r26, 0xEC	; 236
    2d12:	b4 ef       	ldi	r27, 0xF4	; 244
    2d14:	a5 01       	movw	r20, r10
    2d16:	94 01       	movw	r18, r8
    2d18:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <__mulohisi3>
    2d1c:	dc 01       	movw	r26, r24
    2d1e:	cb 01       	movw	r24, r22
    2d20:	8c 0d       	add	r24, r12
    2d22:	9d 1d       	adc	r25, r13
    2d24:	ae 1d       	adc	r26, r14
    2d26:	bf 1d       	adc	r27, r15
    2d28:	b7 ff       	sbrs	r27, 7
    2d2a:	03 c0       	rjmp	.+6      	; 0x2d32 <do_rand+0x72>
    2d2c:	01 97       	sbiw	r24, 0x01	; 1
    2d2e:	a1 09       	sbc	r26, r1
    2d30:	b0 48       	sbci	r27, 0x80	; 128
    2d32:	88 83       	st	Y, r24
    2d34:	99 83       	std	Y+1, r25	; 0x01
    2d36:	aa 83       	std	Y+2, r26	; 0x02
    2d38:	bb 83       	std	Y+3, r27	; 0x03
    2d3a:	9f 77       	andi	r25, 0x7F	; 127
    2d3c:	df 91       	pop	r29
    2d3e:	cf 91       	pop	r28
    2d40:	ff 90       	pop	r15
    2d42:	ef 90       	pop	r14
    2d44:	df 90       	pop	r13
    2d46:	cf 90       	pop	r12
    2d48:	bf 90       	pop	r11
    2d4a:	af 90       	pop	r10
    2d4c:	9f 90       	pop	r9
    2d4e:	8f 90       	pop	r8
    2d50:	08 95       	ret

00002d52 <rand_r>:
    2d52:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <do_rand>
    2d56:	08 95       	ret

00002d58 <rand>:
    2d58:	86 e0       	ldi	r24, 0x06	; 6
    2d5a:	91 e0       	ldi	r25, 0x01	; 1
    2d5c:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <do_rand>
    2d60:	08 95       	ret

00002d62 <srand>:
    2d62:	a0 e0       	ldi	r26, 0x00	; 0
    2d64:	b0 e0       	ldi	r27, 0x00	; 0
    2d66:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <next>
    2d6a:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <next+0x1>
    2d6e:	a0 93 08 01 	sts	0x0108, r26	; 0x800108 <next+0x2>
    2d72:	b0 93 09 01 	sts	0x0109, r27	; 0x800109 <next+0x3>
    2d76:	08 95       	ret

00002d78 <memcpy>:
    2d78:	fb 01       	movw	r30, r22
    2d7a:	dc 01       	movw	r26, r24
    2d7c:	02 c0       	rjmp	.+4      	; 0x2d82 <memcpy+0xa>
    2d7e:	01 90       	ld	r0, Z+
    2d80:	0d 92       	st	X+, r0
    2d82:	41 50       	subi	r20, 0x01	; 1
    2d84:	50 40       	sbci	r21, 0x00	; 0
    2d86:	d8 f7       	brcc	.-10     	; 0x2d7e <memcpy+0x6>
    2d88:	08 95       	ret

00002d8a <memset>:
    2d8a:	dc 01       	movw	r26, r24
    2d8c:	01 c0       	rjmp	.+2      	; 0x2d90 <memset+0x6>
    2d8e:	6d 93       	st	X+, r22
    2d90:	41 50       	subi	r20, 0x01	; 1
    2d92:	50 40       	sbci	r21, 0x00	; 0
    2d94:	e0 f7       	brcc	.-8      	; 0x2d8e <memset+0x4>
    2d96:	08 95       	ret

00002d98 <__divmodsi4>:
    2d98:	05 2e       	mov	r0, r21
    2d9a:	97 fb       	bst	r25, 7
    2d9c:	1e f4       	brtc	.+6      	; 0x2da4 <__divmodsi4+0xc>
    2d9e:	00 94       	com	r0
    2da0:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <__negsi2>
    2da4:	57 fd       	sbrc	r21, 7
    2da6:	07 d0       	rcall	.+14     	; 0x2db6 <__divmodsi4_neg2>
    2da8:	0e 94 0b 15 	call	0x2a16	; 0x2a16 <__udivmodsi4>
    2dac:	07 fc       	sbrc	r0, 7
    2dae:	03 d0       	rcall	.+6      	; 0x2db6 <__divmodsi4_neg2>
    2db0:	4e f4       	brtc	.+18     	; 0x2dc4 <__divmodsi4_exit>
    2db2:	0c 94 e3 16 	jmp	0x2dc6	; 0x2dc6 <__negsi2>

00002db6 <__divmodsi4_neg2>:
    2db6:	50 95       	com	r21
    2db8:	40 95       	com	r20
    2dba:	30 95       	com	r19
    2dbc:	21 95       	neg	r18
    2dbe:	3f 4f       	sbci	r19, 0xFF	; 255
    2dc0:	4f 4f       	sbci	r20, 0xFF	; 255
    2dc2:	5f 4f       	sbci	r21, 0xFF	; 255

00002dc4 <__divmodsi4_exit>:
    2dc4:	08 95       	ret

00002dc6 <__negsi2>:
    2dc6:	90 95       	com	r25
    2dc8:	80 95       	com	r24
    2dca:	70 95       	com	r23
    2dcc:	61 95       	neg	r22
    2dce:	7f 4f       	sbci	r23, 0xFF	; 255
    2dd0:	8f 4f       	sbci	r24, 0xFF	; 255
    2dd2:	9f 4f       	sbci	r25, 0xFF	; 255
    2dd4:	08 95       	ret

00002dd6 <__muluhisi3>:
    2dd6:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__umulhisi3>
    2dda:	a5 9f       	mul	r26, r21
    2ddc:	90 0d       	add	r25, r0
    2dde:	b4 9f       	mul	r27, r20
    2de0:	90 0d       	add	r25, r0
    2de2:	a4 9f       	mul	r26, r20
    2de4:	80 0d       	add	r24, r0
    2de6:	91 1d       	adc	r25, r1
    2de8:	11 24       	eor	r1, r1
    2dea:	08 95       	ret

00002dec <__mulshisi3>:
    2dec:	b7 ff       	sbrs	r27, 7
    2dee:	0c 94 eb 16 	jmp	0x2dd6	; 0x2dd6 <__muluhisi3>

00002df2 <__mulohisi3>:
    2df2:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <__muluhisi3>
    2df6:	82 1b       	sub	r24, r18
    2df8:	93 0b       	sbc	r25, r19
    2dfa:	08 95       	ret

00002dfc <__umulhisi3>:
    2dfc:	a2 9f       	mul	r26, r18
    2dfe:	b0 01       	movw	r22, r0
    2e00:	b3 9f       	mul	r27, r19
    2e02:	c0 01       	movw	r24, r0
    2e04:	a3 9f       	mul	r26, r19
    2e06:	70 0d       	add	r23, r0
    2e08:	81 1d       	adc	r24, r1
    2e0a:	11 24       	eor	r1, r1
    2e0c:	91 1d       	adc	r25, r1
    2e0e:	b2 9f       	mul	r27, r18
    2e10:	70 0d       	add	r23, r0
    2e12:	81 1d       	adc	r24, r1
    2e14:	11 24       	eor	r1, r1
    2e16:	91 1d       	adc	r25, r1
    2e18:	08 95       	ret

00002e1a <_exit>:
    2e1a:	f8 94       	cli

00002e1c <__stop_program>:
    2e1c:	ff cf       	rjmp	.-2      	; 0x2e1c <__stop_program>
