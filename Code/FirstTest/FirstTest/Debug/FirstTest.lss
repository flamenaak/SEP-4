
FirstTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003a  00800100  00001fbc  00002050  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fbc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005d6  0080013a  0080013a  0000208a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000208a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000020bc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000478  00000000  00000000  000020fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000052fe  00000000  00000000  00002574  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001145  00000000  00000000  00007872  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e49  00000000  00000000  000089b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ea8  00000000  00000000  0000b800  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001921  00000000  00000000  0000c6a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005585  00000000  00000000  0000dfc9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000508  00000000  00000000  0001354e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 d4 05 	jmp	0xba8	; 0xba8 <__vector_13>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 21 03 	jmp	0x642	; 0x642 <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 ca 06 	jmp	0xd94	; 0xd94 <__vector_20>
      54:	0c 94 08 07 	jmp	0xe10	; 0xe10 <__vector_21>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 50 07 	jmp	0xea0	; 0xea0 <__vector_28>
      74:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__vector_29>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec eb       	ldi	r30, 0xBC	; 188
      90:	ff e1       	ldi	r31, 0x1F	; 31
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	aa 33       	cpi	r26, 0x3A	; 58
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	27 e0       	ldi	r18, 0x07	; 7
      a0:	aa e3       	ldi	r26, 0x3A	; 58
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a0 31       	cpi	r26, 0x10	; 16
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <main>
      b2:	0c 94 dc 0f 	jmp	0x1fb8	; 0x1fb8 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <startup_task>:
	// The parameters are not used
	( void ) pvParameters;

	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1 );
      ba:	61 e0       	ldi	r22, 0x01	; 1
      bc:	70 e0       	ldi	r23, 0x00	; 0
      be:	80 e0       	ldi	r24, 0x00	; 0
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <vTaskSetApplicationTaskTag>
	#endif
	
	_x_com_received_chars_queue = xQueueCreate( _COM_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
      c6:	40 e0       	ldi	r20, 0x00	; 0
      c8:	61 e0       	ldi	r22, 0x01	; 1
      ca:	8e e1       	ldi	r24, 0x1E	; 30
      cc:	0e 94 c1 08 	call	0x1182	; 0x1182 <xQueueGenericCreate>
      d0:	90 93 72 02 	sts	0x0272, r25	; 0x800272 <_x_com_received_chars_queue+0x1>
      d4:	80 93 71 02 	sts	0x0271, r24	; 0x800271 <_x_com_received_chars_queue>
	init_com(_x_com_received_chars_queue);
      d8:	0e 94 0a 03 	call	0x614	; 0x614 <init_com>
	
	// Initialise Mutex
	xMutex = xSemaphoreCreateMutex();
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	0e 94 93 09 	call	0x1326	; 0x1326 <xQueueCreateMutex>
      e2:	90 93 70 02 	sts	0x0270, r25	; 0x800270 <xMutex+0x1>
      e6:	80 93 6f 02 	sts	0x026F, r24	; 0x80026f <xMutex>
	
	// Initialization of tasks etc. can be done here
	BaseType_t t1 = xTaskCreate(another_task, (const char *)"Another", configMINIMAL_STACK_SIZE, (void *)NULL, 5, NULL);
      ea:	e1 2c       	mov	r14, r1
      ec:	f1 2c       	mov	r15, r1
      ee:	05 e0       	ldi	r16, 0x05	; 5
      f0:	20 e0       	ldi	r18, 0x00	; 0
      f2:	30 e0       	ldi	r19, 0x00	; 0
      f4:	45 e5       	ldi	r20, 0x55	; 85
      f6:	50 e0       	ldi	r21, 0x00	; 0
      f8:	6a e0       	ldi	r22, 0x0A	; 10
      fa:	71 e0       	ldi	r23, 0x01	; 1
      fc:	86 e3       	ldi	r24, 0x36	; 54
      fe:	92 e0       	ldi	r25, 0x02	; 2
     100:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xTaskCreate>
	BaseType_t t2 = xTaskCreate(obstacles_task, (const char *)"Obstacles", configMINIMAL_STACK_SIZE, (void *)NULL, 4, NULL);
     104:	04 e0       	ldi	r16, 0x04	; 4
     106:	20 e0       	ldi	r18, 0x00	; 0
     108:	30 e0       	ldi	r19, 0x00	; 0
     10a:	45 e5       	ldi	r20, 0x55	; 85
     10c:	50 e0       	ldi	r21, 0x00	; 0
     10e:	62 e1       	ldi	r22, 0x12	; 18
     110:	71 e0       	ldi	r23, 0x01	; 1
     112:	88 e8       	ldi	r24, 0x88	; 136
     114:	92 e0       	ldi	r25, 0x02	; 2
     116:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xTaskCreate>
	
	
	
	// Lets send a start message to the console
	com_send_bytes((uint8_t *)"Then we Start!\n", 15);
     11a:	6f e0       	ldi	r22, 0x0F	; 15
     11c:	8c e1       	ldi	r24, 0x1C	; 28
     11e:	91 e0       	ldi	r25, 0x01	; 1
     120:	0e 94 4a 03 	call	0x694	; 0x694 <com_send_bytes>
	
	while(1)
	{
	
	}
     124:	ff cf       	rjmp	.-2      	; 0x124 <startup_task+0x6a>

00000126 <update>:
// 			myMatrix[i][j] = 0;
// 		}
// 	}
// }

void update(){
     126:	cf 92       	push	r12
     128:	df 92       	push	r13
     12a:	ef 92       	push	r14
     12c:	ff 92       	push	r15
     12e:	0f 93       	push	r16
     130:	1f 93       	push	r17
     132:	cf 93       	push	r28
     134:	df 93       	push	r29
     136:	c3 e5       	ldi	r28, 0x53	; 83
     138:	d2 e0       	ldi	r29, 0x02	; 2
     13a:	4b e3       	ldi	r20, 0x3B	; 59
     13c:	51 e0       	ldi	r21, 0x01	; 1
     13e:	03 e5       	ldi	r16, 0x53	; 83
     140:	12 e0       	ldi	r17, 0x02	; 2
			for (int i = 0; i < 14; i++)
			{
				frame_buf[i] = 0;
				for(int j =0; j < 10 ; j++){
     142:	c1 2c       	mov	r12, r1
     144:	d1 2c       	mov	r13, r1
					if(myMatrix[i][j] == 1){
						 frame_buf[i] |= 1<<j;
     146:	61 e0       	ldi	r22, 0x01	; 1
     148:	70 e0       	ldi	r23, 0x00	; 0
     14a:	de 01       	movw	r26, r28
// }

void update(){
			for (int i = 0; i < 14; i++)
			{
				frame_buf[i] = 0;
     14c:	19 82       	std	Y+1, r1	; 0x01
     14e:	18 82       	st	Y, r1
     150:	fa 01       	movw	r30, r20
				for(int j =0; j < 10 ; j++){
     152:	8c 2d       	mov	r24, r12
     154:	9d 2d       	mov	r25, r13
					if(myMatrix[i][j] == 1){
     156:	21 91       	ld	r18, Z+
     158:	31 91       	ld	r19, Z+
     15a:	21 30       	cpi	r18, 0x01	; 1
     15c:	31 05       	cpc	r19, r1
     15e:	79 f4       	brne	.+30     	; 0x17e <update+0x58>
						 frame_buf[i] |= 1<<j;
     160:	ed 90       	ld	r14, X+
     162:	fc 90       	ld	r15, X
     164:	11 97       	sbiw	r26, 0x01	; 1
     166:	9b 01       	movw	r18, r22
     168:	08 2e       	mov	r0, r24
     16a:	02 c0       	rjmp	.+4      	; 0x170 <update+0x4a>
     16c:	22 0f       	add	r18, r18
     16e:	33 1f       	adc	r19, r19
     170:	0a 94       	dec	r0
     172:	e2 f7       	brpl	.-8      	; 0x16c <update+0x46>
     174:	2e 29       	or	r18, r14
     176:	3f 29       	or	r19, r15
     178:	11 96       	adiw	r26, 0x01	; 1
     17a:	3c 93       	st	X, r19
     17c:	2e 93       	st	-X, r18

void update(){
			for (int i = 0; i < 14; i++)
			{
				frame_buf[i] = 0;
				for(int j =0; j < 10 ; j++){
     17e:	01 96       	adiw	r24, 0x01	; 1
     180:	8a 30       	cpi	r24, 0x0A	; 10
     182:	91 05       	cpc	r25, r1
     184:	41 f7       	brne	.-48     	; 0x156 <update+0x30>
     186:	22 96       	adiw	r28, 0x02	; 2
     188:	4c 5e       	subi	r20, 0xEC	; 236
     18a:	5f 4f       	sbci	r21, 0xFF	; 255
// 		}
// 	}
// }

void update(){
			for (int i = 0; i < 14; i++)
     18c:	40 17       	cp	r20, r16
     18e:	51 07       	cpc	r21, r17
     190:	e1 f6       	brne	.-72     	; 0x14a <update+0x24>
					else {
						
					}				
				}
			}
}
     192:	df 91       	pop	r29
     194:	cf 91       	pop	r28
     196:	1f 91       	pop	r17
     198:	0f 91       	pop	r16
     19a:	ff 90       	pop	r15
     19c:	ef 90       	pop	r14
     19e:	df 90       	pop	r13
     1a0:	cf 90       	pop	r12
     1a2:	08 95       	ret

000001a4 <moveCar>:
	}
}

void moveCar (uint16_t direction, uint16_t car[2]){
	
	switch(direction){
     1a4:	81 30       	cpi	r24, 0x01	; 1
     1a6:	91 05       	cpc	r25, r1
     1a8:	09 f4       	brne	.+2      	; 0x1ac <moveCar+0x8>
     1aa:	62 c0       	rjmp	.+196    	; 0x270 <moveCar+0xcc>
     1ac:	40 f0       	brcs	.+16     	; 0x1be <moveCar+0x1a>
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	91 05       	cpc	r25, r1
     1b2:	09 f4       	brne	.+2      	; 0x1b6 <moveCar+0x12>
     1b4:	a2 c0       	rjmp	.+324    	; 0x2fa <moveCar+0x156>
     1b6:	03 97       	sbiw	r24, 0x03	; 3
     1b8:	09 f4       	brne	.+2      	; 0x1bc <moveCar+0x18>
     1ba:	fc c0       	rjmp	.+504    	; 0x3b4 <moveCar+0x210>
     1bc:	08 95       	ret
	case 0: 	
			if((car[1] + 1 <= 9) && myMatrix[car[0]][car[1] + 1] == 0){
     1be:	db 01       	movw	r26, r22
     1c0:	12 96       	adiw	r26, 0x02	; 2
     1c2:	2d 91       	ld	r18, X+
     1c4:	3c 91       	ld	r19, X
     1c6:	13 97       	sbiw	r26, 0x03	; 3
     1c8:	c9 01       	movw	r24, r18
     1ca:	01 96       	adiw	r24, 0x01	; 1
     1cc:	8a 30       	cpi	r24, 0x0A	; 10
     1ce:	91 05       	cpc	r25, r1
     1d0:	08 f0       	brcs	.+2      	; 0x1d4 <moveCar+0x30>
     1d2:	4b c1       	rjmp	.+662    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
     1d4:	4d 91       	ld	r20, X+
     1d6:	5c 91       	ld	r21, X
     1d8:	da 01       	movw	r26, r20
     1da:	aa 0f       	add	r26, r26
     1dc:	bb 1f       	adc	r27, r27
     1de:	fa 01       	movw	r30, r20
     1e0:	ee 0f       	add	r30, r30
     1e2:	ff 1f       	adc	r31, r31
     1e4:	ee 0f       	add	r30, r30
     1e6:	ff 1f       	adc	r31, r31
     1e8:	ee 0f       	add	r30, r30
     1ea:	ff 1f       	adc	r31, r31
     1ec:	ea 0f       	add	r30, r26
     1ee:	fb 1f       	adc	r31, r27
     1f0:	e8 0f       	add	r30, r24
     1f2:	f9 1f       	adc	r31, r25
     1f4:	ee 0f       	add	r30, r30
     1f6:	ff 1f       	adc	r31, r31
     1f8:	e5 5c       	subi	r30, 0xC5	; 197
     1fa:	fe 4f       	sbci	r31, 0xFE	; 254
     1fc:	80 81       	ld	r24, Z
     1fe:	91 81       	ldd	r25, Z+1	; 0x01
     200:	89 2b       	or	r24, r25
     202:	09 f0       	breq	.+2      	; 0x206 <moveCar+0x62>
     204:	32 c1       	rjmp	.+612    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
				myMatrix[car[0]][car[1]] = 0;
     206:	fd 01       	movw	r30, r26
     208:	44 0f       	add	r20, r20
     20a:	55 1f       	adc	r21, r21
     20c:	44 0f       	add	r20, r20
     20e:	55 1f       	adc	r21, r21
     210:	44 0f       	add	r20, r20
     212:	55 1f       	adc	r21, r21
     214:	e4 0f       	add	r30, r20
     216:	f5 1f       	adc	r31, r21
     218:	e2 0f       	add	r30, r18
     21a:	f3 1f       	adc	r31, r19
     21c:	ee 0f       	add	r30, r30
     21e:	ff 1f       	adc	r31, r31
     220:	e5 5c       	subi	r30, 0xC5	; 197
     222:	fe 4f       	sbci	r31, 0xFE	; 254
     224:	11 82       	std	Z+1, r1	; 0x01
     226:	10 82       	st	Z, r1
				myMatrix[car[0]][++car[1]] = 1;
     228:	fb 01       	movw	r30, r22
     22a:	20 81       	ld	r18, Z
     22c:	31 81       	ldd	r19, Z+1	; 0x01
     22e:	82 81       	ldd	r24, Z+2	; 0x02
     230:	93 81       	ldd	r25, Z+3	; 0x03
     232:	01 96       	adiw	r24, 0x01	; 1
     234:	93 83       	std	Z+3, r25	; 0x03
     236:	82 83       	std	Z+2, r24	; 0x02
     238:	f9 01       	movw	r30, r18
     23a:	ee 0f       	add	r30, r30
     23c:	ff 1f       	adc	r31, r31
     23e:	22 0f       	add	r18, r18
     240:	33 1f       	adc	r19, r19
     242:	22 0f       	add	r18, r18
     244:	33 1f       	adc	r19, r19
     246:	22 0f       	add	r18, r18
     248:	33 1f       	adc	r19, r19
     24a:	e2 0f       	add	r30, r18
     24c:	f3 1f       	adc	r31, r19
     24e:	e8 0f       	add	r30, r24
     250:	f9 1f       	adc	r31, r25
     252:	ee 0f       	add	r30, r30
     254:	ff 1f       	adc	r31, r31
     256:	e5 5c       	subi	r30, 0xC5	; 197
     258:	fe 4f       	sbci	r31, 0xFE	; 254
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	91 83       	std	Z+1, r25	; 0x01
     260:	80 83       	st	Z, r24
				update();
     262:	0e 94 93 00 	call	0x126	; 0x126 <update>
				vTaskDelay(200);}
     266:	88 ec       	ldi	r24, 0xC8	; 200
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	0e 94 cb 0c 	call	0x1996	; 0x1996 <vTaskDelay>
     26e:	08 95       	ret
    break;
	
	
	case 1:
			if(car[1] >= 1){
     270:	db 01       	movw	r26, r22
     272:	12 96       	adiw	r26, 0x02	; 2
     274:	8d 91       	ld	r24, X+
     276:	9c 91       	ld	r25, X
     278:	13 97       	sbiw	r26, 0x03	; 3
     27a:	00 97       	sbiw	r24, 0x00	; 0
     27c:	09 f4       	brne	.+2      	; 0x280 <moveCar+0xdc>
     27e:	f5 c0       	rjmp	.+490    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
				myMatrix[car[0]][car[1]] = 0;
     280:	2d 91       	ld	r18, X+
     282:	3c 91       	ld	r19, X
     284:	11 97       	sbiw	r26, 0x01	; 1
     286:	f9 01       	movw	r30, r18
     288:	ee 0f       	add	r30, r30
     28a:	ff 1f       	adc	r31, r31
     28c:	22 0f       	add	r18, r18
     28e:	33 1f       	adc	r19, r19
     290:	22 0f       	add	r18, r18
     292:	33 1f       	adc	r19, r19
     294:	22 0f       	add	r18, r18
     296:	33 1f       	adc	r19, r19
     298:	e2 0f       	add	r30, r18
     29a:	f3 1f       	adc	r31, r19
     29c:	e8 0f       	add	r30, r24
     29e:	f9 1f       	adc	r31, r25
     2a0:	ee 0f       	add	r30, r30
     2a2:	ff 1f       	adc	r31, r31
     2a4:	e5 5c       	subi	r30, 0xC5	; 197
     2a6:	fe 4f       	sbci	r31, 0xFE	; 254
     2a8:	11 82       	std	Z+1, r1	; 0x01
     2aa:	10 82       	st	Z, r1
				--car[1];
     2ac:	12 96       	adiw	r26, 0x02	; 2
     2ae:	8d 91       	ld	r24, X+
     2b0:	9c 91       	ld	r25, X
     2b2:	13 97       	sbiw	r26, 0x03	; 3
     2b4:	01 97       	sbiw	r24, 0x01	; 1
     2b6:	13 96       	adiw	r26, 0x03	; 3
     2b8:	9c 93       	st	X, r25
     2ba:	8e 93       	st	-X, r24
     2bc:	12 97       	sbiw	r26, 0x02	; 2
				myMatrix[car[0]][car[1]] = 1;
     2be:	2d 91       	ld	r18, X+
     2c0:	3c 91       	ld	r19, X
     2c2:	f9 01       	movw	r30, r18
     2c4:	ee 0f       	add	r30, r30
     2c6:	ff 1f       	adc	r31, r31
     2c8:	22 0f       	add	r18, r18
     2ca:	33 1f       	adc	r19, r19
     2cc:	22 0f       	add	r18, r18
     2ce:	33 1f       	adc	r19, r19
     2d0:	22 0f       	add	r18, r18
     2d2:	33 1f       	adc	r19, r19
     2d4:	e2 0f       	add	r30, r18
     2d6:	f3 1f       	adc	r31, r19
     2d8:	e8 0f       	add	r30, r24
     2da:	f9 1f       	adc	r31, r25
     2dc:	ee 0f       	add	r30, r30
     2de:	ff 1f       	adc	r31, r31
     2e0:	e5 5c       	subi	r30, 0xC5	; 197
     2e2:	fe 4f       	sbci	r31, 0xFE	; 254
     2e4:	81 e0       	ldi	r24, 0x01	; 1
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	91 83       	std	Z+1, r25	; 0x01
     2ea:	80 83       	st	Z, r24
				update();
     2ec:	0e 94 93 00 	call	0x126	; 0x126 <update>
				vTaskDelay(200);
     2f0:	88 ec       	ldi	r24, 0xC8	; 200
     2f2:	90 e0       	ldi	r25, 0x00	; 0
     2f4:	0e 94 cb 0c 	call	0x1996	; 0x1996 <vTaskDelay>
     2f8:	08 95       	ret
			}
	
	break;
	case 2:
					if((car[0] + 1 <= 13) && myMatrix[car[0] + 1][car[1]] == 0){
     2fa:	fb 01       	movw	r30, r22
     2fc:	20 81       	ld	r18, Z
     2fe:	31 81       	ldd	r19, Z+1	; 0x01
     300:	c9 01       	movw	r24, r18
     302:	01 96       	adiw	r24, 0x01	; 1
     304:	8e 30       	cpi	r24, 0x0E	; 14
     306:	91 05       	cpc	r25, r1
     308:	08 f0       	brcs	.+2      	; 0x30c <moveCar+0x168>
     30a:	af c0       	rjmp	.+350    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
     30c:	42 81       	ldd	r20, Z+2	; 0x02
     30e:	53 81       	ldd	r21, Z+3	; 0x03
     310:	fc 01       	movw	r30, r24
     312:	ee 0f       	add	r30, r30
     314:	ff 1f       	adc	r31, r31
     316:	88 0f       	add	r24, r24
     318:	99 1f       	adc	r25, r25
     31a:	88 0f       	add	r24, r24
     31c:	99 1f       	adc	r25, r25
     31e:	88 0f       	add	r24, r24
     320:	99 1f       	adc	r25, r25
     322:	e8 0f       	add	r30, r24
     324:	f9 1f       	adc	r31, r25
     326:	e4 0f       	add	r30, r20
     328:	f5 1f       	adc	r31, r21
     32a:	ee 0f       	add	r30, r30
     32c:	ff 1f       	adc	r31, r31
     32e:	e5 5c       	subi	r30, 0xC5	; 197
     330:	fe 4f       	sbci	r31, 0xFE	; 254
     332:	80 81       	ld	r24, Z
     334:	91 81       	ldd	r25, Z+1	; 0x01
     336:	89 2b       	or	r24, r25
     338:	09 f0       	breq	.+2      	; 0x33c <moveCar+0x198>
     33a:	97 c0       	rjmp	.+302    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
					myMatrix[car[0]][car[1]] = 0;
     33c:	c9 01       	movw	r24, r18
     33e:	88 0f       	add	r24, r24
     340:	99 1f       	adc	r25, r25
     342:	22 0f       	add	r18, r18
     344:	33 1f       	adc	r19, r19
     346:	22 0f       	add	r18, r18
     348:	33 1f       	adc	r19, r19
     34a:	22 0f       	add	r18, r18
     34c:	33 1f       	adc	r19, r19
     34e:	28 0f       	add	r18, r24
     350:	39 1f       	adc	r19, r25
     352:	f9 01       	movw	r30, r18
     354:	e4 0f       	add	r30, r20
     356:	f5 1f       	adc	r31, r21
     358:	ee 0f       	add	r30, r30
     35a:	ff 1f       	adc	r31, r31
     35c:	e5 5c       	subi	r30, 0xC5	; 197
     35e:	fe 4f       	sbci	r31, 0xFE	; 254
     360:	11 82       	std	Z+1, r1	; 0x01
     362:	10 82       	st	Z, r1
					myMatrix[++car[0]][car[1]] = 1;
     364:	db 01       	movw	r26, r22
     366:	8d 91       	ld	r24, X+
     368:	9c 91       	ld	r25, X
     36a:	11 97       	sbiw	r26, 0x01	; 1
     36c:	01 96       	adiw	r24, 0x01	; 1
     36e:	11 96       	adiw	r26, 0x01	; 1
     370:	9c 93       	st	X, r25
     372:	8e 93       	st	-X, r24
     374:	12 96       	adiw	r26, 0x02	; 2
     376:	ed 91       	ld	r30, X+
     378:	fc 91       	ld	r31, X
     37a:	13 97       	sbiw	r26, 0x03	; 3
     37c:	9c 01       	movw	r18, r24
     37e:	22 0f       	add	r18, r18
     380:	33 1f       	adc	r19, r19
     382:	88 0f       	add	r24, r24
     384:	99 1f       	adc	r25, r25
     386:	88 0f       	add	r24, r24
     388:	99 1f       	adc	r25, r25
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	82 0f       	add	r24, r18
     390:	93 1f       	adc	r25, r19
     392:	e8 0f       	add	r30, r24
     394:	f9 1f       	adc	r31, r25
     396:	ee 0f       	add	r30, r30
     398:	ff 1f       	adc	r31, r31
     39a:	e5 5c       	subi	r30, 0xC5	; 197
     39c:	fe 4f       	sbci	r31, 0xFE	; 254
     39e:	81 e0       	ldi	r24, 0x01	; 1
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	91 83       	std	Z+1, r25	; 0x01
     3a4:	80 83       	st	Z, r24
					update();
     3a6:	0e 94 93 00 	call	0x126	; 0x126 <update>
					vTaskDelay(200);
     3aa:	88 ec       	ldi	r24, 0xC8	; 200
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	0e 94 cb 0c 	call	0x1996	; 0x1996 <vTaskDelay>
     3b2:	08 95       	ret
				}
	
	break;
	case 3:
					if((car[0] >= 1) && myMatrix[car[0] - 1][car[1]] == 0){
     3b4:	fb 01       	movw	r30, r22
     3b6:	20 81       	ld	r18, Z
     3b8:	31 81       	ldd	r19, Z+1	; 0x01
     3ba:	21 15       	cp	r18, r1
     3bc:	31 05       	cpc	r19, r1
     3be:	09 f4       	brne	.+2      	; 0x3c2 <moveCar+0x21e>
     3c0:	54 c0       	rjmp	.+168    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
     3c2:	42 81       	ldd	r20, Z+2	; 0x02
     3c4:	53 81       	ldd	r21, Z+3	; 0x03
     3c6:	c9 01       	movw	r24, r18
     3c8:	01 97       	sbiw	r24, 0x01	; 1
     3ca:	fc 01       	movw	r30, r24
     3cc:	ee 0f       	add	r30, r30
     3ce:	ff 1f       	adc	r31, r31
     3d0:	88 0f       	add	r24, r24
     3d2:	99 1f       	adc	r25, r25
     3d4:	88 0f       	add	r24, r24
     3d6:	99 1f       	adc	r25, r25
     3d8:	88 0f       	add	r24, r24
     3da:	99 1f       	adc	r25, r25
     3dc:	e8 0f       	add	r30, r24
     3de:	f9 1f       	adc	r31, r25
     3e0:	e4 0f       	add	r30, r20
     3e2:	f5 1f       	adc	r31, r21
     3e4:	ee 0f       	add	r30, r30
     3e6:	ff 1f       	adc	r31, r31
     3e8:	e5 5c       	subi	r30, 0xC5	; 197
     3ea:	fe 4f       	sbci	r31, 0xFE	; 254
     3ec:	80 81       	ld	r24, Z
     3ee:	91 81       	ldd	r25, Z+1	; 0x01
     3f0:	89 2b       	or	r24, r25
     3f2:	d9 f5       	brne	.+118    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
					myMatrix[car[0]][car[1]] = 0;
     3f4:	c9 01       	movw	r24, r18
     3f6:	88 0f       	add	r24, r24
     3f8:	99 1f       	adc	r25, r25
     3fa:	22 0f       	add	r18, r18
     3fc:	33 1f       	adc	r19, r19
     3fe:	22 0f       	add	r18, r18
     400:	33 1f       	adc	r19, r19
     402:	22 0f       	add	r18, r18
     404:	33 1f       	adc	r19, r19
     406:	28 0f       	add	r18, r24
     408:	39 1f       	adc	r19, r25
     40a:	f9 01       	movw	r30, r18
     40c:	e4 0f       	add	r30, r20
     40e:	f5 1f       	adc	r31, r21
     410:	ee 0f       	add	r30, r30
     412:	ff 1f       	adc	r31, r31
     414:	e5 5c       	subi	r30, 0xC5	; 197
     416:	fe 4f       	sbci	r31, 0xFE	; 254
     418:	11 82       	std	Z+1, r1	; 0x01
     41a:	10 82       	st	Z, r1
					myMatrix[--car[0]][car[1]] = 1;
     41c:	db 01       	movw	r26, r22
     41e:	8d 91       	ld	r24, X+
     420:	9c 91       	ld	r25, X
     422:	11 97       	sbiw	r26, 0x01	; 1
     424:	01 97       	sbiw	r24, 0x01	; 1
     426:	11 96       	adiw	r26, 0x01	; 1
     428:	9c 93       	st	X, r25
     42a:	8e 93       	st	-X, r24
     42c:	12 96       	adiw	r26, 0x02	; 2
     42e:	ed 91       	ld	r30, X+
     430:	fc 91       	ld	r31, X
     432:	13 97       	sbiw	r26, 0x03	; 3
     434:	9c 01       	movw	r18, r24
     436:	22 0f       	add	r18, r18
     438:	33 1f       	adc	r19, r19
     43a:	88 0f       	add	r24, r24
     43c:	99 1f       	adc	r25, r25
     43e:	88 0f       	add	r24, r24
     440:	99 1f       	adc	r25, r25
     442:	88 0f       	add	r24, r24
     444:	99 1f       	adc	r25, r25
     446:	82 0f       	add	r24, r18
     448:	93 1f       	adc	r25, r19
     44a:	e8 0f       	add	r30, r24
     44c:	f9 1f       	adc	r31, r25
     44e:	ee 0f       	add	r30, r30
     450:	ff 1f       	adc	r31, r31
     452:	e5 5c       	subi	r30, 0xC5	; 197
     454:	fe 4f       	sbci	r31, 0xFE	; 254
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	90 e0       	ldi	r25, 0x00	; 0
     45a:	91 83       	std	Z+1, r25	; 0x01
     45c:	80 83       	st	Z, r24
					update();
     45e:	0e 94 93 00 	call	0x126	; 0x126 <update>
					vTaskDelay(200);
     462:	88 ec       	ldi	r24, 0xC8	; 200
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	0e 94 cb 0c 	call	0x1996	; 0x1996 <vTaskDelay>
     46a:	08 95       	ret

0000046c <another_task>:
static uint16_t frame_buf[14] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static uint16_t myMatrix[14][10];

//-----------------------------------------
void another_task(void *pvParameters)
{
     46c:	cf 93       	push	r28
     46e:	df 93       	push	r29
     470:	00 d0       	rcall	.+0      	; 0x472 <another_task+0x6>
     472:	00 d0       	rcall	.+0      	; 0x474 <another_task+0x8>
     474:	cd b7       	in	r28, 0x3d	; 61
     476:	de b7       	in	r29, 0x3e	; 62
	// The parameters are not used
	( void ) pvParameters;

	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 2 );
     478:	62 e0       	ldi	r22, 0x02	; 2
     47a:	70 e0       	ldi	r23, 0x00	; 0
     47c:	80 e0       	ldi	r24, 0x00	; 0
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <vTaskSetApplicationTaskTag>
     484:	eb e3       	ldi	r30, 0x3B	; 59
     486:	f1 e0       	ldi	r31, 0x01	; 1
     488:	23 e5       	ldi	r18, 0x53	; 83
     48a:	32 e0       	ldi	r19, 0x02	; 2
     48c:	09 c0       	rjmp	.+18     	; 0x4a0 <another_task+0x34>
	BaseType_t result = 0;
	uint8_t byte;
		
		for(int i = 0; i < 14; i++){
			for(int j = 0; j < 10; j++){
				myMatrix[i][j] = 0;
     48e:	11 92       	st	Z+, r1
     490:	11 92       	st	Z+, r1
	
	BaseType_t result = 0;
	uint8_t byte;
		
		for(int i = 0; i < 14; i++){
			for(int j = 0; j < 10; j++){
     492:	e8 17       	cp	r30, r24
     494:	f9 07       	cpc	r31, r25
     496:	d9 f7       	brne	.-10     	; 0x48e <another_task+0x22>
     498:	fc 01       	movw	r30, r24
	#endif
	
	BaseType_t result = 0;
	uint8_t byte;
		
		for(int i = 0; i < 14; i++){
     49a:	28 17       	cp	r18, r24
     49c:	39 07       	cpc	r19, r25
     49e:	19 f0       	breq	.+6      	; 0x4a6 <another_task+0x3a>
     4a0:	cf 01       	movw	r24, r30
     4a2:	44 96       	adiw	r24, 0x14	; 20
     4a4:	f4 cf       	rjmp	.-24     	; 0x48e <another_task+0x22>
			for(int j = 0; j < 10; j++){
				myMatrix[i][j] = 0;
			}
		}
	uint16_t car[2]={0,0};
     4a6:	1a 82       	std	Y+2, r1	; 0x02
     4a8:	19 82       	std	Y+1, r1	; 0x01
     4aa:	1c 82       	std	Y+4, r1	; 0x04
     4ac:	1b 82       	std	Y+3, r1	; 0x03
	myMatrix[0][0] = 1;
     4ae:	81 e0       	ldi	r24, 0x01	; 1
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	90 93 3c 01 	sts	0x013C, r25	; 0x80013c <myMatrix+0x1>
     4b6:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <myMatrix>
	myMatrix[6][6] = 1;
     4ba:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <myMatrix+0x85>
     4be:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <myMatrix+0x84>
	update();
     4c2:	0e 94 93 00 	call	0x126	; 0x126 <update>
	while(1)
	{	
		//result = xQueueReceive(_x_com_received_chars_queue, &byte, 1000L);
			
    if((~PINC & (1<<PINC0)) != 0){
     4c6:	30 99       	sbic	0x06, 0	; 6
     4c8:	07 c0       	rjmp	.+14     	; 0x4d8 <another_task+0x6c>
			moveCar(0, car); //down
     4ca:	be 01       	movw	r22, r28
     4cc:	6f 5f       	subi	r22, 0xFF	; 255
     4ce:	7f 4f       	sbci	r23, 0xFF	; 255
     4d0:	80 e0       	ldi	r24, 0x00	; 0
     4d2:	90 e0       	ldi	r25, 0x00	; 0
     4d4:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <moveCar>
		}

	if((~PINC & (1<<PINC1)) != 0){
     4d8:	31 99       	sbic	0x06, 1	; 6
     4da:	07 c0       	rjmp	.+14     	; 0x4ea <another_task+0x7e>
		moveCar(2, car);// right
     4dc:	be 01       	movw	r22, r28
     4de:	6f 5f       	subi	r22, 0xFF	; 255
     4e0:	7f 4f       	sbci	r23, 0xFF	; 255
     4e2:	82 e0       	ldi	r24, 0x02	; 2
     4e4:	90 e0       	ldi	r25, 0x00	; 0
     4e6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <moveCar>
	}
	if((~PINC & (1<<PINC6)) != 0){
     4ea:	36 99       	sbic	0x06, 6	; 6
     4ec:	07 c0       	rjmp	.+14     	; 0x4fc <another_task+0x90>
		moveCar(1, car); //up
     4ee:	be 01       	movw	r22, r28
     4f0:	6f 5f       	subi	r22, 0xFF	; 255
     4f2:	7f 4f       	sbci	r23, 0xFF	; 255
     4f4:	81 e0       	ldi	r24, 0x01	; 1
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <moveCar>
	}
	if((~PINC & (1<<PINC7)) != 0){
     4fc:	37 99       	sbic	0x06, 7	; 6
     4fe:	e3 cf       	rjmp	.-58     	; 0x4c6 <another_task+0x5a>
		moveCar(3,car); //left
     500:	be 01       	movw	r22, r28
     502:	6f 5f       	subi	r22, 0xFF	; 255
     504:	7f 4f       	sbci	r23, 0xFF	; 255
     506:	83 e0       	ldi	r24, 0x03	; 3
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <moveCar>
     50e:	db cf       	rjmp	.-74     	; 0x4c6 <another_task+0x5a>

00000510 <obstacles_task>:

void obstacles_task(void *pvParameters){

					
					while(1){
						myMatrix[1][9] =  1;
     510:	0b e3       	ldi	r16, 0x3B	; 59
     512:	11 e0       	ldi	r17, 0x01	; 1
     514:	c1 e0       	ldi	r28, 0x01	; 1
     516:	d0 e0       	ldi	r29, 0x00	; 0
     518:	f8 01       	movw	r30, r16
     51a:	d7 a3       	std	Z+39, r29	; 0x27
     51c:	c6 a3       	std	Z+38, r28	; 0x26
						update();
     51e:	0e 94 93 00 	call	0x126	; 0x126 <update>
						vTaskDelay(200);
     522:	88 ec       	ldi	r24, 0xC8	; 200
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	0e 94 cb 0c 	call	0x1996	; 0x1996 <vTaskDelay>
					}
     52a:	f6 cf       	rjmp	.-20     	; 0x518 <obstacles_task+0x8>

0000052c <prepare_shiftregister>:

// Prepare shift register setting SER = 1
void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     52c:	5a 9a       	sbi	0x0b, 2	; 11
     52e:	08 95       	ret

00000530 <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     530:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     532:	5d 98       	cbi	0x0b, 5	; 11
	
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     534:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     536:	5c 98       	cbi	0x0b, 4	; 11
	
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     538:	5a 98       	cbi	0x0b, 2	; 11
     53a:	08 95       	ret

0000053c <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     53c:	80 95       	com	r24
     53e:	82 b9       	out	0x02, r24	; 2
	
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     540:	85 b1       	in	r24, 0x05	; 5
     542:	83 60       	ori	r24, 0x03	; 3
     544:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     546:	85 b1       	in	r24, 0x05	; 5
     548:	93 70       	andi	r25, 0x03	; 3
     54a:	90 95       	com	r25
     54c:	89 23       	and	r24, r25
     54e:	85 b9       	out	0x05, r24	; 5
     550:	08 95       	ret

00000552 <handle_display>:
}

//-----------------------------------------
void handle_display(void)
{
     552:	cf 93       	push	r28
	static uint8_t col = 0;
	
	if (col == 0)
     554:	c0 91 3a 01 	lds	r28, 0x013A	; 0x80013a <__data_end>
     558:	c1 11       	cpse	r28, r1
     55a:	0e c0       	rjmp	.+28     	; 0x578 <handle_display+0x26>
	{
		prepare_shiftregister();
     55c:	0e 94 96 02 	call	0x52c	; 0x52c <prepare_shiftregister>
	}
	
	load_col_value(frame_buf[col]);
     560:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <frame_buf>
     564:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <frame_buf+0x1>
     568:	0e 94 9e 02 	call	0x53c	; 0x53c <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     56c:	0e 94 98 02 	call	0x530	; 0x530 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <__data_end>
     576:	14 c0       	rjmp	.+40     	; 0x5a0 <handle_display+0x4e>
	if (col == 0)
	{
		prepare_shiftregister();
	}
	
	load_col_value(frame_buf[col]);
     578:	ec 2f       	mov	r30, r28
     57a:	f0 e0       	ldi	r31, 0x00	; 0
     57c:	ee 0f       	add	r30, r30
     57e:	ff 1f       	adc	r31, r31
     580:	ed 5a       	subi	r30, 0xAD	; 173
     582:	fd 4f       	sbci	r31, 0xFD	; 253
     584:	80 81       	ld	r24, Z
     586:	91 81       	ldd	r25, Z+1	; 0x01
     588:	0e 94 9e 02 	call	0x53c	; 0x53c <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     58c:	0e 94 98 02 	call	0x530	; 0x530 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     590:	cf 5f       	subi	r28, 0xFF	; 255
	if (col > 13)
     592:	ce 30       	cpi	r28, 0x0E	; 14
     594:	18 f4       	brcc	.+6      	; 0x59c <handle_display+0x4a>
	load_col_value(frame_buf[col]);
	
	clock_shift_register_and_prepare_for_next_col();
	
	// count column up - prepare for next
	col++;
     596:	c0 93 3a 01 	sts	0x013A, r28	; 0x80013a <__data_end>
     59a:	02 c0       	rjmp	.+4      	; 0x5a0 <handle_display+0x4e>
	if (col > 13)
	{
		col = 0;
     59c:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <__data_end>
	}
}
     5a0:	cf 91       	pop	r28
     5a2:	08 95       	ret

000005a4 <vApplicationIdleHook>:

//-----------------------------------------
void vApplicationIdleHook( void )
{
     5a4:	08 95       	ret

000005a6 <main>:

//-----------------------------------------
int main(void)
{
	
	init_board();
     5a6:	0e 94 53 03 	call	0x6a6	; 0x6a6 <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     5aa:	5e 98       	cbi	0x0b, 6	; 11
	
	//Create task to blink gpio
	BaseType_t t1 = xTaskCreate(startup_task, (const char *)"Startup", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY, NULL);
     5ac:	e1 2c       	mov	r14, r1
     5ae:	f1 2c       	mov	r15, r1
     5b0:	00 e0       	ldi	r16, 0x00	; 0
     5b2:	20 e0       	ldi	r18, 0x00	; 0
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	45 e5       	ldi	r20, 0x55	; 85
     5b8:	50 e0       	ldi	r21, 0x00	; 0
     5ba:	6c e2       	ldi	r22, 0x2C	; 44
     5bc:	71 e0       	ldi	r23, 0x01	; 1
     5be:	8d e5       	ldi	r24, 0x5D	; 93
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xTaskCreate>

	// Start the display handler timer
	init_display_timer(handle_display);
     5c6:	89 ea       	ldi	r24, 0xA9	; 169
     5c8:	92 e0       	ldi	r25, 0x02	; 2
     5ca:	0e 94 0f 03 	call	0x61e	; 0x61e <init_display_timer>
	
	sei();
     5ce:	78 94       	sei
	
	//Start the scheduler
	vTaskStartScheduler();
     5d0:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vTaskStartScheduler>
	
	//Should never reach here
	while (1)
	{
	}
     5d4:	ff cf       	rjmp	.-2      	; 0x5d4 <main+0x2e>

000005d6 <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	00 d0       	rcall	.+0      	; 0x5dc <_com_call_back+0x6>
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     5e2:	80 91 bb 02 	lds	r24, 0x02BB	; 0x8002bb <_x_rx_com_queue>
     5e6:	90 91 bc 02 	lds	r25, 0x02BC	; 0x8002bc <_x_rx_com_queue+0x1>
     5ea:	00 97       	sbiw	r24, 0x00	; 0
     5ec:	71 f0       	breq	.+28     	; 0x60a <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     5ee:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     5f0:	20 e0       	ldi	r18, 0x00	; 0
     5f2:	ae 01       	movw	r20, r28
     5f4:	4f 5f       	subi	r20, 0xFF	; 255
     5f6:	5f 4f       	sbci	r21, 0xFF	; 255
     5f8:	be 01       	movw	r22, r28
     5fa:	6e 5f       	subi	r22, 0xFE	; 254
     5fc:	7f 4f       	sbci	r23, 0xFF	; 255
     5fe:	0e 94 ad 09 	call	0x135a	; 0x135a <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     602:	89 81       	ldd	r24, Y+1	; 0x01
     604:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     606:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
		}
	}
}
     60a:	0f 90       	pop	r0
     60c:	0f 90       	pop	r0
     60e:	df 91       	pop	r29
     610:	cf 91       	pop	r28
     612:	08 95       	ret

00000614 <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     614:	90 93 bc 02 	sts	0x02BC, r25	; 0x8002bc <_x_rx_com_queue+0x1>
     618:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <_x_rx_com_queue>
     61c:	08 95       	ret

0000061e <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     61e:	90 93 ba 02 	sts	0x02BA, r25	; 0x8002ba <cb_ptr+0x1>
     622:	80 93 b9 02 	sts	0x02B9, r24	; 0x8002b9 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     626:	8a e0       	ldi	r24, 0x0A	; 10
     628:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     62a:	84 b5       	in	r24, 0x24	; 36
     62c:	82 60       	ori	r24, 0x02	; 2
     62e:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     630:	ee e6       	ldi	r30, 0x6E	; 110
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	82 60       	ori	r24, 0x02	; 2
     638:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     63a:	85 b5       	in	r24, 0x25	; 37
     63c:	85 60       	ori	r24, 0x05	; 5
     63e:	85 bd       	out	0x25, r24	; 37
     640:	08 95       	ret

00000642 <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     642:	1f 92       	push	r1
     644:	0f 92       	push	r0
     646:	0f b6       	in	r0, 0x3f	; 63
     648:	0f 92       	push	r0
     64a:	11 24       	eor	r1, r1
     64c:	2f 93       	push	r18
     64e:	3f 93       	push	r19
     650:	4f 93       	push	r20
     652:	5f 93       	push	r21
     654:	6f 93       	push	r22
     656:	7f 93       	push	r23
     658:	8f 93       	push	r24
     65a:	9f 93       	push	r25
     65c:	af 93       	push	r26
     65e:	bf 93       	push	r27
     660:	ef 93       	push	r30
     662:	ff 93       	push	r31
	if (cb_ptr)
     664:	e0 91 b9 02 	lds	r30, 0x02B9	; 0x8002b9 <cb_ptr>
     668:	f0 91 ba 02 	lds	r31, 0x02BA	; 0x8002ba <cb_ptr+0x1>
     66c:	30 97       	sbiw	r30, 0x00	; 0
     66e:	09 f0       	breq	.+2      	; 0x672 <__vector_16+0x30>
	{
		cb_ptr();
     670:	09 95       	icall
	}
}
     672:	ff 91       	pop	r31
     674:	ef 91       	pop	r30
     676:	bf 91       	pop	r27
     678:	af 91       	pop	r26
     67a:	9f 91       	pop	r25
     67c:	8f 91       	pop	r24
     67e:	7f 91       	pop	r23
     680:	6f 91       	pop	r22
     682:	5f 91       	pop	r21
     684:	4f 91       	pop	r20
     686:	3f 91       	pop	r19
     688:	2f 91       	pop	r18
     68a:	0f 90       	pop	r0
     68c:	0f be       	out	0x3f, r0	; 63
     68e:	0f 90       	pop	r0
     690:	1f 90       	pop	r1
     692:	18 95       	reti

00000694 <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     694:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     696:	bc 01       	movw	r22, r24
     698:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <_com_serial_instance>
     69c:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <_com_serial_instance+0x1>
     6a0:	0e 94 87 06 	call	0xd0e	; 0xd0e <serial_send_bytes>
     6a4:	08 95       	ret

000006a6 <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     6a6:	8f 92       	push	r8
     6a8:	9f 92       	push	r9
     6aa:	af 92       	push	r10
     6ac:	bf 92       	push	r11
     6ae:	cf 92       	push	r12
     6b0:	df 92       	push	r13
     6b2:	ef 92       	push	r14
     6b4:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     6b6:	86 e9       	ldi	r24, 0x96	; 150
     6b8:	92 e0       	ldi	r25, 0x02	; 2
     6ba:	0e 94 ac 03 	call	0x758	; 0x758 <buffer_init>
	buffer_init(&_com_tx_buffer);
     6be:	83 e7       	ldi	r24, 0x73	; 115
     6c0:	92 e0       	ldi	r25, 0x02	; 2
     6c2:	0e 94 ac 03 	call	0x758	; 0x758 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     6c6:	0f 2e       	mov	r0, r31
     6c8:	fb ee       	ldi	r31, 0xEB	; 235
     6ca:	8f 2e       	mov	r8, r31
     6cc:	f2 e0       	ldi	r31, 0x02	; 2
     6ce:	9f 2e       	mov	r9, r31
     6d0:	f0 2d       	mov	r31, r0
     6d2:	0f 2e       	mov	r0, r31
     6d4:	f3 e7       	ldi	r31, 0x73	; 115
     6d6:	af 2e       	mov	r10, r31
     6d8:	f2 e0       	ldi	r31, 0x02	; 2
     6da:	bf 2e       	mov	r11, r31
     6dc:	f0 2d       	mov	r31, r0
     6de:	0f 2e       	mov	r0, r31
     6e0:	f6 e9       	ldi	r31, 0x96	; 150
     6e2:	cf 2e       	mov	r12, r31
     6e4:	f2 e0       	ldi	r31, 0x02	; 2
     6e6:	df 2e       	mov	r13, r31
     6e8:	f0 2d       	mov	r31, r0
     6ea:	e1 2c       	mov	r14, r1
     6ec:	00 e0       	ldi	r16, 0x00	; 0
     6ee:	23 e0       	ldi	r18, 0x03	; 3
     6f0:	40 e0       	ldi	r20, 0x00	; 0
     6f2:	52 ec       	ldi	r21, 0xC2	; 194
     6f4:	61 e0       	ldi	r22, 0x01	; 1
     6f6:	70 e0       	ldi	r23, 0x00	; 0
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	0e 94 0d 06 	call	0xc1a	; 0xc1a <serial_new_instance>
     6fe:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <_com_serial_instance+0x1>
     702:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     706:	88 b1       	in	r24, 0x08	; 8
     708:	83 6c       	ori	r24, 0xC3	; 195
     70a:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     70c:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     70e:	8a b1       	in	r24, 0x0a	; 10
     710:	84 67       	ori	r24, 0x74	; 116
     712:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     714:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     716:	81 b1       	in	r24, 0x01	; 1
     718:	8f ef       	ldi	r24, 0xFF	; 255
     71a:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     71c:	84 b1       	in	r24, 0x04	; 4
     71e:	83 60       	ori	r24, 0x03	; 3
     720:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     722:	84 b1       	in	r24, 0x04	; 4
     724:	8c 63       	ori	r24, 0x3C	; 60
     726:	84 b9       	out	0x04, r24	; 4
}
     728:	0f 91       	pop	r16
     72a:	ef 90       	pop	r14
     72c:	df 90       	pop	r13
     72e:	cf 90       	pop	r12
     730:	bf 90       	pop	r11
     732:	af 90       	pop	r10
     734:	9f 90       	pop	r9
     736:	8f 90       	pop	r8
     738:	08 95       	ret

0000073a <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     73a:	95 b1       	in	r25, 0x05	; 5
     73c:	93 7c       	andi	r25, 0xC3	; 195
     73e:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     740:	25 b1       	in	r18, 0x05	; 5
     742:	34 e0       	ldi	r19, 0x04	; 4
     744:	83 9f       	mul	r24, r19
     746:	c0 01       	movw	r24, r0
     748:	11 24       	eor	r1, r1
     74a:	82 2b       	or	r24, r18
     74c:	85 b9       	out	0x05, r24	; 5
     74e:	08 95       	ret

00000750 <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     750:	85 b1       	in	r24, 0x05	; 5
     752:	83 7c       	andi	r24, 0xC3	; 195
     754:	85 b9       	out	0x05, r24	; 5
     756:	08 95       	ret

00000758 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     758:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     75a:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     75c:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     75e:	12 a2       	std	Z+34, r1	; 0x22
     760:	08 95       	ret

00000762 <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     762:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     764:	82 a1       	ldd	r24, Z+34	; 0x22
     766:	88 23       	and	r24, r24
     768:	d9 f0       	breq	.+54     	; 0x7a0 <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     76a:	81 a1       	ldd	r24, Z+33	; 0x21
     76c:	df 01       	movw	r26, r30
     76e:	a8 0f       	add	r26, r24
     770:	b1 1d       	adc	r27, r1
     772:	8c 91       	ld	r24, X
     774:	db 01       	movw	r26, r22
     776:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     778:	21 a1       	ldd	r18, Z+33	; 0x21
     77a:	30 e0       	ldi	r19, 0x00	; 0
     77c:	2f 5f       	subi	r18, 0xFF	; 255
     77e:	3f 4f       	sbci	r19, 0xFF	; 255
     780:	2f 71       	andi	r18, 0x1F	; 31
     782:	30 78       	andi	r19, 0x80	; 128
     784:	33 23       	and	r19, r19
     786:	34 f4       	brge	.+12     	; 0x794 <buffer_get_item+0x32>
     788:	21 50       	subi	r18, 0x01	; 1
     78a:	31 09       	sbc	r19, r1
     78c:	20 6e       	ori	r18, 0xE0	; 224
     78e:	3f 6f       	ori	r19, 0xFF	; 255
     790:	2f 5f       	subi	r18, 0xFF	; 255
     792:	3f 4f       	sbci	r19, 0xFF	; 255
     794:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     796:	82 a1       	ldd	r24, Z+34	; 0x22
     798:	81 50       	subi	r24, 0x01	; 1
     79a:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     79c:	80 e0       	ldi	r24, 0x00	; 0
     79e:	08 95       	ret
	}
	return BUFFER_EMPTY;
     7a0:	81 e0       	ldi	r24, 0x01	; 1
}
     7a2:	08 95       	ret

000007a4 <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     7a4:	fc 01       	movw	r30, r24
     7a6:	42 a1       	ldd	r20, Z+34	; 0x22
     7a8:	40 32       	cpi	r20, 0x20	; 32
     7aa:	b8 f4       	brcc	.+46     	; 0x7da <buffer_put_item+0x36>
		buffer->storage[buffer->in_i] = item;
     7ac:	20 a1       	ldd	r18, Z+32	; 0x20
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	e2 0f       	add	r30, r18
     7b2:	f3 1f       	adc	r31, r19
     7b4:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     7b6:	2f 5f       	subi	r18, 0xFF	; 255
     7b8:	3f 4f       	sbci	r19, 0xFF	; 255
     7ba:	2f 71       	andi	r18, 0x1F	; 31
     7bc:	30 78       	andi	r19, 0x80	; 128
     7be:	33 23       	and	r19, r19
     7c0:	34 f4       	brge	.+12     	; 0x7ce <buffer_put_item+0x2a>
     7c2:	21 50       	subi	r18, 0x01	; 1
     7c4:	31 09       	sbc	r19, r1
     7c6:	20 6e       	ori	r18, 0xE0	; 224
     7c8:	3f 6f       	ori	r19, 0xFF	; 255
     7ca:	2f 5f       	subi	r18, 0xFF	; 255
     7cc:	3f 4f       	sbci	r19, 0xFF	; 255
     7ce:	fc 01       	movw	r30, r24
     7d0:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     7d2:	4f 5f       	subi	r20, 0xFF	; 255
     7d4:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     7d6:	80 e0       	ldi	r24, 0x00	; 0
     7d8:	08 95       	ret
	}
	return BUFFER_FULL;
     7da:	82 e0       	ldi	r24, 0x02	; 2
}
     7dc:	08 95       	ret

000007de <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     7de:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7e0:	03 96       	adiw	r24, 0x03	; 3
     7e2:	92 83       	std	Z+2, r25	; 0x02
     7e4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     7e6:	2f ef       	ldi	r18, 0xFF	; 255
     7e8:	3f ef       	ldi	r19, 0xFF	; 255
     7ea:	34 83       	std	Z+4, r19	; 0x04
     7ec:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7ee:	96 83       	std	Z+6, r25	; 0x06
     7f0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7f2:	90 87       	std	Z+8, r25	; 0x08
     7f4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     7f6:	10 82       	st	Z, r1
     7f8:	08 95       	ret

000007fa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     7fa:	fc 01       	movw	r30, r24
     7fc:	11 86       	std	Z+9, r1	; 0x09
     7fe:	10 86       	std	Z+8, r1	; 0x08
     800:	08 95       	ret

00000802 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     802:	cf 93       	push	r28
     804:	df 93       	push	r29
     806:	9c 01       	movw	r18, r24
     808:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     80a:	dc 01       	movw	r26, r24
     80c:	11 96       	adiw	r26, 0x01	; 1
     80e:	cd 91       	ld	r28, X+
     810:	dc 91       	ld	r29, X
     812:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     814:	d3 83       	std	Z+3, r29	; 0x03
     816:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     818:	8c 81       	ldd	r24, Y+4	; 0x04
     81a:	9d 81       	ldd	r25, Y+5	; 0x05
     81c:	95 83       	std	Z+5, r25	; 0x05
     81e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     820:	8c 81       	ldd	r24, Y+4	; 0x04
     822:	9d 81       	ldd	r25, Y+5	; 0x05
     824:	dc 01       	movw	r26, r24
     826:	13 96       	adiw	r26, 0x03	; 3
     828:	7c 93       	st	X, r23
     82a:	6e 93       	st	-X, r22
     82c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     82e:	7d 83       	std	Y+5, r23	; 0x05
     830:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     832:	31 87       	std	Z+9, r19	; 0x09
     834:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     836:	f9 01       	movw	r30, r18
     838:	80 81       	ld	r24, Z
     83a:	8f 5f       	subi	r24, 0xFF	; 255
     83c:	80 83       	st	Z, r24
}
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	08 95       	ret

00000844 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     84a:	48 81       	ld	r20, Y
     84c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     84e:	4f 3f       	cpi	r20, 0xFF	; 255
     850:	2f ef       	ldi	r18, 0xFF	; 255
     852:	52 07       	cpc	r21, r18
     854:	21 f4       	brne	.+8      	; 0x85e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     856:	fc 01       	movw	r30, r24
     858:	a7 81       	ldd	r26, Z+7	; 0x07
     85a:	b0 85       	ldd	r27, Z+8	; 0x08
     85c:	0d c0       	rjmp	.+26     	; 0x878 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     85e:	dc 01       	movw	r26, r24
     860:	13 96       	adiw	r26, 0x03	; 3
     862:	01 c0       	rjmp	.+2      	; 0x866 <vListInsert+0x22>
     864:	df 01       	movw	r26, r30
     866:	12 96       	adiw	r26, 0x02	; 2
     868:	ed 91       	ld	r30, X+
     86a:	fc 91       	ld	r31, X
     86c:	13 97       	sbiw	r26, 0x03	; 3
     86e:	20 81       	ld	r18, Z
     870:	31 81       	ldd	r19, Z+1	; 0x01
     872:	42 17       	cp	r20, r18
     874:	53 07       	cpc	r21, r19
     876:	b0 f7       	brcc	.-20     	; 0x864 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     878:	12 96       	adiw	r26, 0x02	; 2
     87a:	ed 91       	ld	r30, X+
     87c:	fc 91       	ld	r31, X
     87e:	13 97       	sbiw	r26, 0x03	; 3
     880:	fb 83       	std	Y+3, r31	; 0x03
     882:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     884:	d5 83       	std	Z+5, r29	; 0x05
     886:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     888:	bd 83       	std	Y+5, r27	; 0x05
     88a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     88c:	13 96       	adiw	r26, 0x03	; 3
     88e:	dc 93       	st	X, r29
     890:	ce 93       	st	-X, r28
     892:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     894:	99 87       	std	Y+9, r25	; 0x09
     896:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     898:	fc 01       	movw	r30, r24
     89a:	20 81       	ld	r18, Z
     89c:	2f 5f       	subi	r18, 0xFF	; 255
     89e:	20 83       	st	Z, r18
}
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8a6:	cf 93       	push	r28
     8a8:	df 93       	push	r29
     8aa:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8ac:	a0 85       	ldd	r26, Z+8	; 0x08
     8ae:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8b0:	c2 81       	ldd	r28, Z+2	; 0x02
     8b2:	d3 81       	ldd	r29, Z+3	; 0x03
     8b4:	84 81       	ldd	r24, Z+4	; 0x04
     8b6:	95 81       	ldd	r25, Z+5	; 0x05
     8b8:	9d 83       	std	Y+5, r25	; 0x05
     8ba:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8bc:	c4 81       	ldd	r28, Z+4	; 0x04
     8be:	d5 81       	ldd	r29, Z+5	; 0x05
     8c0:	82 81       	ldd	r24, Z+2	; 0x02
     8c2:	93 81       	ldd	r25, Z+3	; 0x03
     8c4:	9b 83       	std	Y+3, r25	; 0x03
     8c6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8c8:	11 96       	adiw	r26, 0x01	; 1
     8ca:	cd 91       	ld	r28, X+
     8cc:	dc 91       	ld	r29, X
     8ce:	12 97       	sbiw	r26, 0x02	; 2
     8d0:	ce 17       	cp	r28, r30
     8d2:	df 07       	cpc	r29, r31
     8d4:	31 f4       	brne	.+12     	; 0x8e2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     8d6:	8c 81       	ldd	r24, Y+4	; 0x04
     8d8:	9d 81       	ldd	r25, Y+5	; 0x05
     8da:	12 96       	adiw	r26, 0x02	; 2
     8dc:	9c 93       	st	X, r25
     8de:	8e 93       	st	-X, r24
     8e0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     8e2:	11 86       	std	Z+9, r1	; 0x09
     8e4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     8e6:	8c 91       	ld	r24, X
     8e8:	81 50       	subi	r24, 0x01	; 1
     8ea:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	08 95       	ret

000008f2 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     8f2:	31 e1       	ldi	r19, 0x11	; 17
     8f4:	fc 01       	movw	r30, r24
     8f6:	30 83       	st	Z, r19
     8f8:	31 97       	sbiw	r30, 0x01	; 1
     8fa:	22 e2       	ldi	r18, 0x22	; 34
     8fc:	20 83       	st	Z, r18
     8fe:	31 97       	sbiw	r30, 0x01	; 1
     900:	a3 e3       	ldi	r26, 0x33	; 51
     902:	a0 83       	st	Z, r26
     904:	31 97       	sbiw	r30, 0x01	; 1
     906:	60 83       	st	Z, r22
     908:	31 97       	sbiw	r30, 0x01	; 1
     90a:	70 83       	st	Z, r23
     90c:	31 97       	sbiw	r30, 0x01	; 1
     90e:	10 82       	st	Z, r1
     910:	31 97       	sbiw	r30, 0x01	; 1
     912:	60 e8       	ldi	r22, 0x80	; 128
     914:	60 83       	st	Z, r22
     916:	31 97       	sbiw	r30, 0x01	; 1
     918:	10 82       	st	Z, r1
     91a:	31 97       	sbiw	r30, 0x01	; 1
     91c:	62 e0       	ldi	r22, 0x02	; 2
     91e:	60 83       	st	Z, r22
     920:	31 97       	sbiw	r30, 0x01	; 1
     922:	63 e0       	ldi	r22, 0x03	; 3
     924:	60 83       	st	Z, r22
     926:	31 97       	sbiw	r30, 0x01	; 1
     928:	64 e0       	ldi	r22, 0x04	; 4
     92a:	60 83       	st	Z, r22
     92c:	31 97       	sbiw	r30, 0x01	; 1
     92e:	65 e0       	ldi	r22, 0x05	; 5
     930:	60 83       	st	Z, r22
     932:	31 97       	sbiw	r30, 0x01	; 1
     934:	66 e0       	ldi	r22, 0x06	; 6
     936:	60 83       	st	Z, r22
     938:	31 97       	sbiw	r30, 0x01	; 1
     93a:	67 e0       	ldi	r22, 0x07	; 7
     93c:	60 83       	st	Z, r22
     93e:	31 97       	sbiw	r30, 0x01	; 1
     940:	68 e0       	ldi	r22, 0x08	; 8
     942:	60 83       	st	Z, r22
     944:	31 97       	sbiw	r30, 0x01	; 1
     946:	69 e0       	ldi	r22, 0x09	; 9
     948:	60 83       	st	Z, r22
     94a:	31 97       	sbiw	r30, 0x01	; 1
     94c:	60 e1       	ldi	r22, 0x10	; 16
     94e:	60 83       	st	Z, r22
     950:	31 97       	sbiw	r30, 0x01	; 1
     952:	30 83       	st	Z, r19
     954:	31 97       	sbiw	r30, 0x01	; 1
     956:	32 e1       	ldi	r19, 0x12	; 18
     958:	30 83       	st	Z, r19
     95a:	31 97       	sbiw	r30, 0x01	; 1
     95c:	33 e1       	ldi	r19, 0x13	; 19
     95e:	30 83       	st	Z, r19
     960:	31 97       	sbiw	r30, 0x01	; 1
     962:	34 e1       	ldi	r19, 0x14	; 20
     964:	30 83       	st	Z, r19
     966:	31 97       	sbiw	r30, 0x01	; 1
     968:	35 e1       	ldi	r19, 0x15	; 21
     96a:	30 83       	st	Z, r19
     96c:	31 97       	sbiw	r30, 0x01	; 1
     96e:	36 e1       	ldi	r19, 0x16	; 22
     970:	30 83       	st	Z, r19
     972:	31 97       	sbiw	r30, 0x01	; 1
     974:	37 e1       	ldi	r19, 0x17	; 23
     976:	30 83       	st	Z, r19
     978:	31 97       	sbiw	r30, 0x01	; 1
     97a:	38 e1       	ldi	r19, 0x18	; 24
     97c:	30 83       	st	Z, r19
     97e:	31 97       	sbiw	r30, 0x01	; 1
     980:	39 e1       	ldi	r19, 0x19	; 25
     982:	30 83       	st	Z, r19
     984:	31 97       	sbiw	r30, 0x01	; 1
     986:	30 e2       	ldi	r19, 0x20	; 32
     988:	30 83       	st	Z, r19
     98a:	31 97       	sbiw	r30, 0x01	; 1
     98c:	31 e2       	ldi	r19, 0x21	; 33
     98e:	30 83       	st	Z, r19
     990:	31 97       	sbiw	r30, 0x01	; 1
     992:	20 83       	st	Z, r18
     994:	31 97       	sbiw	r30, 0x01	; 1
     996:	23 e2       	ldi	r18, 0x23	; 35
     998:	20 83       	st	Z, r18
     99a:	31 97       	sbiw	r30, 0x01	; 1
     99c:	40 83       	st	Z, r20
     99e:	31 97       	sbiw	r30, 0x01	; 1
     9a0:	50 83       	st	Z, r21
     9a2:	31 97       	sbiw	r30, 0x01	; 1
     9a4:	26 e2       	ldi	r18, 0x26	; 38
     9a6:	20 83       	st	Z, r18
     9a8:	31 97       	sbiw	r30, 0x01	; 1
     9aa:	27 e2       	ldi	r18, 0x27	; 39
     9ac:	20 83       	st	Z, r18
     9ae:	31 97       	sbiw	r30, 0x01	; 1
     9b0:	28 e2       	ldi	r18, 0x28	; 40
     9b2:	20 83       	st	Z, r18
     9b4:	31 97       	sbiw	r30, 0x01	; 1
     9b6:	29 e2       	ldi	r18, 0x29	; 41
     9b8:	20 83       	st	Z, r18
     9ba:	31 97       	sbiw	r30, 0x01	; 1
     9bc:	20 e3       	ldi	r18, 0x30	; 48
     9be:	20 83       	st	Z, r18
     9c0:	31 97       	sbiw	r30, 0x01	; 1
     9c2:	21 e3       	ldi	r18, 0x31	; 49
     9c4:	20 83       	st	Z, r18
     9c6:	86 97       	sbiw	r24, 0x26	; 38
     9c8:	08 95       	ret

000009ca <xPortStartScheduler>:
     9ca:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     9ce:	85 ee       	ldi	r24, 0xE5	; 229
     9d0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     9d4:	8b e0       	ldi	r24, 0x0B	; 11
     9d6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     9da:	ef e6       	ldi	r30, 0x6F	; 111
     9dc:	f0 e0       	ldi	r31, 0x00	; 0
     9de:	80 81       	ld	r24, Z
     9e0:	82 60       	ori	r24, 0x02	; 2
     9e2:	80 83       	st	Z, r24
     9e4:	a0 91 0a 07 	lds	r26, 0x070A	; 0x80070a <pxCurrentTCB>
     9e8:	b0 91 0b 07 	lds	r27, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
     9ec:	cd 91       	ld	r28, X+
     9ee:	cd bf       	out	0x3d, r28	; 61
     9f0:	dd 91       	ld	r29, X+
     9f2:	de bf       	out	0x3e, r29	; 62
     9f4:	ff 91       	pop	r31
     9f6:	ef 91       	pop	r30
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	bf 91       	pop	r27
     9fe:	af 91       	pop	r26
     a00:	9f 91       	pop	r25
     a02:	8f 91       	pop	r24
     a04:	7f 91       	pop	r23
     a06:	6f 91       	pop	r22
     a08:	5f 91       	pop	r21
     a0a:	4f 91       	pop	r20
     a0c:	3f 91       	pop	r19
     a0e:	2f 91       	pop	r18
     a10:	1f 91       	pop	r17
     a12:	0f 91       	pop	r16
     a14:	ff 90       	pop	r15
     a16:	ef 90       	pop	r14
     a18:	df 90       	pop	r13
     a1a:	cf 90       	pop	r12
     a1c:	bf 90       	pop	r11
     a1e:	af 90       	pop	r10
     a20:	9f 90       	pop	r9
     a22:	8f 90       	pop	r8
     a24:	7f 90       	pop	r7
     a26:	6f 90       	pop	r6
     a28:	5f 90       	pop	r5
     a2a:	4f 90       	pop	r4
     a2c:	3f 90       	pop	r3
     a2e:	2f 90       	pop	r2
     a30:	1f 90       	pop	r1
     a32:	0f 90       	pop	r0
     a34:	0f be       	out	0x3f, r0	; 63
     a36:	0f 90       	pop	r0
     a38:	08 95       	ret
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	08 95       	ret

00000a3e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a3e:	0f 92       	push	r0
     a40:	0f b6       	in	r0, 0x3f	; 63
     a42:	f8 94       	cli
     a44:	0f 92       	push	r0
     a46:	1f 92       	push	r1
     a48:	11 24       	eor	r1, r1
     a4a:	2f 92       	push	r2
     a4c:	3f 92       	push	r3
     a4e:	4f 92       	push	r4
     a50:	5f 92       	push	r5
     a52:	6f 92       	push	r6
     a54:	7f 92       	push	r7
     a56:	8f 92       	push	r8
     a58:	9f 92       	push	r9
     a5a:	af 92       	push	r10
     a5c:	bf 92       	push	r11
     a5e:	cf 92       	push	r12
     a60:	df 92       	push	r13
     a62:	ef 92       	push	r14
     a64:	ff 92       	push	r15
     a66:	0f 93       	push	r16
     a68:	1f 93       	push	r17
     a6a:	2f 93       	push	r18
     a6c:	3f 93       	push	r19
     a6e:	4f 93       	push	r20
     a70:	5f 93       	push	r21
     a72:	6f 93       	push	r22
     a74:	7f 93       	push	r23
     a76:	8f 93       	push	r24
     a78:	9f 93       	push	r25
     a7a:	af 93       	push	r26
     a7c:	bf 93       	push	r27
     a7e:	cf 93       	push	r28
     a80:	df 93       	push	r29
     a82:	ef 93       	push	r30
     a84:	ff 93       	push	r31
     a86:	a0 91 0a 07 	lds	r26, 0x070A	; 0x80070a <pxCurrentTCB>
     a8a:	b0 91 0b 07 	lds	r27, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
     a8e:	0d b6       	in	r0, 0x3d	; 61
     a90:	0d 92       	st	X+, r0
     a92:	0e b6       	in	r0, 0x3e	; 62
     a94:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a96:	0e 94 2d 0d 	call	0x1a5a	; 0x1a5a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a9a:	a0 91 0a 07 	lds	r26, 0x070A	; 0x80070a <pxCurrentTCB>
     a9e:	b0 91 0b 07 	lds	r27, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
     aa2:	cd 91       	ld	r28, X+
     aa4:	cd bf       	out	0x3d, r28	; 61
     aa6:	dd 91       	ld	r29, X+
     aa8:	de bf       	out	0x3e, r29	; 62
     aaa:	ff 91       	pop	r31
     aac:	ef 91       	pop	r30
     aae:	df 91       	pop	r29
     ab0:	cf 91       	pop	r28
     ab2:	bf 91       	pop	r27
     ab4:	af 91       	pop	r26
     ab6:	9f 91       	pop	r25
     ab8:	8f 91       	pop	r24
     aba:	7f 91       	pop	r23
     abc:	6f 91       	pop	r22
     abe:	5f 91       	pop	r21
     ac0:	4f 91       	pop	r20
     ac2:	3f 91       	pop	r19
     ac4:	2f 91       	pop	r18
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	ff 90       	pop	r15
     acc:	ef 90       	pop	r14
     ace:	df 90       	pop	r13
     ad0:	cf 90       	pop	r12
     ad2:	bf 90       	pop	r11
     ad4:	af 90       	pop	r10
     ad6:	9f 90       	pop	r9
     ad8:	8f 90       	pop	r8
     ada:	7f 90       	pop	r7
     adc:	6f 90       	pop	r6
     ade:	5f 90       	pop	r5
     ae0:	4f 90       	pop	r4
     ae2:	3f 90       	pop	r3
     ae4:	2f 90       	pop	r2
     ae6:	1f 90       	pop	r1
     ae8:	0f 90       	pop	r0
     aea:	0f be       	out	0x3f, r0	; 63
     aec:	0f 90       	pop	r0

	asm volatile ( "ret" );
     aee:	08 95       	ret

00000af0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     af0:	0f 92       	push	r0
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	f8 94       	cli
     af6:	0f 92       	push	r0
     af8:	1f 92       	push	r1
     afa:	11 24       	eor	r1, r1
     afc:	2f 92       	push	r2
     afe:	3f 92       	push	r3
     b00:	4f 92       	push	r4
     b02:	5f 92       	push	r5
     b04:	6f 92       	push	r6
     b06:	7f 92       	push	r7
     b08:	8f 92       	push	r8
     b0a:	9f 92       	push	r9
     b0c:	af 92       	push	r10
     b0e:	bf 92       	push	r11
     b10:	cf 92       	push	r12
     b12:	df 92       	push	r13
     b14:	ef 92       	push	r14
     b16:	ff 92       	push	r15
     b18:	0f 93       	push	r16
     b1a:	1f 93       	push	r17
     b1c:	2f 93       	push	r18
     b1e:	3f 93       	push	r19
     b20:	4f 93       	push	r20
     b22:	5f 93       	push	r21
     b24:	6f 93       	push	r22
     b26:	7f 93       	push	r23
     b28:	8f 93       	push	r24
     b2a:	9f 93       	push	r25
     b2c:	af 93       	push	r26
     b2e:	bf 93       	push	r27
     b30:	cf 93       	push	r28
     b32:	df 93       	push	r29
     b34:	ef 93       	push	r30
     b36:	ff 93       	push	r31
     b38:	a0 91 0a 07 	lds	r26, 0x070A	; 0x80070a <pxCurrentTCB>
     b3c:	b0 91 0b 07 	lds	r27, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
     b40:	0d b6       	in	r0, 0x3d	; 61
     b42:	0d 92       	st	X+, r0
     b44:	0e b6       	in	r0, 0x3e	; 62
     b46:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     b48:	0e 94 91 0b 	call	0x1722	; 0x1722 <xTaskIncrementTick>
     b4c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     b4e:	0e 94 2d 0d 	call	0x1a5a	; 0x1a5a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     b52:	a0 91 0a 07 	lds	r26, 0x070A	; 0x80070a <pxCurrentTCB>
     b56:	b0 91 0b 07 	lds	r27, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
     b5a:	cd 91       	ld	r28, X+
     b5c:	cd bf       	out	0x3d, r28	; 61
     b5e:	dd 91       	ld	r29, X+
     b60:	de bf       	out	0x3e, r29	; 62
     b62:	ff 91       	pop	r31
     b64:	ef 91       	pop	r30
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	bf 91       	pop	r27
     b6c:	af 91       	pop	r26
     b6e:	9f 91       	pop	r25
     b70:	8f 91       	pop	r24
     b72:	7f 91       	pop	r23
     b74:	6f 91       	pop	r22
     b76:	5f 91       	pop	r21
     b78:	4f 91       	pop	r20
     b7a:	3f 91       	pop	r19
     b7c:	2f 91       	pop	r18
     b7e:	1f 91       	pop	r17
     b80:	0f 91       	pop	r16
     b82:	ff 90       	pop	r15
     b84:	ef 90       	pop	r14
     b86:	df 90       	pop	r13
     b88:	cf 90       	pop	r12
     b8a:	bf 90       	pop	r11
     b8c:	af 90       	pop	r10
     b8e:	9f 90       	pop	r9
     b90:	8f 90       	pop	r8
     b92:	7f 90       	pop	r7
     b94:	6f 90       	pop	r6
     b96:	5f 90       	pop	r5
     b98:	4f 90       	pop	r4
     b9a:	3f 90       	pop	r3
     b9c:	2f 90       	pop	r2
     b9e:	1f 90       	pop	r1
     ba0:	0f 90       	pop	r0
     ba2:	0f be       	out	0x3f, r0	; 63
     ba4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ba6:	08 95       	ret

00000ba8 <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     ba8:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vPortYieldFromTick>
		asm volatile ( "reti" );
     bac:	18 95       	reti

00000bae <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     bae:	cf 93       	push	r28
     bb0:	df 93       	push	r29
     bb2:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     bb4:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     bb8:	80 91 bf 02 	lds	r24, 0x02BF	; 0x8002bf <pucAlignedHeap.1965>
     bbc:	90 91 c0 02 	lds	r25, 0x02C0	; 0x8002c0 <pucAlignedHeap.1965+0x1>
     bc0:	89 2b       	or	r24, r25
     bc2:	31 f4       	brne	.+12     	; 0xbd0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     bc4:	84 ec       	ldi	r24, 0xC4	; 196
     bc6:	92 e0       	ldi	r25, 0x02	; 2
     bc8:	90 93 c0 02 	sts	0x02C0, r25	; 0x8002c0 <pucAlignedHeap.1965+0x1>
     bcc:	80 93 bf 02 	sts	0x02BF, r24	; 0x8002bf <pucAlignedHeap.1965>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     bd0:	20 91 c1 02 	lds	r18, 0x02C1	; 0x8002c1 <xNextFreeByte>
     bd4:	30 91 c2 02 	lds	r19, 0x02C2	; 0x8002c2 <xNextFreeByte+0x1>
     bd8:	ce 01       	movw	r24, r28
     bda:	82 0f       	add	r24, r18
     bdc:	93 1f       	adc	r25, r19
     bde:	87 3e       	cpi	r24, 0xE7	; 231
     be0:	43 e0       	ldi	r20, 0x03	; 3
     be2:	94 07       	cpc	r25, r20
     be4:	70 f4       	brcc	.+28     	; 0xc02 <pvPortMalloc+0x54>
     be6:	28 17       	cp	r18, r24
     be8:	39 07       	cpc	r19, r25
     bea:	70 f4       	brcc	.+28     	; 0xc08 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     bec:	c0 91 bf 02 	lds	r28, 0x02BF	; 0x8002bf <pucAlignedHeap.1965>
     bf0:	d0 91 c0 02 	lds	r29, 0x02C0	; 0x8002c0 <pucAlignedHeap.1965+0x1>
     bf4:	c2 0f       	add	r28, r18
     bf6:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     bf8:	90 93 c2 02 	sts	0x02C2, r25	; 0x8002c2 <xNextFreeByte+0x1>
     bfc:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <xNextFreeByte>
     c00:	05 c0       	rjmp	.+10     	; 0xc0c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     c02:	c0 e0       	ldi	r28, 0x00	; 0
     c04:	d0 e0       	ldi	r29, 0x00	; 0
     c06:	02 c0       	rjmp	.+4      	; 0xc0c <pvPortMalloc+0x5e>
     c08:	c0 e0       	ldi	r28, 0x00	; 0
     c0a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c0c:	0e 94 4c 0c 	call	0x1898	; 0x1898 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c10:	ce 01       	movw	r24, r28
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	08 95       	ret

00000c18 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c18:	08 95       	ret

00000c1a <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
     c1a:	4f 92       	push	r4
     c1c:	5f 92       	push	r5
     c1e:	6f 92       	push	r6
     c20:	7f 92       	push	r7
     c22:	8f 92       	push	r8
     c24:	9f 92       	push	r9
     c26:	af 92       	push	r10
     c28:	bf 92       	push	r11
     c2a:	cf 92       	push	r12
     c2c:	df 92       	push	r13
     c2e:	ff 92       	push	r15
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17
     c34:	cf 93       	push	r28
     c36:	df 93       	push	r29
     c38:	cd b7       	in	r28, 0x3d	; 61
     c3a:	de b7       	in	r29, 0x3e	; 62
     c3c:	f8 2e       	mov	r15, r24
     c3e:	2a 01       	movw	r4, r20
     c40:	3b 01       	movw	r6, r22
     c42:	88 e0       	ldi	r24, 0x08	; 8
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <malloc>
     c4a:	8c 01       	movw	r16, r24
     c4c:	8f 2d       	mov	r24, r15
     c4e:	90 e0       	ldi	r25, 0x00	; 0
     c50:	88 0f       	add	r24, r24
     c52:	99 1f       	adc	r25, r25
     c54:	fc 01       	movw	r30, r24
     c56:	e5 55       	subi	r30, 0x55	; 85
     c58:	f9 4f       	sbci	r31, 0xF9	; 249
     c5a:	11 83       	std	Z+1, r17	; 0x01
     c5c:	00 83       	st	Z, r16
     c5e:	fc 01       	movw	r30, r24
     c60:	ea 5f       	subi	r30, 0xFA	; 250
     c62:	fe 4f       	sbci	r31, 0xFE	; 254
     c64:	80 81       	ld	r24, Z
     c66:	91 81       	ldd	r25, Z+1	; 0x01
     c68:	d8 01       	movw	r26, r16
     c6a:	11 96       	adiw	r26, 0x01	; 1
     c6c:	9c 93       	st	X, r25
     c6e:	8e 93       	st	-X, r24
     c70:	13 96       	adiw	r26, 0x03	; 3
     c72:	bc 92       	st	X, r11
     c74:	ae 92       	st	-X, r10
     c76:	12 97       	sbiw	r26, 0x02	; 2
     c78:	15 96       	adiw	r26, 0x05	; 5
     c7a:	dc 92       	st	X, r13
     c7c:	ce 92       	st	-X, r12
     c7e:	14 97       	sbiw	r26, 0x04	; 4
     c80:	17 96       	adiw	r26, 0x07	; 7
     c82:	9c 92       	st	X, r9
     c84:	8e 92       	st	-X, r8
     c86:	16 97       	sbiw	r26, 0x06	; 6
     c88:	ff b6       	in	r15, 0x3f	; 63
     c8a:	f8 94       	cli
     c8c:	ed 91       	ld	r30, X+
     c8e:	fc 91       	ld	r31, X
     c90:	11 97       	sbiw	r26, 0x01	; 1
     c92:	36 97       	sbiw	r30, 0x06	; 6
     c94:	80 81       	ld	r24, Z
     c96:	82 60       	ori	r24, 0x02	; 2
     c98:	80 83       	st	Z, r24
     c9a:	cd 90       	ld	r12, X+
     c9c:	dc 90       	ld	r13, X
     c9e:	d3 01       	movw	r26, r6
     ca0:	c2 01       	movw	r24, r4
     ca2:	88 0f       	add	r24, r24
     ca4:	99 1f       	adc	r25, r25
     ca6:	aa 1f       	adc	r26, r26
     ca8:	bb 1f       	adc	r27, r27
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	aa 1f       	adc	r26, r26
     cb0:	bb 1f       	adc	r27, r27
     cb2:	9c 01       	movw	r18, r24
     cb4:	ad 01       	movw	r20, r26
     cb6:	22 0f       	add	r18, r18
     cb8:	33 1f       	adc	r19, r19
     cba:	44 1f       	adc	r20, r20
     cbc:	55 1f       	adc	r21, r21
     cbe:	60 e0       	ldi	r22, 0x00	; 0
     cc0:	70 e0       	ldi	r23, 0x00	; 0
     cc2:	81 ee       	ldi	r24, 0xE1	; 225
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <__udivmodsi4>
     cca:	21 50       	subi	r18, 0x01	; 1
     ccc:	f6 01       	movw	r30, r12
     cce:	32 97       	sbiw	r30, 0x02	; 2
     cd0:	20 83       	st	Z, r18
     cd2:	d8 01       	movw	r26, r16
     cd4:	ed 91       	ld	r30, X+
     cd6:	fc 91       	ld	r31, X
     cd8:	11 97       	sbiw	r26, 0x01	; 1
     cda:	35 97       	sbiw	r30, 0x05	; 5
     cdc:	88 e9       	ldi	r24, 0x98	; 152
     cde:	80 83       	st	Z, r24
     ce0:	ed 91       	ld	r30, X+
     ce2:	fc 91       	ld	r31, X
     ce4:	34 97       	sbiw	r30, 0x04	; 4
     ce6:	86 e0       	ldi	r24, 0x06	; 6
     ce8:	80 83       	st	Z, r24
     cea:	ff be       	out	0x3f, r15	; 63
     cec:	c8 01       	movw	r24, r16
     cee:	df 91       	pop	r29
     cf0:	cf 91       	pop	r28
     cf2:	1f 91       	pop	r17
     cf4:	0f 91       	pop	r16
     cf6:	ff 90       	pop	r15
     cf8:	df 90       	pop	r13
     cfa:	cf 90       	pop	r12
     cfc:	bf 90       	pop	r11
     cfe:	af 90       	pop	r10
     d00:	9f 90       	pop	r9
     d02:	8f 90       	pop	r8
     d04:	7f 90       	pop	r7
     d06:	6f 90       	pop	r6
     d08:	5f 90       	pop	r5
     d0a:	4f 90       	pop	r4
     d0c:	08 95       	ret

00000d0e <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
     d0e:	ef 92       	push	r14
     d10:	ff 92       	push	r15
     d12:	0f 93       	push	r16
     d14:	1f 93       	push	r17
     d16:	cf 93       	push	r28
     d18:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     d1a:	fc 01       	movw	r30, r24
     d1c:	a2 81       	ldd	r26, Z+2	; 0x02
     d1e:	b3 81       	ldd	r27, Z+3	; 0x03
     d20:	10 97       	sbiw	r26, 0x00	; 0
     d22:	79 f0       	breq	.+30     	; 0xd42 <serial_send_bytes+0x34>
     d24:	e4 2f       	mov	r30, r20
     d26:	f0 e0       	ldi	r31, 0x00	; 0
     d28:	92 96       	adiw	r26, 0x22	; 34
     d2a:	5c 91       	ld	r21, X
     d2c:	20 e2       	ldi	r18, 0x20	; 32
     d2e:	30 e0       	ldi	r19, 0x00	; 0
     d30:	25 1b       	sub	r18, r21
     d32:	31 09       	sbc	r19, r1
     d34:	2e 17       	cp	r18, r30
     d36:	3f 07       	cpc	r19, r31
     d38:	1c f1       	brlt	.+70     	; 0xd80 <serial_send_bytes+0x72>
     d3a:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     d3c:	41 11       	cpse	r20, r1
     d3e:	04 c0       	rjmp	.+8      	; 0xd48 <serial_send_bytes+0x3a>
     d40:	16 c0       	rjmp	.+44     	; 0xd6e <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     d42:	42 30       	cpi	r20, 0x02	; 2
     d44:	f8 f4       	brcc	.+62     	; 0xd84 <serial_send_bytes+0x76>
     d46:	f9 cf       	rjmp	.-14     	; 0xd3a <serial_send_bytes+0x2c>
     d48:	eb 01       	movw	r28, r22
     d4a:	41 50       	subi	r20, 0x01	; 1
     d4c:	04 2f       	mov	r16, r20
     d4e:	10 e0       	ldi	r17, 0x00	; 0
     d50:	0f 5f       	subi	r16, 0xFF	; 255
     d52:	1f 4f       	sbci	r17, 0xFF	; 255
     d54:	06 0f       	add	r16, r22
     d56:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
     d58:	69 91       	ld	r22, Y+
     d5a:	d7 01       	movw	r26, r14
     d5c:	12 96       	adiw	r26, 0x02	; 2
     d5e:	8d 91       	ld	r24, X+
     d60:	9c 91       	ld	r25, X
     d62:	13 97       	sbiw	r26, 0x03	; 3
     d64:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     d68:	c0 17       	cp	r28, r16
     d6a:	d1 07       	cpc	r29, r17
     d6c:	a9 f7       	brne	.-22     	; 0xd58 <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
     d6e:	d7 01       	movw	r26, r14
     d70:	ed 91       	ld	r30, X+
     d72:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
     d74:	35 97       	sbiw	r30, 0x05	; 5
     d76:	80 81       	ld	r24, Z
     d78:	80 62       	ori	r24, 0x20	; 32
     d7a:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
     d7c:	80 e0       	ldi	r24, 0x00	; 0
     d7e:	03 c0       	rjmp	.+6      	; 0xd86 <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
     d80:	82 e0       	ldi	r24, 0x02	; 2
     d82:	01 c0       	rjmp	.+2      	; 0xd86 <serial_send_bytes+0x78>
     d84:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
     d8a:	1f 91       	pop	r17
     d8c:	0f 91       	pop	r16
     d8e:	ff 90       	pop	r15
     d90:	ef 90       	pop	r14
     d92:	08 95       	ret

00000d94 <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
     d94:	1f 92       	push	r1
     d96:	0f 92       	push	r0
     d98:	0f b6       	in	r0, 0x3f	; 63
     d9a:	0f 92       	push	r0
     d9c:	11 24       	eor	r1, r1
     d9e:	2f 93       	push	r18
     da0:	3f 93       	push	r19
     da2:	4f 93       	push	r20
     da4:	5f 93       	push	r21
     da6:	6f 93       	push	r22
     da8:	7f 93       	push	r23
     daa:	8f 93       	push	r24
     dac:	9f 93       	push	r25
     dae:	af 93       	push	r26
     db0:	bf 93       	push	r27
     db2:	cf 93       	push	r28
     db4:	ef 93       	push	r30
     db6:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     db8:	e0 91 ab 06 	lds	r30, 0x06AB	; 0x8006ab <_ser_handle>
     dbc:	f0 91 ac 06 	lds	r31, 0x06AC	; 0x8006ac <_ser_handle+0x1>
     dc0:	30 97       	sbiw	r30, 0x00	; 0
     dc2:	a1 f0       	breq	.+40     	; 0xdec <__vector_20+0x58>
		item = UDR0;
     dc4:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
     dc8:	6c 2f       	mov	r22, r28
     dca:	84 81       	ldd	r24, Z+4	; 0x04
     dcc:	95 81       	ldd	r25, Z+5	; 0x05
     dce:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
     dd2:	80 91 ab 06 	lds	r24, 0x06AB	; 0x8006ab <_ser_handle>
     dd6:	90 91 ac 06 	lds	r25, 0x06AC	; 0x8006ac <_ser_handle+0x1>
     dda:	dc 01       	movw	r26, r24
     ddc:	16 96       	adiw	r26, 0x06	; 6
     dde:	ed 91       	ld	r30, X+
     de0:	fc 91       	ld	r31, X
     de2:	17 97       	sbiw	r26, 0x07	; 7
     de4:	30 97       	sbiw	r30, 0x00	; 0
     de6:	11 f0       	breq	.+4      	; 0xdec <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
     de8:	6c 2f       	mov	r22, r28
     dea:	09 95       	icall
		}
	}
}
     dec:	ff 91       	pop	r31
     dee:	ef 91       	pop	r30
     df0:	cf 91       	pop	r28
     df2:	bf 91       	pop	r27
     df4:	af 91       	pop	r26
     df6:	9f 91       	pop	r25
     df8:	8f 91       	pop	r24
     dfa:	7f 91       	pop	r23
     dfc:	6f 91       	pop	r22
     dfe:	5f 91       	pop	r21
     e00:	4f 91       	pop	r20
     e02:	3f 91       	pop	r19
     e04:	2f 91       	pop	r18
     e06:	0f 90       	pop	r0
     e08:	0f be       	out	0x3f, r0	; 63
     e0a:	0f 90       	pop	r0
     e0c:	1f 90       	pop	r1
     e0e:	18 95       	reti

00000e10 <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
     e10:	1f 92       	push	r1
     e12:	0f 92       	push	r0
     e14:	0f b6       	in	r0, 0x3f	; 63
     e16:	0f 92       	push	r0
     e18:	11 24       	eor	r1, r1
     e1a:	2f 93       	push	r18
     e1c:	3f 93       	push	r19
     e1e:	4f 93       	push	r20
     e20:	5f 93       	push	r21
     e22:	6f 93       	push	r22
     e24:	7f 93       	push	r23
     e26:	8f 93       	push	r24
     e28:	9f 93       	push	r25
     e2a:	af 93       	push	r26
     e2c:	bf 93       	push	r27
     e2e:	ef 93       	push	r30
     e30:	ff 93       	push	r31
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	1f 92       	push	r1
     e38:	cd b7       	in	r28, 0x3d	; 61
     e3a:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     e3c:	e0 91 ab 06 	lds	r30, 0x06AB	; 0x8006ab <_ser_handle>
     e40:	f0 91 ac 06 	lds	r31, 0x06AC	; 0x8006ac <_ser_handle+0x1>
     e44:	30 97       	sbiw	r30, 0x00	; 0
     e46:	99 f0       	breq	.+38     	; 0xe6e <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
     e48:	be 01       	movw	r22, r28
     e4a:	6f 5f       	subi	r22, 0xFF	; 255
     e4c:	7f 4f       	sbci	r23, 0xFF	; 255
     e4e:	82 81       	ldd	r24, Z+2	; 0x02
     e50:	93 81       	ldd	r25, Z+3	; 0x03
     e52:	0e 94 b1 03 	call	0x762	; 0x762 <buffer_get_item>
     e56:	81 11       	cpse	r24, r1
     e58:	04 c0       	rjmp	.+8      	; 0xe62 <__vector_21+0x52>
			UDR0 = item;
     e5a:	89 81       	ldd	r24, Y+1	; 0x01
     e5c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     e60:	0b c0       	rjmp	.+22     	; 0xe78 <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
     e62:	e1 ec       	ldi	r30, 0xC1	; 193
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	8f 7d       	andi	r24, 0xDF	; 223
     e6a:	80 83       	st	Z, r24
     e6c:	05 c0       	rjmp	.+10     	; 0xe78 <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
     e6e:	e1 ec       	ldi	r30, 0xC1	; 193
     e70:	f0 e0       	ldi	r31, 0x00	; 0
     e72:	80 81       	ld	r24, Z
     e74:	8f 7d       	andi	r24, 0xDF	; 223
     e76:	80 83       	st	Z, r24
	}
}
     e78:	0f 90       	pop	r0
     e7a:	df 91       	pop	r29
     e7c:	cf 91       	pop	r28
     e7e:	ff 91       	pop	r31
     e80:	ef 91       	pop	r30
     e82:	bf 91       	pop	r27
     e84:	af 91       	pop	r26
     e86:	9f 91       	pop	r25
     e88:	8f 91       	pop	r24
     e8a:	7f 91       	pop	r23
     e8c:	6f 91       	pop	r22
     e8e:	5f 91       	pop	r21
     e90:	4f 91       	pop	r20
     e92:	3f 91       	pop	r19
     e94:	2f 91       	pop	r18
     e96:	0f 90       	pop	r0
     e98:	0f be       	out	0x3f, r0	; 63
     e9a:	0f 90       	pop	r0
     e9c:	1f 90       	pop	r1
     e9e:	18 95       	reti

00000ea0 <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
     ea0:	1f 92       	push	r1
     ea2:	0f 92       	push	r0
     ea4:	0f b6       	in	r0, 0x3f	; 63
     ea6:	0f 92       	push	r0
     ea8:	11 24       	eor	r1, r1
     eaa:	2f 93       	push	r18
     eac:	3f 93       	push	r19
     eae:	4f 93       	push	r20
     eb0:	5f 93       	push	r21
     eb2:	6f 93       	push	r22
     eb4:	7f 93       	push	r23
     eb6:	8f 93       	push	r24
     eb8:	9f 93       	push	r25
     eba:	af 93       	push	r26
     ebc:	bf 93       	push	r27
     ebe:	cf 93       	push	r28
     ec0:	ef 93       	push	r30
     ec2:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     ec4:	e0 91 ad 06 	lds	r30, 0x06AD	; 0x8006ad <_ser_handle+0x2>
     ec8:	f0 91 ae 06 	lds	r31, 0x06AE	; 0x8006ae <_ser_handle+0x3>
     ecc:	30 97       	sbiw	r30, 0x00	; 0
     ece:	a1 f0       	breq	.+40     	; 0xef8 <__vector_28+0x58>
		item = UDR1;
     ed0:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
     ed4:	6c 2f       	mov	r22, r28
     ed6:	84 81       	ldd	r24, Z+4	; 0x04
     ed8:	95 81       	ldd	r25, Z+5	; 0x05
     eda:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
     ede:	80 91 ad 06 	lds	r24, 0x06AD	; 0x8006ad <_ser_handle+0x2>
     ee2:	90 91 ae 06 	lds	r25, 0x06AE	; 0x8006ae <_ser_handle+0x3>
     ee6:	dc 01       	movw	r26, r24
     ee8:	16 96       	adiw	r26, 0x06	; 6
     eea:	ed 91       	ld	r30, X+
     eec:	fc 91       	ld	r31, X
     eee:	17 97       	sbiw	r26, 0x07	; 7
     ef0:	30 97       	sbiw	r30, 0x00	; 0
     ef2:	11 f0       	breq	.+4      	; 0xef8 <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
     ef4:	6c 2f       	mov	r22, r28
     ef6:	09 95       	icall
		}
	}
}
     ef8:	ff 91       	pop	r31
     efa:	ef 91       	pop	r30
     efc:	cf 91       	pop	r28
     efe:	bf 91       	pop	r27
     f00:	af 91       	pop	r26
     f02:	9f 91       	pop	r25
     f04:	8f 91       	pop	r24
     f06:	7f 91       	pop	r23
     f08:	6f 91       	pop	r22
     f0a:	5f 91       	pop	r21
     f0c:	4f 91       	pop	r20
     f0e:	3f 91       	pop	r19
     f10:	2f 91       	pop	r18
     f12:	0f 90       	pop	r0
     f14:	0f be       	out	0x3f, r0	; 63
     f16:	0f 90       	pop	r0
     f18:	1f 90       	pop	r1
     f1a:	18 95       	reti

00000f1c <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
     f1c:	1f 92       	push	r1
     f1e:	0f 92       	push	r0
     f20:	0f b6       	in	r0, 0x3f	; 63
     f22:	0f 92       	push	r0
     f24:	11 24       	eor	r1, r1
     f26:	2f 93       	push	r18
     f28:	3f 93       	push	r19
     f2a:	4f 93       	push	r20
     f2c:	5f 93       	push	r21
     f2e:	6f 93       	push	r22
     f30:	7f 93       	push	r23
     f32:	8f 93       	push	r24
     f34:	9f 93       	push	r25
     f36:	af 93       	push	r26
     f38:	bf 93       	push	r27
     f3a:	ef 93       	push	r30
     f3c:	ff 93       	push	r31
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
     f42:	1f 92       	push	r1
     f44:	cd b7       	in	r28, 0x3d	; 61
     f46:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     f48:	e0 91 ad 06 	lds	r30, 0x06AD	; 0x8006ad <_ser_handle+0x2>
     f4c:	f0 91 ae 06 	lds	r31, 0x06AE	; 0x8006ae <_ser_handle+0x3>
     f50:	30 97       	sbiw	r30, 0x00	; 0
     f52:	99 f0       	breq	.+38     	; 0xf7a <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
     f54:	be 01       	movw	r22, r28
     f56:	6f 5f       	subi	r22, 0xFF	; 255
     f58:	7f 4f       	sbci	r23, 0xFF	; 255
     f5a:	82 81       	ldd	r24, Z+2	; 0x02
     f5c:	93 81       	ldd	r25, Z+3	; 0x03
     f5e:	0e 94 b1 03 	call	0x762	; 0x762 <buffer_get_item>
     f62:	81 11       	cpse	r24, r1
     f64:	04 c0       	rjmp	.+8      	; 0xf6e <__vector_29+0x52>
			UDR1 = item;
     f66:	89 81       	ldd	r24, Y+1	; 0x01
     f68:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     f6c:	0b c0       	rjmp	.+22     	; 0xf84 <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
     f6e:	e9 ec       	ldi	r30, 0xC9	; 201
     f70:	f0 e0       	ldi	r31, 0x00	; 0
     f72:	80 81       	ld	r24, Z
     f74:	8f 7d       	andi	r24, 0xDF	; 223
     f76:	80 83       	st	Z, r24
     f78:	05 c0       	rjmp	.+10     	; 0xf84 <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
     f7a:	e9 ec       	ldi	r30, 0xC9	; 201
     f7c:	f0 e0       	ldi	r31, 0x00	; 0
     f7e:	80 81       	ld	r24, Z
     f80:	8f 7d       	andi	r24, 0xDF	; 223
     f82:	80 83       	st	Z, r24
	}
}
     f84:	0f 90       	pop	r0
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	ff 91       	pop	r31
     f8c:	ef 91       	pop	r30
     f8e:	bf 91       	pop	r27
     f90:	af 91       	pop	r26
     f92:	9f 91       	pop	r25
     f94:	8f 91       	pop	r24
     f96:	7f 91       	pop	r23
     f98:	6f 91       	pop	r22
     f9a:	5f 91       	pop	r21
     f9c:	4f 91       	pop	r20
     f9e:	3f 91       	pop	r19
     fa0:	2f 91       	pop	r18
     fa2:	0f 90       	pop	r0
     fa4:	0f be       	out	0x3f, r0	; 63
     fa6:	0f 90       	pop	r0
     fa8:	1f 90       	pop	r1
     faa:	18 95       	reti

00000fac <prvCopyDataToQueue>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     fac:	0f 93       	push	r16
     fae:	1f 93       	push	r17
     fb0:	cf 93       	push	r28
     fb2:	df 93       	push	r29
     fb4:	ec 01       	movw	r28, r24
     fb6:	04 2f       	mov	r16, r20
     fb8:	1a 8d       	ldd	r17, Y+26	; 0x1a
     fba:	8c 8d       	ldd	r24, Y+28	; 0x1c
     fbc:	81 11       	cpse	r24, r1
     fbe:	0c c0       	rjmp	.+24     	; 0xfd8 <prvCopyDataToQueue+0x2c>
     fc0:	88 81       	ld	r24, Y
     fc2:	99 81       	ldd	r25, Y+1	; 0x01
     fc4:	89 2b       	or	r24, r25
     fc6:	09 f0       	breq	.+2      	; 0xfca <prvCopyDataToQueue+0x1e>
     fc8:	44 c0       	rjmp	.+136    	; 0x1052 <prvCopyDataToQueue+0xa6>
     fca:	8a 81       	ldd	r24, Y+2	; 0x02
     fcc:	9b 81       	ldd	r25, Y+3	; 0x03
     fce:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskPriorityDisinherit>
     fd2:	1b 82       	std	Y+3, r1	; 0x03
     fd4:	1a 82       	std	Y+2, r1	; 0x02
     fd6:	44 c0       	rjmp	.+136    	; 0x1060 <prvCopyDataToQueue+0xb4>
     fd8:	41 11       	cpse	r20, r1
     fda:	18 c0       	rjmp	.+48     	; 0x100c <prvCopyDataToQueue+0x60>
     fdc:	48 2f       	mov	r20, r24
     fde:	50 e0       	ldi	r21, 0x00	; 0
     fe0:	8c 81       	ldd	r24, Y+4	; 0x04
     fe2:	9d 81       	ldd	r25, Y+5	; 0x05
     fe4:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <memcpy>
     fe8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fea:	8c 81       	ldd	r24, Y+4	; 0x04
     fec:	9d 81       	ldd	r25, Y+5	; 0x05
     fee:	82 0f       	add	r24, r18
     ff0:	91 1d       	adc	r25, r1
     ff2:	9d 83       	std	Y+5, r25	; 0x05
     ff4:	8c 83       	std	Y+4, r24	; 0x04
     ff6:	2a 81       	ldd	r18, Y+2	; 0x02
     ff8:	3b 81       	ldd	r19, Y+3	; 0x03
     ffa:	82 17       	cp	r24, r18
     ffc:	93 07       	cpc	r25, r19
     ffe:	58 f1       	brcs	.+86     	; 0x1056 <prvCopyDataToQueue+0xaa>
    1000:	88 81       	ld	r24, Y
    1002:	99 81       	ldd	r25, Y+1	; 0x01
    1004:	9d 83       	std	Y+5, r25	; 0x05
    1006:	8c 83       	std	Y+4, r24	; 0x04
    1008:	80 e0       	ldi	r24, 0x00	; 0
    100a:	2a c0       	rjmp	.+84     	; 0x1060 <prvCopyDataToQueue+0xb4>
    100c:	48 2f       	mov	r20, r24
    100e:	50 e0       	ldi	r21, 0x00	; 0
    1010:	8e 81       	ldd	r24, Y+6	; 0x06
    1012:	9f 81       	ldd	r25, Y+7	; 0x07
    1014:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <memcpy>
    1018:	8c 8d       	ldd	r24, Y+28	; 0x1c
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	91 95       	neg	r25
    101e:	81 95       	neg	r24
    1020:	91 09       	sbc	r25, r1
    1022:	2e 81       	ldd	r18, Y+6	; 0x06
    1024:	3f 81       	ldd	r19, Y+7	; 0x07
    1026:	28 0f       	add	r18, r24
    1028:	39 1f       	adc	r19, r25
    102a:	3f 83       	std	Y+7, r19	; 0x07
    102c:	2e 83       	std	Y+6, r18	; 0x06
    102e:	48 81       	ld	r20, Y
    1030:	59 81       	ldd	r21, Y+1	; 0x01
    1032:	24 17       	cp	r18, r20
    1034:	35 07       	cpc	r19, r21
    1036:	30 f4       	brcc	.+12     	; 0x1044 <prvCopyDataToQueue+0x98>
    1038:	2a 81       	ldd	r18, Y+2	; 0x02
    103a:	3b 81       	ldd	r19, Y+3	; 0x03
    103c:	82 0f       	add	r24, r18
    103e:	93 1f       	adc	r25, r19
    1040:	9f 83       	std	Y+7, r25	; 0x07
    1042:	8e 83       	std	Y+6, r24	; 0x06
    1044:	02 30       	cpi	r16, 0x02	; 2
    1046:	49 f4       	brne	.+18     	; 0x105a <prvCopyDataToQueue+0xae>
    1048:	11 23       	and	r17, r17
    104a:	49 f0       	breq	.+18     	; 0x105e <prvCopyDataToQueue+0xb2>
    104c:	11 50       	subi	r17, 0x01	; 1
    104e:	80 e0       	ldi	r24, 0x00	; 0
    1050:	07 c0       	rjmp	.+14     	; 0x1060 <prvCopyDataToQueue+0xb4>
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	05 c0       	rjmp	.+10     	; 0x1060 <prvCopyDataToQueue+0xb4>
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	03 c0       	rjmp	.+6      	; 0x1060 <prvCopyDataToQueue+0xb4>
    105a:	80 e0       	ldi	r24, 0x00	; 0
    105c:	01 c0       	rjmp	.+2      	; 0x1060 <prvCopyDataToQueue+0xb4>
    105e:	80 e0       	ldi	r24, 0x00	; 0
    1060:	1f 5f       	subi	r17, 0xFF	; 255
    1062:	1a 8f       	std	Y+26, r17	; 0x1a
    1064:	df 91       	pop	r29
    1066:	cf 91       	pop	r28
    1068:	1f 91       	pop	r17
    106a:	0f 91       	pop	r16
    106c:	08 95       	ret

0000106e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    106e:	ef 92       	push	r14
    1070:	ff 92       	push	r15
    1072:	0f 93       	push	r16
    1074:	1f 93       	push	r17
    1076:	cf 93       	push	r28
    1078:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    107a:	0f b6       	in	r0, 0x3f	; 63
    107c:	f8 94       	cli
    107e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1080:	fc 01       	movw	r30, r24
    1082:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1084:	1c 16       	cp	r1, r28
    1086:	ac f4       	brge	.+42     	; 0x10b2 <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1088:	81 89       	ldd	r24, Z+17	; 0x11
    108a:	81 11       	cpse	r24, r1
    108c:	06 c0       	rjmp	.+12     	; 0x109a <prvUnlockQueue+0x2c>
    108e:	11 c0       	rjmp	.+34     	; 0x10b2 <prvUnlockQueue+0x44>
    1090:	f8 01       	movw	r30, r16
    1092:	91 89       	ldd	r25, Z+17	; 0x11
    1094:	91 11       	cpse	r25, r1
    1096:	05 c0       	rjmp	.+10     	; 0x10a2 <prvUnlockQueue+0x34>
    1098:	0c c0       	rjmp	.+24     	; 0x10b2 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    109a:	78 01       	movw	r14, r16
    109c:	f1 e1       	ldi	r31, 0x11	; 17
    109e:	ef 0e       	add	r14, r31
    10a0:	f1 1c       	adc	r15, r1
    10a2:	c7 01       	movw	r24, r14
    10a4:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <xTaskRemoveFromEventList>
    10a8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    10aa:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <vTaskMissedYield>
    10ae:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    10b0:	79 f7       	brne	.-34     	; 0x1090 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    10b2:	8f ef       	ldi	r24, 0xFF	; 255
    10b4:	f8 01       	movw	r30, r16
    10b6:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    10b8:	0f 90       	pop	r0
    10ba:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    10bc:	0f b6       	in	r0, 0x3f	; 63
    10be:	f8 94       	cli
    10c0:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    10c2:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    10c4:	1c 16       	cp	r1, r28
    10c6:	ac f4       	brge	.+42     	; 0x10f2 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10c8:	80 85       	ldd	r24, Z+8	; 0x08
    10ca:	81 11       	cpse	r24, r1
    10cc:	06 c0       	rjmp	.+12     	; 0x10da <prvUnlockQueue+0x6c>
    10ce:	11 c0       	rjmp	.+34     	; 0x10f2 <prvUnlockQueue+0x84>
    10d0:	f8 01       	movw	r30, r16
    10d2:	90 85       	ldd	r25, Z+8	; 0x08
    10d4:	91 11       	cpse	r25, r1
    10d6:	05 c0       	rjmp	.+10     	; 0x10e2 <prvUnlockQueue+0x74>
    10d8:	0c c0       	rjmp	.+24     	; 0x10f2 <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10da:	78 01       	movw	r14, r16
    10dc:	f8 e0       	ldi	r31, 0x08	; 8
    10de:	ef 0e       	add	r14, r31
    10e0:	f1 1c       	adc	r15, r1
    10e2:	c7 01       	movw	r24, r14
    10e4:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <xTaskRemoveFromEventList>
    10e8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    10ea:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <vTaskMissedYield>
    10ee:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    10f0:	79 f7       	brne	.-34     	; 0x10d0 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    10f2:	8f ef       	ldi	r24, 0xFF	; 255
    10f4:	f8 01       	movw	r30, r16
    10f6:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    10f8:	0f 90       	pop	r0
    10fa:	0f be       	out	0x3f, r0	; 63
}
    10fc:	cf 91       	pop	r28
    10fe:	1f 91       	pop	r17
    1100:	0f 91       	pop	r16
    1102:	ff 90       	pop	r15
    1104:	ef 90       	pop	r14
    1106:	08 95       	ret

00001108 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1108:	cf 93       	push	r28
    110a:	df 93       	push	r29
    110c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    110e:	0f b6       	in	r0, 0x3f	; 63
    1110:	f8 94       	cli
    1112:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1114:	48 81       	ld	r20, Y
    1116:	59 81       	ldd	r21, Y+1	; 0x01
    1118:	2c 8d       	ldd	r18, Y+28	; 0x1c
    111a:	30 e0       	ldi	r19, 0x00	; 0
    111c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    111e:	72 9f       	mul	r23, r18
    1120:	c0 01       	movw	r24, r0
    1122:	73 9f       	mul	r23, r19
    1124:	90 0d       	add	r25, r0
    1126:	11 24       	eor	r1, r1
    1128:	fa 01       	movw	r30, r20
    112a:	e8 0f       	add	r30, r24
    112c:	f9 1f       	adc	r31, r25
    112e:	fb 83       	std	Y+3, r31	; 0x03
    1130:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1132:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1134:	5d 83       	std	Y+5, r21	; 0x05
    1136:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1138:	82 1b       	sub	r24, r18
    113a:	93 0b       	sbc	r25, r19
    113c:	84 0f       	add	r24, r20
    113e:	95 1f       	adc	r25, r21
    1140:	9f 83       	std	Y+7, r25	; 0x07
    1142:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1144:	8f ef       	ldi	r24, 0xFF	; 255
    1146:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1148:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    114a:	61 11       	cpse	r22, r1
    114c:	0c c0       	rjmp	.+24     	; 0x1166 <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    114e:	88 85       	ldd	r24, Y+8	; 0x08
    1150:	88 23       	and	r24, r24
    1152:	89 f0       	breq	.+34     	; 0x1176 <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1154:	ce 01       	movw	r24, r28
    1156:	08 96       	adiw	r24, 0x08	; 8
    1158:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <xTaskRemoveFromEventList>
    115c:	88 23       	and	r24, r24
    115e:	59 f0       	breq	.+22     	; 0x1176 <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1160:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
    1164:	08 c0       	rjmp	.+16     	; 0x1176 <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1166:	ce 01       	movw	r24, r28
    1168:	08 96       	adiw	r24, 0x08	; 8
    116a:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    116e:	ce 01       	movw	r24, r28
    1170:	41 96       	adiw	r24, 0x11	; 17
    1172:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1176:	0f 90       	pop	r0
    1178:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	08 95       	ret

00001182 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1182:	ff 92       	push	r15
    1184:	0f 93       	push	r16
    1186:	1f 93       	push	r17
    1188:	cf 93       	push	r28
    118a:	df 93       	push	r29
    118c:	08 2f       	mov	r16, r24
    118e:	16 2f       	mov	r17, r22
    1190:	f4 2e       	mov	r15, r20
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1192:	66 23       	and	r22, r22
    1194:	c9 f0       	breq	.+50     	; 0x11c8 <xQueueGenericCreate+0x46>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1196:	86 9f       	mul	r24, r22
    1198:	c0 01       	movw	r24, r0
    119a:	11 24       	eor	r1, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    119c:	81 96       	adiw	r24, 0x21	; 33
    119e:	0e 94 d7 05 	call	0xbae	; 0xbae <pvPortMalloc>
    11a2:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    11a4:	00 97       	sbiw	r24, 0x00	; 0
    11a6:	49 f4       	brne	.+18     	; 0x11ba <xQueueGenericCreate+0x38>
    11a8:	16 c0       	rjmp	.+44     	; 0x11d6 <xQueueGenericCreate+0x54>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    11aa:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    11ac:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    11ae:	61 e0       	ldi	r22, 0x01	; 1
    11b0:	ce 01       	movw	r24, r28
    11b2:	0e 94 84 08 	call	0x1108	; 0x1108 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    11b6:	f8 a2       	std	Y+32, r15	; 0x20
    11b8:	0e c0       	rjmp	.+28     	; 0x11d6 <xQueueGenericCreate+0x54>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    11ba:	81 96       	adiw	r24, 0x21	; 33
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    11bc:	99 83       	std	Y+1, r25	; 0x01
    11be:	88 83       	st	Y, r24
    11c0:	f4 cf       	rjmp	.-24     	; 0x11aa <xQueueGenericCreate+0x28>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    11c2:	d9 83       	std	Y+1, r29	; 0x01
    11c4:	c8 83       	st	Y, r28
    11c6:	f1 cf       	rjmp	.-30     	; 0x11aa <xQueueGenericCreate+0x28>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    11c8:	81 e2       	ldi	r24, 0x21	; 33
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	0e 94 d7 05 	call	0xbae	; 0xbae <pvPortMalloc>
    11d0:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    11d2:	89 2b       	or	r24, r25
    11d4:	b1 f7       	brne	.-20     	; 0x11c2 <xQueueGenericCreate+0x40>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    11d6:	ce 01       	movw	r24, r28
    11d8:	df 91       	pop	r29
    11da:	cf 91       	pop	r28
    11dc:	1f 91       	pop	r17
    11de:	0f 91       	pop	r16
    11e0:	ff 90       	pop	r15
    11e2:	08 95       	ret

000011e4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    11e4:	9f 92       	push	r9
    11e6:	af 92       	push	r10
    11e8:	bf 92       	push	r11
    11ea:	cf 92       	push	r12
    11ec:	df 92       	push	r13
    11ee:	ef 92       	push	r14
    11f0:	ff 92       	push	r15
    11f2:	0f 93       	push	r16
    11f4:	1f 93       	push	r17
    11f6:	cf 93       	push	r28
    11f8:	df 93       	push	r29
    11fa:	00 d0       	rcall	.+0      	; 0x11fc <xQueueGenericSend+0x18>
    11fc:	00 d0       	rcall	.+0      	; 0x11fe <xQueueGenericSend+0x1a>
    11fe:	1f 92       	push	r1
    1200:	cd b7       	in	r28, 0x3d	; 61
    1202:	de b7       	in	r29, 0x3e	; 62
    1204:	8c 01       	movw	r16, r24
    1206:	6b 01       	movw	r12, r22
    1208:	5d 83       	std	Y+5, r21	; 0x05
    120a:	4c 83       	std	Y+4, r20	; 0x04
    120c:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    120e:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1210:	99 24       	eor	r9, r9
    1212:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1214:	7c 01       	movw	r14, r24
    1216:	88 e0       	ldi	r24, 0x08	; 8
    1218:	e8 0e       	add	r14, r24
    121a:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    121c:	0f b6       	in	r0, 0x3f	; 63
    121e:	f8 94       	cli
    1220:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1222:	f8 01       	movw	r30, r16
    1224:	32 8d       	ldd	r19, Z+26	; 0x1a
    1226:	93 8d       	ldd	r25, Z+27	; 0x1b
    1228:	39 17       	cp	r19, r25
    122a:	18 f0       	brcs	.+6      	; 0x1232 <xQueueGenericSend+0x4e>
    122c:	f2 e0       	ldi	r31, 0x02	; 2
    122e:	af 12       	cpse	r10, r31
    1230:	19 c0       	rjmp	.+50     	; 0x1264 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1232:	4a 2d       	mov	r20, r10
    1234:	b6 01       	movw	r22, r12
    1236:	c8 01       	movw	r24, r16
    1238:	0e 94 d6 07 	call	0xfac	; 0xfac <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    123c:	f8 01       	movw	r30, r16
    123e:	91 89       	ldd	r25, Z+17	; 0x11
    1240:	99 23       	and	r25, r25
    1242:	49 f0       	breq	.+18     	; 0x1256 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1244:	c8 01       	movw	r24, r16
    1246:	41 96       	adiw	r24, 0x11	; 17
    1248:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <xTaskRemoveFromEventList>
    124c:	88 23       	and	r24, r24
    124e:	31 f0       	breq	.+12     	; 0x125c <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1250:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
    1254:	03 c0       	rjmp	.+6      	; 0x125c <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1256:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1258:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    125c:	0f 90       	pop	r0
    125e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1260:	81 e0       	ldi	r24, 0x01	; 1
    1262:	50 c0       	rjmp	.+160    	; 0x1304 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1264:	ec 81       	ldd	r30, Y+4	; 0x04
    1266:	fd 81       	ldd	r31, Y+5	; 0x05
    1268:	ef 2b       	or	r30, r31
    126a:	21 f4       	brne	.+8      	; 0x1274 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    126c:	0f 90       	pop	r0
    126e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1270:	80 e0       	ldi	r24, 0x00	; 0
    1272:	48 c0       	rjmp	.+144    	; 0x1304 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
    1274:	b1 10       	cpse	r11, r1
    1276:	05 c0       	rjmp	.+10     	; 0x1282 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1278:	ce 01       	movw	r24, r28
    127a:	01 96       	adiw	r24, 0x01	; 1
    127c:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1280:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1282:	0f 90       	pop	r0
    1284:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1286:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    128a:	0f b6       	in	r0, 0x3f	; 63
    128c:	f8 94       	cli
    128e:	0f 92       	push	r0
    1290:	f8 01       	movw	r30, r16
    1292:	85 8d       	ldd	r24, Z+29	; 0x1d
    1294:	8f 3f       	cpi	r24, 0xFF	; 255
    1296:	09 f4       	brne	.+2      	; 0x129a <xQueueGenericSend+0xb6>
    1298:	15 8e       	std	Z+29, r1	; 0x1d
    129a:	f8 01       	movw	r30, r16
    129c:	86 8d       	ldd	r24, Z+30	; 0x1e
    129e:	8f 3f       	cpi	r24, 0xFF	; 255
    12a0:	09 f4       	brne	.+2      	; 0x12a4 <xQueueGenericSend+0xc0>
    12a2:	16 8e       	std	Z+30, r1	; 0x1e
    12a4:	0f 90       	pop	r0
    12a6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12a8:	be 01       	movw	r22, r28
    12aa:	6c 5f       	subi	r22, 0xFC	; 252
    12ac:	7f 4f       	sbci	r23, 0xFF	; 255
    12ae:	ce 01       	movw	r24, r28
    12b0:	01 96       	adiw	r24, 0x01	; 1
    12b2:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xTaskCheckForTimeOut>
    12b6:	81 11       	cpse	r24, r1
    12b8:	1f c0       	rjmp	.+62     	; 0x12f8 <xQueueGenericSend+0x114>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    12c0:	f8 01       	movw	r30, r16
    12c2:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12c4:	0f 90       	pop	r0
    12c6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    12ca:	98 13       	cpse	r25, r24
    12cc:	0f c0       	rjmp	.+30     	; 0x12ec <xQueueGenericSend+0x108>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12ce:	6c 81       	ldd	r22, Y+4	; 0x04
    12d0:	7d 81       	ldd	r23, Y+5	; 0x05
    12d2:	c7 01       	movw	r24, r14
    12d4:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    12d8:	c8 01       	movw	r24, r16
    12da:	0e 94 37 08 	call	0x106e	; 0x106e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    12de:	0e 94 4c 0c 	call	0x1898	; 0x1898 <xTaskResumeAll>
    12e2:	81 11       	cpse	r24, r1
    12e4:	9b cf       	rjmp	.-202    	; 0x121c <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    12e6:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
    12ea:	98 cf       	rjmp	.-208    	; 0x121c <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12ec:	c8 01       	movw	r24, r16
    12ee:	0e 94 37 08 	call	0x106e	; 0x106e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12f2:	0e 94 4c 0c 	call	0x1898	; 0x1898 <xTaskResumeAll>
    12f6:	92 cf       	rjmp	.-220    	; 0x121c <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    12f8:	c8 01       	movw	r24, r16
    12fa:	0e 94 37 08 	call	0x106e	; 0x106e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12fe:	0e 94 4c 0c 	call	0x1898	; 0x1898 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1302:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	0f 90       	pop	r0
    130c:	0f 90       	pop	r0
    130e:	df 91       	pop	r29
    1310:	cf 91       	pop	r28
    1312:	1f 91       	pop	r17
    1314:	0f 91       	pop	r16
    1316:	ff 90       	pop	r15
    1318:	ef 90       	pop	r14
    131a:	df 90       	pop	r13
    131c:	cf 90       	pop	r12
    131e:	bf 90       	pop	r11
    1320:	af 90       	pop	r10
    1322:	9f 90       	pop	r9
    1324:	08 95       	ret

00001326 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    132a:	48 2f       	mov	r20, r24
    132c:	60 e0       	ldi	r22, 0x00	; 0
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	0e 94 c1 08 	call	0x1182	; 0x1182 <xQueueGenericCreate>
    1334:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    1336:	00 97       	sbiw	r24, 0x00	; 0
    1338:	61 f0       	breq	.+24     	; 0x1352 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    133a:	1b 82       	std	Y+3, r1	; 0x03
    133c:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    133e:	19 82       	std	Y+1, r1	; 0x01
    1340:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    1342:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1344:	20 e0       	ldi	r18, 0x00	; 0
    1346:	40 e0       	ldi	r20, 0x00	; 0
    1348:	50 e0       	ldi	r21, 0x00	; 0
    134a:	60 e0       	ldi	r22, 0x00	; 0
    134c:	70 e0       	ldi	r23, 0x00	; 0
    134e:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    1352:	ce 01       	movw	r24, r28
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	08 95       	ret

0000135a <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    135a:	ef 92       	push	r14
    135c:	ff 92       	push	r15
    135e:	0f 93       	push	r16
    1360:	1f 93       	push	r17
    1362:	cf 93       	push	r28
    1364:	df 93       	push	r29
    1366:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1368:	fc 01       	movw	r30, r24
    136a:	52 8d       	ldd	r21, Z+26	; 0x1a
    136c:	33 8d       	ldd	r19, Z+27	; 0x1b
    136e:	53 17       	cp	r21, r19
    1370:	10 f0       	brcs	.+4      	; 0x1376 <xQueueGenericSendFromISR+0x1c>
    1372:	22 30       	cpi	r18, 0x02	; 2
    1374:	f1 f4       	brne	.+60     	; 0x13b2 <xQueueGenericSendFromISR+0x58>
    1376:	42 2f       	mov	r20, r18
    1378:	78 01       	movw	r14, r16
    137a:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    137c:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    137e:	0e 94 d6 07 	call	0xfac	; 0xfac <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1382:	1f 3f       	cpi	r17, 0xFF	; 255
    1384:	81 f4       	brne	.+32     	; 0x13a6 <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1386:	89 89       	ldd	r24, Y+17	; 0x11
    1388:	88 23       	and	r24, r24
    138a:	a9 f0       	breq	.+42     	; 0x13b6 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    138c:	ce 01       	movw	r24, r28
    138e:	41 96       	adiw	r24, 0x11	; 17
    1390:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <xTaskRemoveFromEventList>
    1394:	88 23       	and	r24, r24
    1396:	89 f0       	breq	.+34     	; 0x13ba <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1398:	e1 14       	cp	r14, r1
    139a:	f1 04       	cpc	r15, r1
    139c:	81 f0       	breq	.+32     	; 0x13be <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    139e:	81 e0       	ldi	r24, 0x01	; 1
    13a0:	f7 01       	movw	r30, r14
    13a2:	80 83       	st	Z, r24
    13a4:	0d c0       	rjmp	.+26     	; 0x13c0 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    13a6:	ff 24       	eor	r15, r15
    13a8:	f3 94       	inc	r15
    13aa:	f1 0e       	add	r15, r17
    13ac:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	07 c0       	rjmp	.+14     	; 0x13c0 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13b2:	80 e0       	ldi	r24, 0x00	; 0
    13b4:	05 c0       	rjmp	.+10     	; 0x13c0 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	03 c0       	rjmp	.+6      	; 0x13c0 <xQueueGenericSendFromISR+0x66>
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	01 c0       	rjmp	.+2      	; 0x13c0 <xQueueGenericSendFromISR+0x66>
    13be:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	1f 91       	pop	r17
    13c6:	0f 91       	pop	r16
    13c8:	ff 90       	pop	r15
    13ca:	ef 90       	pop	r14
    13cc:	08 95       	ret

000013ce <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    13ce:	e0 91 d2 06 	lds	r30, 0x06D2	; 0x8006d2 <pxDelayedTaskList>
    13d2:	f0 91 d3 06 	lds	r31, 0x06D3	; 0x8006d3 <pxDelayedTaskList+0x1>
    13d6:	80 81       	ld	r24, Z
    13d8:	81 11       	cpse	r24, r1
    13da:	07 c0       	rjmp	.+14     	; 0x13ea <prvResetNextTaskUnblockTime+0x1c>
    13dc:	8f ef       	ldi	r24, 0xFF	; 255
    13de:	9f ef       	ldi	r25, 0xFF	; 255
    13e0:	90 93 b3 06 	sts	0x06B3, r25	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    13e4:	80 93 b2 06 	sts	0x06B2, r24	; 0x8006b2 <xNextTaskUnblockTime>
    13e8:	08 95       	ret
    13ea:	e0 91 d2 06 	lds	r30, 0x06D2	; 0x8006d2 <pxDelayedTaskList>
    13ee:	f0 91 d3 06 	lds	r31, 0x06D3	; 0x8006d3 <pxDelayedTaskList+0x1>
    13f2:	05 80       	ldd	r0, Z+5	; 0x05
    13f4:	f6 81       	ldd	r31, Z+6	; 0x06
    13f6:	e0 2d       	mov	r30, r0
    13f8:	06 80       	ldd	r0, Z+6	; 0x06
    13fa:	f7 81       	ldd	r31, Z+7	; 0x07
    13fc:	e0 2d       	mov	r30, r0
    13fe:	82 81       	ldd	r24, Z+2	; 0x02
    1400:	93 81       	ldd	r25, Z+3	; 0x03
    1402:	90 93 b3 06 	sts	0x06B3, r25	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    1406:	80 93 b2 06 	sts	0x06B2, r24	; 0x8006b2 <xNextTaskUnblockTime>
    140a:	08 95       	ret

0000140c <prvAddCurrentTaskToDelayedList>:
    140c:	0f 93       	push	r16
    140e:	1f 93       	push	r17
    1410:	cf 93       	push	r28
    1412:	df 93       	push	r29
    1414:	ec 01       	movw	r28, r24
    1416:	00 91 ba 06 	lds	r16, 0x06BA	; 0x8006ba <xTickCount>
    141a:	10 91 bb 06 	lds	r17, 0x06BB	; 0x8006bb <xTickCount+0x1>
    141e:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <pxCurrentTCB>
    1422:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1426:	02 96       	adiw	r24, 0x02	; 2
    1428:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    142c:	c0 0f       	add	r28, r16
    142e:	d1 1f       	adc	r29, r17
    1430:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    1434:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1438:	d3 83       	std	Z+3, r29	; 0x03
    143a:	c2 83       	std	Z+2, r28	; 0x02
    143c:	c0 17       	cp	r28, r16
    143e:	d1 07       	cpc	r29, r17
    1440:	68 f4       	brcc	.+26     	; 0x145c <prvAddCurrentTaskToDelayedList+0x50>
    1442:	60 91 0a 07 	lds	r22, 0x070A	; 0x80070a <pxCurrentTCB>
    1446:	70 91 0b 07 	lds	r23, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    144a:	80 91 d0 06 	lds	r24, 0x06D0	; 0x8006d0 <pxOverflowDelayedTaskList>
    144e:	90 91 d1 06 	lds	r25, 0x06D1	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    1452:	6e 5f       	subi	r22, 0xFE	; 254
    1454:	7f 4f       	sbci	r23, 0xFF	; 255
    1456:	0e 94 22 04 	call	0x844	; 0x844 <vListInsert>
    145a:	17 c0       	rjmp	.+46     	; 0x148a <prvAddCurrentTaskToDelayedList+0x7e>
    145c:	60 91 0a 07 	lds	r22, 0x070A	; 0x80070a <pxCurrentTCB>
    1460:	70 91 0b 07 	lds	r23, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1464:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <pxDelayedTaskList>
    1468:	90 91 d3 06 	lds	r25, 0x06D3	; 0x8006d3 <pxDelayedTaskList+0x1>
    146c:	6e 5f       	subi	r22, 0xFE	; 254
    146e:	7f 4f       	sbci	r23, 0xFF	; 255
    1470:	0e 94 22 04 	call	0x844	; 0x844 <vListInsert>
    1474:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <xNextTaskUnblockTime>
    1478:	90 91 b3 06 	lds	r25, 0x06B3	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    147c:	c8 17       	cp	r28, r24
    147e:	d9 07       	cpc	r29, r25
    1480:	20 f4       	brcc	.+8      	; 0x148a <prvAddCurrentTaskToDelayedList+0x7e>
    1482:	d0 93 b3 06 	sts	0x06B3, r29	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    1486:	c0 93 b2 06 	sts	0x06B2, r28	; 0x8006b2 <xNextTaskUnblockTime>
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	1f 91       	pop	r17
    1490:	0f 91       	pop	r16
    1492:	08 95       	ret

00001494 <xTaskCreate>:
    1494:	4f 92       	push	r4
    1496:	5f 92       	push	r5
    1498:	6f 92       	push	r6
    149a:	7f 92       	push	r7
    149c:	8f 92       	push	r8
    149e:	9f 92       	push	r9
    14a0:	af 92       	push	r10
    14a2:	bf 92       	push	r11
    14a4:	cf 92       	push	r12
    14a6:	df 92       	push	r13
    14a8:	ef 92       	push	r14
    14aa:	ff 92       	push	r15
    14ac:	0f 93       	push	r16
    14ae:	cf 93       	push	r28
    14b0:	df 93       	push	r29
    14b2:	4c 01       	movw	r8, r24
    14b4:	eb 01       	movw	r28, r22
    14b6:	6a 01       	movw	r12, r20
    14b8:	29 01       	movw	r4, r18
    14ba:	ca 01       	movw	r24, r20
    14bc:	0e 94 d7 05 	call	0xbae	; 0xbae <pvPortMalloc>
    14c0:	5c 01       	movw	r10, r24
    14c2:	89 2b       	or	r24, r25
    14c4:	09 f4       	brne	.+2      	; 0x14c8 <xTaskCreate+0x34>
    14c6:	ec c0       	rjmp	.+472    	; 0x16a0 <xTaskCreate+0x20c>
    14c8:	8c e2       	ldi	r24, 0x2C	; 44
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	0e 94 d7 05 	call	0xbae	; 0xbae <pvPortMalloc>
    14d0:	3c 01       	movw	r6, r24
    14d2:	00 97       	sbiw	r24, 0x00	; 0
    14d4:	b9 f0       	breq	.+46     	; 0x1504 <xTaskCreate+0x70>
    14d6:	fc 01       	movw	r30, r24
    14d8:	b0 8e       	std	Z+24, r11	; 0x18
    14da:	a7 8a       	std	Z+23, r10	; 0x17
    14dc:	a6 01       	movw	r20, r12
    14de:	65 ea       	ldi	r22, 0xA5	; 165
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	c5 01       	movw	r24, r10
    14e4:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <memset>
    14e8:	f1 e0       	ldi	r31, 0x01	; 1
    14ea:	cf 1a       	sub	r12, r31
    14ec:	d1 08       	sbc	r13, r1
    14ee:	f3 01       	movw	r30, r6
    14f0:	87 89       	ldd	r24, Z+23	; 0x17
    14f2:	90 8d       	ldd	r25, Z+24	; 0x18
    14f4:	c8 0e       	add	r12, r24
    14f6:	d9 1e       	adc	r13, r25
    14f8:	88 81       	ld	r24, Y
    14fa:	81 8f       	std	Z+25, r24	; 0x19
    14fc:	88 81       	ld	r24, Y
    14fe:	81 11       	cpse	r24, r1
    1500:	05 c0       	rjmp	.+10     	; 0x150c <xTaskCreate+0x78>
    1502:	14 c0       	rjmp	.+40     	; 0x152c <xTaskCreate+0x98>
    1504:	c5 01       	movw	r24, r10
    1506:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortFree>
    150a:	ca c0       	rjmp	.+404    	; 0x16a0 <xTaskCreate+0x20c>
    150c:	d3 01       	movw	r26, r6
    150e:	5a 96       	adiw	r26, 0x1a	; 26
    1510:	fe 01       	movw	r30, r28
    1512:	31 96       	adiw	r30, 0x01	; 1
    1514:	9e 01       	movw	r18, r28
    1516:	28 5f       	subi	r18, 0xF8	; 248
    1518:	3f 4f       	sbci	r19, 0xFF	; 255
    151a:	ef 01       	movw	r28, r30
    151c:	81 91       	ld	r24, Z+
    151e:	8d 93       	st	X+, r24
    1520:	88 81       	ld	r24, Y
    1522:	88 23       	and	r24, r24
    1524:	19 f0       	breq	.+6      	; 0x152c <xTaskCreate+0x98>
    1526:	e2 17       	cp	r30, r18
    1528:	f3 07       	cpc	r31, r19
    152a:	b9 f7       	brne	.-18     	; 0x151a <xTaskCreate+0x86>
    152c:	f3 01       	movw	r30, r6
    152e:	10 a2       	std	Z+32, r1	; 0x20
    1530:	04 30       	cpi	r16, 0x04	; 4
    1532:	08 f0       	brcs	.+2      	; 0x1536 <xTaskCreate+0xa2>
    1534:	03 e0       	ldi	r16, 0x03	; 3
    1536:	f3 01       	movw	r30, r6
    1538:	06 8b       	std	Z+22, r16	; 0x16
    153a:	03 a3       	std	Z+35, r16	; 0x23
    153c:	14 a2       	std	Z+36, r1	; 0x24
    153e:	e3 01       	movw	r28, r6
    1540:	22 96       	adiw	r28, 0x02	; 2
    1542:	ce 01       	movw	r24, r28
    1544:	0e 94 fd 03 	call	0x7fa	; 0x7fa <vListInitialiseItem>
    1548:	c3 01       	movw	r24, r6
    154a:	0c 96       	adiw	r24, 0x0c	; 12
    154c:	0e 94 fd 03 	call	0x7fa	; 0x7fa <vListInitialiseItem>
    1550:	f3 01       	movw	r30, r6
    1552:	71 86       	std	Z+9, r7	; 0x09
    1554:	60 86       	std	Z+8, r6	; 0x08
    1556:	84 e0       	ldi	r24, 0x04	; 4
    1558:	90 e0       	ldi	r25, 0x00	; 0
    155a:	80 1b       	sub	r24, r16
    155c:	91 09       	sbc	r25, r1
    155e:	95 87       	std	Z+13, r25	; 0x0d
    1560:	84 87       	std	Z+12, r24	; 0x0c
    1562:	73 8a       	std	Z+19, r7	; 0x13
    1564:	62 8a       	std	Z+18, r6	; 0x12
    1566:	16 a2       	std	Z+38, r1	; 0x26
    1568:	15 a2       	std	Z+37, r1	; 0x25
    156a:	17 a2       	std	Z+39, r1	; 0x27
    156c:	10 a6       	std	Z+40, r1	; 0x28
    156e:	11 a6       	std	Z+41, r1	; 0x29
    1570:	12 a6       	std	Z+42, r1	; 0x2a
    1572:	13 a6       	std	Z+43, r1	; 0x2b
    1574:	a2 01       	movw	r20, r4
    1576:	b4 01       	movw	r22, r8
    1578:	c6 01       	movw	r24, r12
    157a:	0e 94 79 04 	call	0x8f2	; 0x8f2 <pxPortInitialiseStack>
    157e:	f3 01       	movw	r30, r6
    1580:	91 83       	std	Z+1, r25	; 0x01
    1582:	80 83       	st	Z, r24
    1584:	e1 14       	cp	r14, r1
    1586:	f1 04       	cpc	r15, r1
    1588:	19 f0       	breq	.+6      	; 0x1590 <xTaskCreate+0xfc>
    158a:	f7 01       	movw	r30, r14
    158c:	71 82       	std	Z+1, r7	; 0x01
    158e:	60 82       	st	Z, r6
    1590:	0f b6       	in	r0, 0x3f	; 63
    1592:	f8 94       	cli
    1594:	0f 92       	push	r0
    1596:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <uxCurrentNumberOfTasks>
    159a:	8f 5f       	subi	r24, 0xFF	; 255
    159c:	80 93 bc 06 	sts	0x06BC, r24	; 0x8006bc <uxCurrentNumberOfTasks>
    15a0:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <pxCurrentTCB>
    15a4:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    15a8:	89 2b       	or	r24, r25
    15aa:	a9 f5       	brne	.+106    	; 0x1616 <xTaskCreate+0x182>
    15ac:	70 92 0b 07 	sts	0x070B, r7	; 0x80070b <pxCurrentTCB+0x1>
    15b0:	60 92 0a 07 	sts	0x070A, r6	; 0x80070a <pxCurrentTCB>
    15b4:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <uxCurrentNumberOfTasks>
    15b8:	81 30       	cpi	r24, 0x01	; 1
    15ba:	f1 f5       	brne	.+124    	; 0x1638 <xTaskCreate+0x1a4>
    15bc:	86 ee       	ldi	r24, 0xE6	; 230
    15be:	96 e0       	ldi	r25, 0x06	; 6
    15c0:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15c4:	8f ee       	ldi	r24, 0xEF	; 239
    15c6:	96 e0       	ldi	r25, 0x06	; 6
    15c8:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15cc:	88 ef       	ldi	r24, 0xF8	; 248
    15ce:	96 e0       	ldi	r25, 0x06	; 6
    15d0:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	97 e0       	ldi	r25, 0x07	; 7
    15d8:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15dc:	8d ed       	ldi	r24, 0xDD	; 221
    15de:	96 e0       	ldi	r25, 0x06	; 6
    15e0:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15e4:	84 ed       	ldi	r24, 0xD4	; 212
    15e6:	96 e0       	ldi	r25, 0x06	; 6
    15e8:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15ec:	87 ec       	ldi	r24, 0xC7	; 199
    15ee:	96 e0       	ldi	r25, 0x06	; 6
    15f0:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15f4:	8e eb       	ldi	r24, 0xBE	; 190
    15f6:	96 e0       	ldi	r25, 0x06	; 6
    15f8:	0e 94 ef 03 	call	0x7de	; 0x7de <vListInitialise>
    15fc:	8d ed       	ldi	r24, 0xDD	; 221
    15fe:	96 e0       	ldi	r25, 0x06	; 6
    1600:	90 93 d3 06 	sts	0x06D3, r25	; 0x8006d3 <pxDelayedTaskList+0x1>
    1604:	80 93 d2 06 	sts	0x06D2, r24	; 0x8006d2 <pxDelayedTaskList>
    1608:	84 ed       	ldi	r24, 0xD4	; 212
    160a:	96 e0       	ldi	r25, 0x06	; 6
    160c:	90 93 d1 06 	sts	0x06D1, r25	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    1610:	80 93 d0 06 	sts	0x06D0, r24	; 0x8006d0 <pxOverflowDelayedTaskList>
    1614:	11 c0       	rjmp	.+34     	; 0x1638 <xTaskCreate+0x1a4>
    1616:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <xSchedulerRunning>
    161a:	81 11       	cpse	r24, r1
    161c:	0d c0       	rjmp	.+26     	; 0x1638 <xTaskCreate+0x1a4>
    161e:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    1622:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1626:	96 89       	ldd	r25, Z+22	; 0x16
    1628:	f3 01       	movw	r30, r6
    162a:	86 89       	ldd	r24, Z+22	; 0x16
    162c:	89 17       	cp	r24, r25
    162e:	20 f0       	brcs	.+8      	; 0x1638 <xTaskCreate+0x1a4>
    1630:	70 92 0b 07 	sts	0x070B, r7	; 0x80070b <pxCurrentTCB+0x1>
    1634:	60 92 0a 07 	sts	0x070A, r6	; 0x80070a <pxCurrentTCB>
    1638:	80 91 b4 06 	lds	r24, 0x06B4	; 0x8006b4 <uxTaskNumber>
    163c:	8f 5f       	subi	r24, 0xFF	; 255
    163e:	80 93 b4 06 	sts	0x06B4, r24	; 0x8006b4 <uxTaskNumber>
    1642:	f3 01       	movw	r30, r6
    1644:	81 a3       	std	Z+33, r24	; 0x21
    1646:	86 89       	ldd	r24, Z+22	; 0x16
    1648:	90 91 b9 06 	lds	r25, 0x06B9	; 0x8006b9 <uxTopReadyPriority>
    164c:	98 17       	cp	r25, r24
    164e:	10 f4       	brcc	.+4      	; 0x1654 <xTaskCreate+0x1c0>
    1650:	80 93 b9 06 	sts	0x06B9, r24	; 0x8006b9 <uxTopReadyPriority>
    1654:	90 e0       	ldi	r25, 0x00	; 0
    1656:	9c 01       	movw	r18, r24
    1658:	22 0f       	add	r18, r18
    165a:	33 1f       	adc	r19, r19
    165c:	22 0f       	add	r18, r18
    165e:	33 1f       	adc	r19, r19
    1660:	22 0f       	add	r18, r18
    1662:	33 1f       	adc	r19, r19
    1664:	82 0f       	add	r24, r18
    1666:	93 1f       	adc	r25, r19
    1668:	be 01       	movw	r22, r28
    166a:	8a 51       	subi	r24, 0x1A	; 26
    166c:	99 4f       	sbci	r25, 0xF9	; 249
    166e:	0e 94 01 04 	call	0x802	; 0x802 <vListInsertEnd>
    1672:	0f 90       	pop	r0
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <xSchedulerRunning>
    167a:	88 23       	and	r24, r24
    167c:	69 f0       	breq	.+26     	; 0x1698 <xTaskCreate+0x204>
    167e:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    1682:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1686:	96 89       	ldd	r25, Z+22	; 0x16
    1688:	f3 01       	movw	r30, r6
    168a:	86 89       	ldd	r24, Z+22	; 0x16
    168c:	98 17       	cp	r25, r24
    168e:	30 f4       	brcc	.+12     	; 0x169c <xTaskCreate+0x208>
    1690:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	05 c0       	rjmp	.+10     	; 0x16a2 <xTaskCreate+0x20e>
    1698:	81 e0       	ldi	r24, 0x01	; 1
    169a:	03 c0       	rjmp	.+6      	; 0x16a2 <xTaskCreate+0x20e>
    169c:	81 e0       	ldi	r24, 0x01	; 1
    169e:	01 c0       	rjmp	.+2      	; 0x16a2 <xTaskCreate+0x20e>
    16a0:	8f ef       	ldi	r24, 0xFF	; 255
    16a2:	df 91       	pop	r29
    16a4:	cf 91       	pop	r28
    16a6:	0f 91       	pop	r16
    16a8:	ff 90       	pop	r15
    16aa:	ef 90       	pop	r14
    16ac:	df 90       	pop	r13
    16ae:	cf 90       	pop	r12
    16b0:	bf 90       	pop	r11
    16b2:	af 90       	pop	r10
    16b4:	9f 90       	pop	r9
    16b6:	8f 90       	pop	r8
    16b8:	7f 90       	pop	r7
    16ba:	6f 90       	pop	r6
    16bc:	5f 90       	pop	r5
    16be:	4f 90       	pop	r4
    16c0:	08 95       	ret

000016c2 <vTaskStartScheduler>:
    16c2:	ef 92       	push	r14
    16c4:	ff 92       	push	r15
    16c6:	0f 93       	push	r16
    16c8:	0f 2e       	mov	r0, r31
    16ca:	f0 eb       	ldi	r31, 0xB0	; 176
    16cc:	ef 2e       	mov	r14, r31
    16ce:	f6 e0       	ldi	r31, 0x06	; 6
    16d0:	ff 2e       	mov	r15, r31
    16d2:	f0 2d       	mov	r31, r0
    16d4:	00 e0       	ldi	r16, 0x00	; 0
    16d6:	20 e0       	ldi	r18, 0x00	; 0
    16d8:	30 e0       	ldi	r19, 0x00	; 0
    16da:	45 e5       	ldi	r20, 0x55	; 85
    16dc:	50 e0       	ldi	r21, 0x00	; 0
    16de:	64 e3       	ldi	r22, 0x34	; 52
    16e0:	71 e0       	ldi	r23, 0x01	; 1
    16e2:	8f ed       	ldi	r24, 0xDF	; 223
    16e4:	9c e0       	ldi	r25, 0x0C	; 12
    16e6:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xTaskCreate>
    16ea:	81 30       	cpi	r24, 0x01	; 1
    16ec:	81 f4       	brne	.+32     	; 0x170e <vTaskStartScheduler+0x4c>
    16ee:	f8 94       	cli
    16f0:	8f ef       	ldi	r24, 0xFF	; 255
    16f2:	9f ef       	ldi	r25, 0xFF	; 255
    16f4:	90 93 b3 06 	sts	0x06B3, r25	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    16f8:	80 93 b2 06 	sts	0x06B2, r24	; 0x8006b2 <xNextTaskUnblockTime>
    16fc:	81 e0       	ldi	r24, 0x01	; 1
    16fe:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <xSchedulerRunning>
    1702:	10 92 bb 06 	sts	0x06BB, r1	; 0x8006bb <xTickCount+0x1>
    1706:	10 92 ba 06 	sts	0x06BA, r1	; 0x8006ba <xTickCount>
    170a:	0e 94 e5 04 	call	0x9ca	; 0x9ca <xPortStartScheduler>
    170e:	0f 91       	pop	r16
    1710:	ff 90       	pop	r15
    1712:	ef 90       	pop	r14
    1714:	08 95       	ret

00001716 <vTaskSuspendAll>:
    1716:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <uxSchedulerSuspended>
    171a:	8f 5f       	subi	r24, 0xFF	; 255
    171c:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <uxSchedulerSuspended>
    1720:	08 95       	ret

00001722 <xTaskIncrementTick>:
    1722:	cf 92       	push	r12
    1724:	df 92       	push	r13
    1726:	ef 92       	push	r14
    1728:	ff 92       	push	r15
    172a:	0f 93       	push	r16
    172c:	1f 93       	push	r17
    172e:	cf 93       	push	r28
    1730:	df 93       	push	r29
    1732:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <uxSchedulerSuspended>
    1736:	81 11       	cpse	r24, r1
    1738:	99 c0       	rjmp	.+306    	; 0x186c <xTaskIncrementTick+0x14a>
    173a:	e0 90 ba 06 	lds	r14, 0x06BA	; 0x8006ba <xTickCount>
    173e:	f0 90 bb 06 	lds	r15, 0x06BB	; 0x8006bb <xTickCount+0x1>
    1742:	8f ef       	ldi	r24, 0xFF	; 255
    1744:	e8 1a       	sub	r14, r24
    1746:	f8 0a       	sbc	r15, r24
    1748:	f0 92 bb 06 	sts	0x06BB, r15	; 0x8006bb <xTickCount+0x1>
    174c:	e0 92 ba 06 	sts	0x06BA, r14	; 0x8006ba <xTickCount>
    1750:	e1 14       	cp	r14, r1
    1752:	f1 04       	cpc	r15, r1
    1754:	b9 f4       	brne	.+46     	; 0x1784 <xTaskIncrementTick+0x62>
    1756:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <pxDelayedTaskList>
    175a:	90 91 d3 06 	lds	r25, 0x06D3	; 0x8006d3 <pxDelayedTaskList+0x1>
    175e:	20 91 d0 06 	lds	r18, 0x06D0	; 0x8006d0 <pxOverflowDelayedTaskList>
    1762:	30 91 d1 06 	lds	r19, 0x06D1	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    1766:	30 93 d3 06 	sts	0x06D3, r19	; 0x8006d3 <pxDelayedTaskList+0x1>
    176a:	20 93 d2 06 	sts	0x06D2, r18	; 0x8006d2 <pxDelayedTaskList>
    176e:	90 93 d1 06 	sts	0x06D1, r25	; 0x8006d1 <pxOverflowDelayedTaskList+0x1>
    1772:	80 93 d0 06 	sts	0x06D0, r24	; 0x8006d0 <pxOverflowDelayedTaskList>
    1776:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xNumOfOverflows>
    177a:	8f 5f       	subi	r24, 0xFF	; 255
    177c:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <xNumOfOverflows>
    1780:	0e 94 e7 09 	call	0x13ce	; 0x13ce <prvResetNextTaskUnblockTime>
    1784:	80 91 b2 06 	lds	r24, 0x06B2	; 0x8006b2 <xNextTaskUnblockTime>
    1788:	90 91 b3 06 	lds	r25, 0x06B3	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    178c:	e8 16       	cp	r14, r24
    178e:	f9 06       	cpc	r15, r25
    1790:	10 f4       	brcc	.+4      	; 0x1796 <xTaskIncrementTick+0x74>
    1792:	d1 2c       	mov	r13, r1
    1794:	53 c0       	rjmp	.+166    	; 0x183c <xTaskIncrementTick+0x11a>
    1796:	d1 2c       	mov	r13, r1
    1798:	cc 24       	eor	r12, r12
    179a:	c3 94       	inc	r12
    179c:	e0 91 d2 06 	lds	r30, 0x06D2	; 0x8006d2 <pxDelayedTaskList>
    17a0:	f0 91 d3 06 	lds	r31, 0x06D3	; 0x8006d3 <pxDelayedTaskList+0x1>
    17a4:	90 81       	ld	r25, Z
    17a6:	91 11       	cpse	r25, r1
    17a8:	07 c0       	rjmp	.+14     	; 0x17b8 <xTaskIncrementTick+0x96>
    17aa:	8f ef       	ldi	r24, 0xFF	; 255
    17ac:	9f ef       	ldi	r25, 0xFF	; 255
    17ae:	90 93 b3 06 	sts	0x06B3, r25	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    17b2:	80 93 b2 06 	sts	0x06B2, r24	; 0x8006b2 <xNextTaskUnblockTime>
    17b6:	42 c0       	rjmp	.+132    	; 0x183c <xTaskIncrementTick+0x11a>
    17b8:	e0 91 d2 06 	lds	r30, 0x06D2	; 0x8006d2 <pxDelayedTaskList>
    17bc:	f0 91 d3 06 	lds	r31, 0x06D3	; 0x8006d3 <pxDelayedTaskList+0x1>
    17c0:	05 80       	ldd	r0, Z+5	; 0x05
    17c2:	f6 81       	ldd	r31, Z+6	; 0x06
    17c4:	e0 2d       	mov	r30, r0
    17c6:	c6 81       	ldd	r28, Z+6	; 0x06
    17c8:	d7 81       	ldd	r29, Z+7	; 0x07
    17ca:	2a 81       	ldd	r18, Y+2	; 0x02
    17cc:	3b 81       	ldd	r19, Y+3	; 0x03
    17ce:	e2 16       	cp	r14, r18
    17d0:	f3 06       	cpc	r15, r19
    17d2:	28 f4       	brcc	.+10     	; 0x17de <xTaskIncrementTick+0xbc>
    17d4:	30 93 b3 06 	sts	0x06B3, r19	; 0x8006b3 <xNextTaskUnblockTime+0x1>
    17d8:	20 93 b2 06 	sts	0x06B2, r18	; 0x8006b2 <xNextTaskUnblockTime>
    17dc:	2f c0       	rjmp	.+94     	; 0x183c <xTaskIncrementTick+0x11a>
    17de:	8e 01       	movw	r16, r28
    17e0:	0e 5f       	subi	r16, 0xFE	; 254
    17e2:	1f 4f       	sbci	r17, 0xFF	; 255
    17e4:	c8 01       	movw	r24, r16
    17e6:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    17ea:	8c 89       	ldd	r24, Y+20	; 0x14
    17ec:	9d 89       	ldd	r25, Y+21	; 0x15
    17ee:	89 2b       	or	r24, r25
    17f0:	21 f0       	breq	.+8      	; 0x17fa <xTaskIncrementTick+0xd8>
    17f2:	ce 01       	movw	r24, r28
    17f4:	0c 96       	adiw	r24, 0x0c	; 12
    17f6:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    17fa:	2e 89       	ldd	r18, Y+22	; 0x16
    17fc:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <uxTopReadyPriority>
    1800:	82 17       	cp	r24, r18
    1802:	10 f4       	brcc	.+4      	; 0x1808 <xTaskIncrementTick+0xe6>
    1804:	20 93 b9 06 	sts	0x06B9, r18	; 0x8006b9 <uxTopReadyPriority>
    1808:	30 e0       	ldi	r19, 0x00	; 0
    180a:	c9 01       	movw	r24, r18
    180c:	88 0f       	add	r24, r24
    180e:	99 1f       	adc	r25, r25
    1810:	88 0f       	add	r24, r24
    1812:	99 1f       	adc	r25, r25
    1814:	88 0f       	add	r24, r24
    1816:	99 1f       	adc	r25, r25
    1818:	82 0f       	add	r24, r18
    181a:	93 1f       	adc	r25, r19
    181c:	b8 01       	movw	r22, r16
    181e:	8a 51       	subi	r24, 0x1A	; 26
    1820:	99 4f       	sbci	r25, 0xF9	; 249
    1822:	0e 94 01 04 	call	0x802	; 0x802 <vListInsertEnd>
    1826:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    182a:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    182e:	9e 89       	ldd	r25, Y+22	; 0x16
    1830:	86 89       	ldd	r24, Z+22	; 0x16
    1832:	98 17       	cp	r25, r24
    1834:	08 f4       	brcc	.+2      	; 0x1838 <xTaskIncrementTick+0x116>
    1836:	b2 cf       	rjmp	.-156    	; 0x179c <xTaskIncrementTick+0x7a>
    1838:	dc 2c       	mov	r13, r12
    183a:	b0 cf       	rjmp	.-160    	; 0x179c <xTaskIncrementTick+0x7a>
    183c:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    1840:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1844:	86 89       	ldd	r24, Z+22	; 0x16
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	fc 01       	movw	r30, r24
    184a:	ee 0f       	add	r30, r30
    184c:	ff 1f       	adc	r31, r31
    184e:	ee 0f       	add	r30, r30
    1850:	ff 1f       	adc	r31, r31
    1852:	ee 0f       	add	r30, r30
    1854:	ff 1f       	adc	r31, r31
    1856:	8e 0f       	add	r24, r30
    1858:	9f 1f       	adc	r25, r31
    185a:	fc 01       	movw	r30, r24
    185c:	ea 51       	subi	r30, 0x1A	; 26
    185e:	f9 4f       	sbci	r31, 0xF9	; 249
    1860:	80 81       	ld	r24, Z
    1862:	82 30       	cpi	r24, 0x02	; 2
    1864:	48 f0       	brcs	.+18     	; 0x1878 <xTaskIncrementTick+0x156>
    1866:	dd 24       	eor	r13, r13
    1868:	d3 94       	inc	r13
    186a:	06 c0       	rjmp	.+12     	; 0x1878 <xTaskIncrementTick+0x156>
    186c:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <uxPendedTicks>
    1870:	8f 5f       	subi	r24, 0xFF	; 255
    1872:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <uxPendedTicks>
    1876:	d1 2c       	mov	r13, r1
    1878:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <xYieldPending>
    187c:	88 23       	and	r24, r24
    187e:	11 f0       	breq	.+4      	; 0x1884 <xTaskIncrementTick+0x162>
    1880:	dd 24       	eor	r13, r13
    1882:	d3 94       	inc	r13
    1884:	8d 2d       	mov	r24, r13
    1886:	df 91       	pop	r29
    1888:	cf 91       	pop	r28
    188a:	1f 91       	pop	r17
    188c:	0f 91       	pop	r16
    188e:	ff 90       	pop	r15
    1890:	ef 90       	pop	r14
    1892:	df 90       	pop	r13
    1894:	cf 90       	pop	r12
    1896:	08 95       	ret

00001898 <xTaskResumeAll>:
    1898:	df 92       	push	r13
    189a:	ef 92       	push	r14
    189c:	ff 92       	push	r15
    189e:	0f 93       	push	r16
    18a0:	1f 93       	push	r17
    18a2:	cf 93       	push	r28
    18a4:	df 93       	push	r29
    18a6:	0f b6       	in	r0, 0x3f	; 63
    18a8:	f8 94       	cli
    18aa:	0f 92       	push	r0
    18ac:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <uxSchedulerSuspended>
    18b0:	81 50       	subi	r24, 0x01	; 1
    18b2:	80 93 af 06 	sts	0x06AF, r24	; 0x8006af <uxSchedulerSuspended>
    18b6:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <uxSchedulerSuspended>
    18ba:	81 11       	cpse	r24, r1
    18bc:	5f c0       	rjmp	.+190    	; 0x197c <xTaskResumeAll+0xe4>
    18be:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <uxCurrentNumberOfTasks>
    18c2:	81 11       	cpse	r24, r1
    18c4:	33 c0       	rjmp	.+102    	; 0x192c <xTaskResumeAll+0x94>
    18c6:	5d c0       	rjmp	.+186    	; 0x1982 <xTaskResumeAll+0xea>
    18c8:	d7 01       	movw	r26, r14
    18ca:	15 96       	adiw	r26, 0x05	; 5
    18cc:	ed 91       	ld	r30, X+
    18ce:	fc 91       	ld	r31, X
    18d0:	16 97       	sbiw	r26, 0x06	; 6
    18d2:	c6 81       	ldd	r28, Z+6	; 0x06
    18d4:	d7 81       	ldd	r29, Z+7	; 0x07
    18d6:	ce 01       	movw	r24, r28
    18d8:	0c 96       	adiw	r24, 0x0c	; 12
    18da:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    18de:	8e 01       	movw	r16, r28
    18e0:	0e 5f       	subi	r16, 0xFE	; 254
    18e2:	1f 4f       	sbci	r17, 0xFF	; 255
    18e4:	c8 01       	movw	r24, r16
    18e6:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    18ea:	2e 89       	ldd	r18, Y+22	; 0x16
    18ec:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <uxTopReadyPriority>
    18f0:	82 17       	cp	r24, r18
    18f2:	10 f4       	brcc	.+4      	; 0x18f8 <xTaskResumeAll+0x60>
    18f4:	20 93 b9 06 	sts	0x06B9, r18	; 0x8006b9 <uxTopReadyPriority>
    18f8:	30 e0       	ldi	r19, 0x00	; 0
    18fa:	c9 01       	movw	r24, r18
    18fc:	88 0f       	add	r24, r24
    18fe:	99 1f       	adc	r25, r25
    1900:	88 0f       	add	r24, r24
    1902:	99 1f       	adc	r25, r25
    1904:	88 0f       	add	r24, r24
    1906:	99 1f       	adc	r25, r25
    1908:	82 0f       	add	r24, r18
    190a:	93 1f       	adc	r25, r19
    190c:	b8 01       	movw	r22, r16
    190e:	8a 51       	subi	r24, 0x1A	; 26
    1910:	99 4f       	sbci	r25, 0xF9	; 249
    1912:	0e 94 01 04 	call	0x802	; 0x802 <vListInsertEnd>
    1916:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    191a:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    191e:	9e 89       	ldd	r25, Y+22	; 0x16
    1920:	86 89       	ldd	r24, Z+22	; 0x16
    1922:	98 17       	cp	r25, r24
    1924:	68 f0       	brcs	.+26     	; 0x1940 <xTaskResumeAll+0xa8>
    1926:	d0 92 b6 06 	sts	0x06B6, r13	; 0x8006b6 <xYieldPending>
    192a:	0a c0       	rjmp	.+20     	; 0x1940 <xTaskResumeAll+0xa8>
    192c:	c0 e0       	ldi	r28, 0x00	; 0
    192e:	d0 e0       	ldi	r29, 0x00	; 0
    1930:	0f 2e       	mov	r0, r31
    1932:	f7 ec       	ldi	r31, 0xC7	; 199
    1934:	ef 2e       	mov	r14, r31
    1936:	f6 e0       	ldi	r31, 0x06	; 6
    1938:	ff 2e       	mov	r15, r31
    193a:	f0 2d       	mov	r31, r0
    193c:	dd 24       	eor	r13, r13
    193e:	d3 94       	inc	r13
    1940:	f7 01       	movw	r30, r14
    1942:	80 81       	ld	r24, Z
    1944:	81 11       	cpse	r24, r1
    1946:	c0 cf       	rjmp	.-128    	; 0x18c8 <xTaskResumeAll+0x30>
    1948:	cd 2b       	or	r28, r29
    194a:	11 f0       	breq	.+4      	; 0x1950 <xTaskResumeAll+0xb8>
    194c:	0e 94 e7 09 	call	0x13ce	; 0x13ce <prvResetNextTaskUnblockTime>
    1950:	c0 91 b7 06 	lds	r28, 0x06B7	; 0x8006b7 <uxPendedTicks>
    1954:	cc 23       	and	r28, r28
    1956:	51 f0       	breq	.+20     	; 0x196c <xTaskResumeAll+0xd4>
    1958:	d1 e0       	ldi	r29, 0x01	; 1
    195a:	0e 94 91 0b 	call	0x1722	; 0x1722 <xTaskIncrementTick>
    195e:	81 11       	cpse	r24, r1
    1960:	d0 93 b6 06 	sts	0x06B6, r29	; 0x8006b6 <xYieldPending>
    1964:	c1 50       	subi	r28, 0x01	; 1
    1966:	c9 f7       	brne	.-14     	; 0x195a <xTaskResumeAll+0xc2>
    1968:	10 92 b7 06 	sts	0x06B7, r1	; 0x8006b7 <uxPendedTicks>
    196c:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <xYieldPending>
    1970:	88 23       	and	r24, r24
    1972:	31 f0       	breq	.+12     	; 0x1980 <xTaskResumeAll+0xe8>
    1974:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	03 c0       	rjmp	.+6      	; 0x1982 <xTaskResumeAll+0xea>
    197c:	80 e0       	ldi	r24, 0x00	; 0
    197e:	01 c0       	rjmp	.+2      	; 0x1982 <xTaskResumeAll+0xea>
    1980:	80 e0       	ldi	r24, 0x00	; 0
    1982:	0f 90       	pop	r0
    1984:	0f be       	out	0x3f, r0	; 63
    1986:	df 91       	pop	r29
    1988:	cf 91       	pop	r28
    198a:	1f 91       	pop	r17
    198c:	0f 91       	pop	r16
    198e:	ff 90       	pop	r15
    1990:	ef 90       	pop	r14
    1992:	df 90       	pop	r13
    1994:	08 95       	ret

00001996 <vTaskDelay>:
    1996:	cf 93       	push	r28
    1998:	df 93       	push	r29
    199a:	ec 01       	movw	r28, r24
    199c:	89 2b       	or	r24, r25
    199e:	51 f0       	breq	.+20     	; 0x19b4 <vTaskDelay+0x1e>
    19a0:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vTaskSuspendAll>
    19a4:	60 e0       	ldi	r22, 0x00	; 0
    19a6:	ce 01       	movw	r24, r28
    19a8:	0e 94 06 0a 	call	0x140c	; 0x140c <prvAddCurrentTaskToDelayedList>
    19ac:	0e 94 4c 0c 	call	0x1898	; 0x1898 <xTaskResumeAll>
    19b0:	81 11       	cpse	r24, r1
    19b2:	02 c0       	rjmp	.+4      	; 0x19b8 <vTaskDelay+0x22>
    19b4:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
    19b8:	df 91       	pop	r29
    19ba:	cf 91       	pop	r28
    19bc:	08 95       	ret

000019be <prvIdleTask>:
    19be:	0e eb       	ldi	r16, 0xBE	; 190
    19c0:	16 e0       	ldi	r17, 0x06	; 6
    19c2:	0f 2e       	mov	r0, r31
    19c4:	f6 ee       	ldi	r31, 0xE6	; 230
    19c6:	ef 2e       	mov	r14, r31
    19c8:	f6 e0       	ldi	r31, 0x06	; 6
    19ca:	ff 2e       	mov	r15, r31
    19cc:	f0 2d       	mov	r31, r0
    19ce:	29 c0       	rjmp	.+82     	; 0x1a22 <prvIdleTask+0x64>
    19d0:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vTaskSuspendAll>
    19d4:	d8 01       	movw	r26, r16
    19d6:	cc 91       	ld	r28, X
    19d8:	0e 94 4c 0c 	call	0x1898	; 0x1898 <xTaskResumeAll>
    19dc:	cc 23       	and	r28, r28
    19de:	09 f1       	breq	.+66     	; 0x1a22 <prvIdleTask+0x64>
    19e0:	0f b6       	in	r0, 0x3f	; 63
    19e2:	f8 94       	cli
    19e4:	0f 92       	push	r0
    19e6:	d8 01       	movw	r26, r16
    19e8:	15 96       	adiw	r26, 0x05	; 5
    19ea:	ed 91       	ld	r30, X+
    19ec:	fc 91       	ld	r31, X
    19ee:	16 97       	sbiw	r26, 0x06	; 6
    19f0:	c6 81       	ldd	r28, Z+6	; 0x06
    19f2:	d7 81       	ldd	r29, Z+7	; 0x07
    19f4:	ce 01       	movw	r24, r28
    19f6:	02 96       	adiw	r24, 0x02	; 2
    19f8:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    19fc:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <uxCurrentNumberOfTasks>
    1a00:	81 50       	subi	r24, 0x01	; 1
    1a02:	80 93 bc 06 	sts	0x06BC, r24	; 0x8006bc <uxCurrentNumberOfTasks>
    1a06:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <uxDeletedTasksWaitingCleanUp>
    1a0a:	81 50       	subi	r24, 0x01	; 1
    1a0c:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <uxDeletedTasksWaitingCleanUp>
    1a10:	0f 90       	pop	r0
    1a12:	0f be       	out	0x3f, r0	; 63
    1a14:	8f 89       	ldd	r24, Y+23	; 0x17
    1a16:	98 8d       	ldd	r25, Y+24	; 0x18
    1a18:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortFree>
    1a1c:	ce 01       	movw	r24, r28
    1a1e:	0e 94 0c 06 	call	0xc18	; 0xc18 <vPortFree>
    1a22:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <uxDeletedTasksWaitingCleanUp>
    1a26:	81 11       	cpse	r24, r1
    1a28:	d3 cf       	rjmp	.-90     	; 0x19d0 <prvIdleTask+0x12>
    1a2a:	f7 01       	movw	r30, r14
    1a2c:	80 81       	ld	r24, Z
    1a2e:	82 30       	cpi	r24, 0x02	; 2
    1a30:	10 f0       	brcs	.+4      	; 0x1a36 <prvIdleTask+0x78>
    1a32:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vPortYield>
    1a36:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vApplicationIdleHook>
    1a3a:	f3 cf       	rjmp	.-26     	; 0x1a22 <prvIdleTask+0x64>

00001a3c <vTaskSetApplicationTaskTag>:
    1a3c:	00 97       	sbiw	r24, 0x00	; 0
    1a3e:	21 f4       	brne	.+8      	; 0x1a48 <vTaskSetApplicationTaskTag+0xc>
    1a40:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <pxCurrentTCB>
    1a44:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	f8 94       	cli
    1a4c:	0f 92       	push	r0
    1a4e:	fc 01       	movw	r30, r24
    1a50:	76 a3       	std	Z+38, r23	; 0x26
    1a52:	65 a3       	std	Z+37, r22	; 0x25
    1a54:	0f 90       	pop	r0
    1a56:	0f be       	out	0x3f, r0	; 63
    1a58:	08 95       	ret

00001a5a <vTaskSwitchContext>:
    1a5a:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <uxSchedulerSuspended>
    1a5e:	88 23       	and	r24, r24
    1a60:	21 f0       	breq	.+8      	; 0x1a6a <vTaskSwitchContext+0x10>
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	80 93 b6 06 	sts	0x06B6, r24	; 0x8006b6 <xYieldPending>
    1a68:	08 95       	ret
    1a6a:	10 92 b6 06 	sts	0x06B6, r1	; 0x8006b6 <xYieldPending>
    1a6e:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    1a72:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1a76:	85 a1       	ldd	r24, Z+37	; 0x25
    1a78:	0e 94 a8 03 	call	0x750	; 0x750 <switch_out>
    1a7c:	20 91 b9 06 	lds	r18, 0x06B9	; 0x8006b9 <uxTopReadyPriority>
    1a80:	82 2f       	mov	r24, r18
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	fc 01       	movw	r30, r24
    1a86:	ee 0f       	add	r30, r30
    1a88:	ff 1f       	adc	r31, r31
    1a8a:	ee 0f       	add	r30, r30
    1a8c:	ff 1f       	adc	r31, r31
    1a8e:	ee 0f       	add	r30, r30
    1a90:	ff 1f       	adc	r31, r31
    1a92:	e8 0f       	add	r30, r24
    1a94:	f9 1f       	adc	r31, r25
    1a96:	ea 51       	subi	r30, 0x1A	; 26
    1a98:	f9 4f       	sbci	r31, 0xF9	; 249
    1a9a:	30 81       	ld	r19, Z
    1a9c:	31 11       	cpse	r19, r1
    1a9e:	11 c0       	rjmp	.+34     	; 0x1ac2 <vTaskSwitchContext+0x68>
    1aa0:	21 50       	subi	r18, 0x01	; 1
    1aa2:	82 2f       	mov	r24, r18
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	ee 0f       	add	r30, r30
    1aaa:	ff 1f       	adc	r31, r31
    1aac:	ee 0f       	add	r30, r30
    1aae:	ff 1f       	adc	r31, r31
    1ab0:	ee 0f       	add	r30, r30
    1ab2:	ff 1f       	adc	r31, r31
    1ab4:	e8 0f       	add	r30, r24
    1ab6:	f9 1f       	adc	r31, r25
    1ab8:	ea 51       	subi	r30, 0x1A	; 26
    1aba:	f9 4f       	sbci	r31, 0xF9	; 249
    1abc:	30 81       	ld	r19, Z
    1abe:	33 23       	and	r19, r19
    1ac0:	79 f3       	breq	.-34     	; 0x1aa0 <vTaskSwitchContext+0x46>
    1ac2:	ac 01       	movw	r20, r24
    1ac4:	44 0f       	add	r20, r20
    1ac6:	55 1f       	adc	r21, r21
    1ac8:	44 0f       	add	r20, r20
    1aca:	55 1f       	adc	r21, r21
    1acc:	44 0f       	add	r20, r20
    1ace:	55 1f       	adc	r21, r21
    1ad0:	48 0f       	add	r20, r24
    1ad2:	59 1f       	adc	r21, r25
    1ad4:	da 01       	movw	r26, r20
    1ad6:	aa 51       	subi	r26, 0x1A	; 26
    1ad8:	b9 4f       	sbci	r27, 0xF9	; 249
    1ada:	11 96       	adiw	r26, 0x01	; 1
    1adc:	ed 91       	ld	r30, X+
    1ade:	fc 91       	ld	r31, X
    1ae0:	12 97       	sbiw	r26, 0x02	; 2
    1ae2:	02 80       	ldd	r0, Z+2	; 0x02
    1ae4:	f3 81       	ldd	r31, Z+3	; 0x03
    1ae6:	e0 2d       	mov	r30, r0
    1ae8:	12 96       	adiw	r26, 0x02	; 2
    1aea:	fc 93       	st	X, r31
    1aec:	ee 93       	st	-X, r30
    1aee:	11 97       	sbiw	r26, 0x01	; 1
    1af0:	47 51       	subi	r20, 0x17	; 23
    1af2:	59 4f       	sbci	r21, 0xF9	; 249
    1af4:	e4 17       	cp	r30, r20
    1af6:	f5 07       	cpc	r31, r21
    1af8:	29 f4       	brne	.+10     	; 0x1b04 <vTaskSwitchContext+0xaa>
    1afa:	42 81       	ldd	r20, Z+2	; 0x02
    1afc:	53 81       	ldd	r21, Z+3	; 0x03
    1afe:	fd 01       	movw	r30, r26
    1b00:	52 83       	std	Z+2, r21	; 0x02
    1b02:	41 83       	std	Z+1, r20	; 0x01
    1b04:	fc 01       	movw	r30, r24
    1b06:	ee 0f       	add	r30, r30
    1b08:	ff 1f       	adc	r31, r31
    1b0a:	ee 0f       	add	r30, r30
    1b0c:	ff 1f       	adc	r31, r31
    1b0e:	ee 0f       	add	r30, r30
    1b10:	ff 1f       	adc	r31, r31
    1b12:	8e 0f       	add	r24, r30
    1b14:	9f 1f       	adc	r25, r31
    1b16:	fc 01       	movw	r30, r24
    1b18:	ea 51       	subi	r30, 0x1A	; 26
    1b1a:	f9 4f       	sbci	r31, 0xF9	; 249
    1b1c:	01 80       	ldd	r0, Z+1	; 0x01
    1b1e:	f2 81       	ldd	r31, Z+2	; 0x02
    1b20:	e0 2d       	mov	r30, r0
    1b22:	86 81       	ldd	r24, Z+6	; 0x06
    1b24:	97 81       	ldd	r25, Z+7	; 0x07
    1b26:	90 93 0b 07 	sts	0x070B, r25	; 0x80070b <pxCurrentTCB+0x1>
    1b2a:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <pxCurrentTCB>
    1b2e:	20 93 b9 06 	sts	0x06B9, r18	; 0x8006b9 <uxTopReadyPriority>
    1b32:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    1b36:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1b3a:	85 a1       	ldd	r24, Z+37	; 0x25
    1b3c:	0e 94 9d 03 	call	0x73a	; 0x73a <switch_in>
    1b40:	08 95       	ret

00001b42 <vTaskPlaceOnEventList>:
    1b42:	cf 93       	push	r28
    1b44:	df 93       	push	r29
    1b46:	eb 01       	movw	r28, r22
    1b48:	20 91 0a 07 	lds	r18, 0x070A	; 0x80070a <pxCurrentTCB>
    1b4c:	30 91 0b 07 	lds	r19, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1b50:	b9 01       	movw	r22, r18
    1b52:	64 5f       	subi	r22, 0xF4	; 244
    1b54:	7f 4f       	sbci	r23, 0xFF	; 255
    1b56:	0e 94 22 04 	call	0x844	; 0x844 <vListInsert>
    1b5a:	61 e0       	ldi	r22, 0x01	; 1
    1b5c:	ce 01       	movw	r24, r28
    1b5e:	0e 94 06 0a 	call	0x140c	; 0x140c <prvAddCurrentTaskToDelayedList>
    1b62:	df 91       	pop	r29
    1b64:	cf 91       	pop	r28
    1b66:	08 95       	ret

00001b68 <xTaskRemoveFromEventList>:
    1b68:	0f 93       	push	r16
    1b6a:	1f 93       	push	r17
    1b6c:	cf 93       	push	r28
    1b6e:	df 93       	push	r29
    1b70:	dc 01       	movw	r26, r24
    1b72:	15 96       	adiw	r26, 0x05	; 5
    1b74:	ed 91       	ld	r30, X+
    1b76:	fc 91       	ld	r31, X
    1b78:	16 97       	sbiw	r26, 0x06	; 6
    1b7a:	c6 81       	ldd	r28, Z+6	; 0x06
    1b7c:	d7 81       	ldd	r29, Z+7	; 0x07
    1b7e:	8e 01       	movw	r16, r28
    1b80:	04 5f       	subi	r16, 0xF4	; 244
    1b82:	1f 4f       	sbci	r17, 0xFF	; 255
    1b84:	c8 01       	movw	r24, r16
    1b86:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    1b8a:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <uxSchedulerSuspended>
    1b8e:	81 11       	cpse	r24, r1
    1b90:	1c c0       	rjmp	.+56     	; 0x1bca <xTaskRemoveFromEventList+0x62>
    1b92:	0a 50       	subi	r16, 0x0A	; 10
    1b94:	11 09       	sbc	r17, r1
    1b96:	c8 01       	movw	r24, r16
    1b98:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
    1b9c:	2e 89       	ldd	r18, Y+22	; 0x16
    1b9e:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <uxTopReadyPriority>
    1ba2:	82 17       	cp	r24, r18
    1ba4:	10 f4       	brcc	.+4      	; 0x1baa <xTaskRemoveFromEventList+0x42>
    1ba6:	20 93 b9 06 	sts	0x06B9, r18	; 0x8006b9 <uxTopReadyPriority>
    1baa:	30 e0       	ldi	r19, 0x00	; 0
    1bac:	c9 01       	movw	r24, r18
    1bae:	88 0f       	add	r24, r24
    1bb0:	99 1f       	adc	r25, r25
    1bb2:	88 0f       	add	r24, r24
    1bb4:	99 1f       	adc	r25, r25
    1bb6:	88 0f       	add	r24, r24
    1bb8:	99 1f       	adc	r25, r25
    1bba:	82 0f       	add	r24, r18
    1bbc:	93 1f       	adc	r25, r19
    1bbe:	b8 01       	movw	r22, r16
    1bc0:	8a 51       	subi	r24, 0x1A	; 26
    1bc2:	99 4f       	sbci	r25, 0xF9	; 249
    1bc4:	0e 94 01 04 	call	0x802	; 0x802 <vListInsertEnd>
    1bc8:	05 c0       	rjmp	.+10     	; 0x1bd4 <xTaskRemoveFromEventList+0x6c>
    1bca:	b8 01       	movw	r22, r16
    1bcc:	87 ec       	ldi	r24, 0xC7	; 199
    1bce:	96 e0       	ldi	r25, 0x06	; 6
    1bd0:	0e 94 01 04 	call	0x802	; 0x802 <vListInsertEnd>
    1bd4:	e0 91 0a 07 	lds	r30, 0x070A	; 0x80070a <pxCurrentTCB>
    1bd8:	f0 91 0b 07 	lds	r31, 0x070B	; 0x80070b <pxCurrentTCB+0x1>
    1bdc:	9e 89       	ldd	r25, Y+22	; 0x16
    1bde:	86 89       	ldd	r24, Z+22	; 0x16
    1be0:	89 17       	cp	r24, r25
    1be2:	20 f4       	brcc	.+8      	; 0x1bec <xTaskRemoveFromEventList+0x84>
    1be4:	81 e0       	ldi	r24, 0x01	; 1
    1be6:	80 93 b6 06 	sts	0x06B6, r24	; 0x8006b6 <xYieldPending>
    1bea:	01 c0       	rjmp	.+2      	; 0x1bee <xTaskRemoveFromEventList+0x86>
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	df 91       	pop	r29
    1bf0:	cf 91       	pop	r28
    1bf2:	1f 91       	pop	r17
    1bf4:	0f 91       	pop	r16
    1bf6:	08 95       	ret

00001bf8 <vTaskSetTimeOutState>:
    1bf8:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <xNumOfOverflows>
    1bfc:	fc 01       	movw	r30, r24
    1bfe:	20 83       	st	Z, r18
    1c00:	20 91 ba 06 	lds	r18, 0x06BA	; 0x8006ba <xTickCount>
    1c04:	30 91 bb 06 	lds	r19, 0x06BB	; 0x8006bb <xTickCount+0x1>
    1c08:	32 83       	std	Z+2, r19	; 0x02
    1c0a:	21 83       	std	Z+1, r18	; 0x01
    1c0c:	08 95       	ret

00001c0e <xTaskCheckForTimeOut>:
    1c0e:	cf 93       	push	r28
    1c10:	df 93       	push	r29
    1c12:	fc 01       	movw	r30, r24
    1c14:	0f b6       	in	r0, 0x3f	; 63
    1c16:	f8 94       	cli
    1c18:	0f 92       	push	r0
    1c1a:	20 91 ba 06 	lds	r18, 0x06BA	; 0x8006ba <xTickCount>
    1c1e:	30 91 bb 06 	lds	r19, 0x06BB	; 0x8006bb <xTickCount+0x1>
    1c22:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <xNumOfOverflows>
    1c26:	90 81       	ld	r25, Z
    1c28:	98 17       	cp	r25, r24
    1c2a:	29 f0       	breq	.+10     	; 0x1c36 <xTaskCheckForTimeOut+0x28>
    1c2c:	81 81       	ldd	r24, Z+1	; 0x01
    1c2e:	92 81       	ldd	r25, Z+2	; 0x02
    1c30:	28 17       	cp	r18, r24
    1c32:	39 07       	cpc	r19, r25
    1c34:	b0 f4       	brcc	.+44     	; 0x1c62 <xTaskCheckForTimeOut+0x54>
    1c36:	a1 81       	ldd	r26, Z+1	; 0x01
    1c38:	b2 81       	ldd	r27, Z+2	; 0x02
    1c3a:	eb 01       	movw	r28, r22
    1c3c:	48 81       	ld	r20, Y
    1c3e:	59 81       	ldd	r21, Y+1	; 0x01
    1c40:	c9 01       	movw	r24, r18
    1c42:	8a 1b       	sub	r24, r26
    1c44:	9b 0b       	sbc	r25, r27
    1c46:	84 17       	cp	r24, r20
    1c48:	95 07       	cpc	r25, r21
    1c4a:	68 f4       	brcc	.+26     	; 0x1c66 <xTaskCheckForTimeOut+0x58>
    1c4c:	cf 01       	movw	r24, r30
    1c4e:	a2 1b       	sub	r26, r18
    1c50:	b3 0b       	sbc	r27, r19
    1c52:	4a 0f       	add	r20, r26
    1c54:	5b 1f       	adc	r21, r27
    1c56:	59 83       	std	Y+1, r21	; 0x01
    1c58:	48 83       	st	Y, r20
    1c5a:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <vTaskSetTimeOutState>
    1c5e:	80 e0       	ldi	r24, 0x00	; 0
    1c60:	03 c0       	rjmp	.+6      	; 0x1c68 <xTaskCheckForTimeOut+0x5a>
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	01 c0       	rjmp	.+2      	; 0x1c68 <xTaskCheckForTimeOut+0x5a>
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	0f 90       	pop	r0
    1c6a:	0f be       	out	0x3f, r0	; 63
    1c6c:	df 91       	pop	r29
    1c6e:	cf 91       	pop	r28
    1c70:	08 95       	ret

00001c72 <vTaskMissedYield>:
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	80 93 b6 06 	sts	0x06B6, r24	; 0x8006b6 <xYieldPending>
    1c78:	08 95       	ret

00001c7a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1c7a:	0f 93       	push	r16
    1c7c:	1f 93       	push	r17
    1c7e:	cf 93       	push	r28
    1c80:	df 93       	push	r29
    1c82:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1c84:	89 2b       	or	r24, r25
    1c86:	79 f1       	breq	.+94     	; 0x1ce6 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1c88:	84 a1       	ldd	r24, Z+36	; 0x24
    1c8a:	81 50       	subi	r24, 0x01	; 1
    1c8c:	84 a3       	std	Z+36, r24	; 0x24

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1c8e:	26 89       	ldd	r18, Z+22	; 0x16
    1c90:	93 a1       	ldd	r25, Z+35	; 0x23
    1c92:	29 17       	cp	r18, r25
    1c94:	51 f1       	breq	.+84     	; 0x1cea <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1c96:	81 11       	cpse	r24, r1
    1c98:	2a c0       	rjmp	.+84     	; 0x1cee <xTaskPriorityDisinherit+0x74>
    1c9a:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1c9c:	8f 01       	movw	r16, r30
    1c9e:	0e 5f       	subi	r16, 0xFE	; 254
    1ca0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ca2:	c8 01       	movw	r24, r16
    1ca4:	0e 94 53 04 	call	0x8a6	; 0x8a6 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1ca8:	2b a1       	ldd	r18, Y+35	; 0x23
    1caa:	2e 8b       	std	Y+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1cac:	44 e0       	ldi	r20, 0x04	; 4
    1cae:	50 e0       	ldi	r21, 0x00	; 0
    1cb0:	42 1b       	sub	r20, r18
    1cb2:	51 09       	sbc	r21, r1
    1cb4:	5d 87       	std	Y+13, r21	; 0x0d
    1cb6:	4c 87       	std	Y+12, r20	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    1cb8:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <uxTopReadyPriority>
    1cbc:	82 17       	cp	r24, r18
    1cbe:	10 f4       	brcc	.+4      	; 0x1cc4 <xTaskPriorityDisinherit+0x4a>
    1cc0:	20 93 b9 06 	sts	0x06B9, r18	; 0x8006b9 <uxTopReadyPriority>
    1cc4:	30 e0       	ldi	r19, 0x00	; 0
    1cc6:	c9 01       	movw	r24, r18
    1cc8:	88 0f       	add	r24, r24
    1cca:	99 1f       	adc	r25, r25
    1ccc:	88 0f       	add	r24, r24
    1cce:	99 1f       	adc	r25, r25
    1cd0:	88 0f       	add	r24, r24
    1cd2:	99 1f       	adc	r25, r25
    1cd4:	82 0f       	add	r24, r18
    1cd6:	93 1f       	adc	r25, r19
    1cd8:	b8 01       	movw	r22, r16
    1cda:	8a 51       	subi	r24, 0x1A	; 26
    1cdc:	99 4f       	sbci	r25, 0xF9	; 249
    1cde:	0e 94 01 04 	call	0x802	; 0x802 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    1ce2:	81 e0       	ldi	r24, 0x01	; 1
    1ce4:	05 c0       	rjmp	.+10     	; 0x1cf0 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1ce6:	80 e0       	ldi	r24, 0x00	; 0
    1ce8:	03 c0       	rjmp	.+6      	; 0x1cf0 <xTaskPriorityDisinherit+0x76>
    1cea:	80 e0       	ldi	r24, 0x00	; 0
    1cec:	01 c0       	rjmp	.+2      	; 0x1cf0 <xTaskPriorityDisinherit+0x76>
    1cee:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	1f 91       	pop	r17
    1cf6:	0f 91       	pop	r16
    1cf8:	08 95       	ret

00001cfa <__udivmodsi4>:
    1cfa:	a1 e2       	ldi	r26, 0x21	; 33
    1cfc:	1a 2e       	mov	r1, r26
    1cfe:	aa 1b       	sub	r26, r26
    1d00:	bb 1b       	sub	r27, r27
    1d02:	fd 01       	movw	r30, r26
    1d04:	0d c0       	rjmp	.+26     	; 0x1d20 <__udivmodsi4_ep>

00001d06 <__udivmodsi4_loop>:
    1d06:	aa 1f       	adc	r26, r26
    1d08:	bb 1f       	adc	r27, r27
    1d0a:	ee 1f       	adc	r30, r30
    1d0c:	ff 1f       	adc	r31, r31
    1d0e:	a2 17       	cp	r26, r18
    1d10:	b3 07       	cpc	r27, r19
    1d12:	e4 07       	cpc	r30, r20
    1d14:	f5 07       	cpc	r31, r21
    1d16:	20 f0       	brcs	.+8      	; 0x1d20 <__udivmodsi4_ep>
    1d18:	a2 1b       	sub	r26, r18
    1d1a:	b3 0b       	sbc	r27, r19
    1d1c:	e4 0b       	sbc	r30, r20
    1d1e:	f5 0b       	sbc	r31, r21

00001d20 <__udivmodsi4_ep>:
    1d20:	66 1f       	adc	r22, r22
    1d22:	77 1f       	adc	r23, r23
    1d24:	88 1f       	adc	r24, r24
    1d26:	99 1f       	adc	r25, r25
    1d28:	1a 94       	dec	r1
    1d2a:	69 f7       	brne	.-38     	; 0x1d06 <__udivmodsi4_loop>
    1d2c:	60 95       	com	r22
    1d2e:	70 95       	com	r23
    1d30:	80 95       	com	r24
    1d32:	90 95       	com	r25
    1d34:	9b 01       	movw	r18, r22
    1d36:	ac 01       	movw	r20, r24
    1d38:	bd 01       	movw	r22, r26
    1d3a:	cf 01       	movw	r24, r30
    1d3c:	08 95       	ret

00001d3e <malloc>:
    1d3e:	cf 93       	push	r28
    1d40:	df 93       	push	r29
    1d42:	82 30       	cpi	r24, 0x02	; 2
    1d44:	91 05       	cpc	r25, r1
    1d46:	10 f4       	brcc	.+4      	; 0x1d4c <malloc+0xe>
    1d48:	82 e0       	ldi	r24, 0x02	; 2
    1d4a:	90 e0       	ldi	r25, 0x00	; 0
    1d4c:	e0 91 0e 07 	lds	r30, 0x070E	; 0x80070e <__flp>
    1d50:	f0 91 0f 07 	lds	r31, 0x070F	; 0x80070f <__flp+0x1>
    1d54:	20 e0       	ldi	r18, 0x00	; 0
    1d56:	30 e0       	ldi	r19, 0x00	; 0
    1d58:	c0 e0       	ldi	r28, 0x00	; 0
    1d5a:	d0 e0       	ldi	r29, 0x00	; 0
    1d5c:	30 97       	sbiw	r30, 0x00	; 0
    1d5e:	11 f1       	breq	.+68     	; 0x1da4 <malloc+0x66>
    1d60:	40 81       	ld	r20, Z
    1d62:	51 81       	ldd	r21, Z+1	; 0x01
    1d64:	48 17       	cp	r20, r24
    1d66:	59 07       	cpc	r21, r25
    1d68:	c0 f0       	brcs	.+48     	; 0x1d9a <malloc+0x5c>
    1d6a:	48 17       	cp	r20, r24
    1d6c:	59 07       	cpc	r21, r25
    1d6e:	61 f4       	brne	.+24     	; 0x1d88 <malloc+0x4a>
    1d70:	82 81       	ldd	r24, Z+2	; 0x02
    1d72:	93 81       	ldd	r25, Z+3	; 0x03
    1d74:	20 97       	sbiw	r28, 0x00	; 0
    1d76:	19 f0       	breq	.+6      	; 0x1d7e <malloc+0x40>
    1d78:	9b 83       	std	Y+3, r25	; 0x03
    1d7a:	8a 83       	std	Y+2, r24	; 0x02
    1d7c:	2b c0       	rjmp	.+86     	; 0x1dd4 <malloc+0x96>
    1d7e:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <__flp+0x1>
    1d82:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <__flp>
    1d86:	26 c0       	rjmp	.+76     	; 0x1dd4 <malloc+0x96>
    1d88:	21 15       	cp	r18, r1
    1d8a:	31 05       	cpc	r19, r1
    1d8c:	19 f0       	breq	.+6      	; 0x1d94 <malloc+0x56>
    1d8e:	42 17       	cp	r20, r18
    1d90:	53 07       	cpc	r21, r19
    1d92:	18 f4       	brcc	.+6      	; 0x1d9a <malloc+0x5c>
    1d94:	9a 01       	movw	r18, r20
    1d96:	be 01       	movw	r22, r28
    1d98:	df 01       	movw	r26, r30
    1d9a:	ef 01       	movw	r28, r30
    1d9c:	02 80       	ldd	r0, Z+2	; 0x02
    1d9e:	f3 81       	ldd	r31, Z+3	; 0x03
    1da0:	e0 2d       	mov	r30, r0
    1da2:	dc cf       	rjmp	.-72     	; 0x1d5c <malloc+0x1e>
    1da4:	21 15       	cp	r18, r1
    1da6:	31 05       	cpc	r19, r1
    1da8:	09 f1       	breq	.+66     	; 0x1dec <malloc+0xae>
    1daa:	28 1b       	sub	r18, r24
    1dac:	39 0b       	sbc	r19, r25
    1dae:	24 30       	cpi	r18, 0x04	; 4
    1db0:	31 05       	cpc	r19, r1
    1db2:	90 f4       	brcc	.+36     	; 0x1dd8 <malloc+0x9a>
    1db4:	12 96       	adiw	r26, 0x02	; 2
    1db6:	8d 91       	ld	r24, X+
    1db8:	9c 91       	ld	r25, X
    1dba:	13 97       	sbiw	r26, 0x03	; 3
    1dbc:	61 15       	cp	r22, r1
    1dbe:	71 05       	cpc	r23, r1
    1dc0:	21 f0       	breq	.+8      	; 0x1dca <malloc+0x8c>
    1dc2:	fb 01       	movw	r30, r22
    1dc4:	93 83       	std	Z+3, r25	; 0x03
    1dc6:	82 83       	std	Z+2, r24	; 0x02
    1dc8:	04 c0       	rjmp	.+8      	; 0x1dd2 <malloc+0x94>
    1dca:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <__flp+0x1>
    1dce:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <__flp>
    1dd2:	fd 01       	movw	r30, r26
    1dd4:	32 96       	adiw	r30, 0x02	; 2
    1dd6:	44 c0       	rjmp	.+136    	; 0x1e60 <malloc+0x122>
    1dd8:	fd 01       	movw	r30, r26
    1dda:	e2 0f       	add	r30, r18
    1ddc:	f3 1f       	adc	r31, r19
    1dde:	81 93       	st	Z+, r24
    1de0:	91 93       	st	Z+, r25
    1de2:	22 50       	subi	r18, 0x02	; 2
    1de4:	31 09       	sbc	r19, r1
    1de6:	2d 93       	st	X+, r18
    1de8:	3c 93       	st	X, r19
    1dea:	3a c0       	rjmp	.+116    	; 0x1e60 <malloc+0x122>
    1dec:	20 91 0c 07 	lds	r18, 0x070C	; 0x80070c <__brkval>
    1df0:	30 91 0d 07 	lds	r19, 0x070D	; 0x80070d <__brkval+0x1>
    1df4:	23 2b       	or	r18, r19
    1df6:	41 f4       	brne	.+16     	; 0x1e08 <malloc+0xca>
    1df8:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1dfc:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1e00:	30 93 0d 07 	sts	0x070D, r19	; 0x80070d <__brkval+0x1>
    1e04:	20 93 0c 07 	sts	0x070C, r18	; 0x80070c <__brkval>
    1e08:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1e0c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    1e10:	21 15       	cp	r18, r1
    1e12:	31 05       	cpc	r19, r1
    1e14:	41 f4       	brne	.+16     	; 0x1e26 <malloc+0xe8>
    1e16:	2d b7       	in	r18, 0x3d	; 61
    1e18:	3e b7       	in	r19, 0x3e	; 62
    1e1a:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1e1e:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1e22:	24 1b       	sub	r18, r20
    1e24:	35 0b       	sbc	r19, r21
    1e26:	e0 91 0c 07 	lds	r30, 0x070C	; 0x80070c <__brkval>
    1e2a:	f0 91 0d 07 	lds	r31, 0x070D	; 0x80070d <__brkval+0x1>
    1e2e:	e2 17       	cp	r30, r18
    1e30:	f3 07       	cpc	r31, r19
    1e32:	a0 f4       	brcc	.+40     	; 0x1e5c <malloc+0x11e>
    1e34:	2e 1b       	sub	r18, r30
    1e36:	3f 0b       	sbc	r19, r31
    1e38:	28 17       	cp	r18, r24
    1e3a:	39 07       	cpc	r19, r25
    1e3c:	78 f0       	brcs	.+30     	; 0x1e5c <malloc+0x11e>
    1e3e:	ac 01       	movw	r20, r24
    1e40:	4e 5f       	subi	r20, 0xFE	; 254
    1e42:	5f 4f       	sbci	r21, 0xFF	; 255
    1e44:	24 17       	cp	r18, r20
    1e46:	35 07       	cpc	r19, r21
    1e48:	48 f0       	brcs	.+18     	; 0x1e5c <malloc+0x11e>
    1e4a:	4e 0f       	add	r20, r30
    1e4c:	5f 1f       	adc	r21, r31
    1e4e:	50 93 0d 07 	sts	0x070D, r21	; 0x80070d <__brkval+0x1>
    1e52:	40 93 0c 07 	sts	0x070C, r20	; 0x80070c <__brkval>
    1e56:	81 93       	st	Z+, r24
    1e58:	91 93       	st	Z+, r25
    1e5a:	02 c0       	rjmp	.+4      	; 0x1e60 <malloc+0x122>
    1e5c:	e0 e0       	ldi	r30, 0x00	; 0
    1e5e:	f0 e0       	ldi	r31, 0x00	; 0
    1e60:	cf 01       	movw	r24, r30
    1e62:	df 91       	pop	r29
    1e64:	cf 91       	pop	r28
    1e66:	08 95       	ret

00001e68 <free>:
    1e68:	0f 93       	push	r16
    1e6a:	1f 93       	push	r17
    1e6c:	cf 93       	push	r28
    1e6e:	df 93       	push	r29
    1e70:	00 97       	sbiw	r24, 0x00	; 0
    1e72:	09 f4       	brne	.+2      	; 0x1e76 <free+0xe>
    1e74:	8c c0       	rjmp	.+280    	; 0x1f8e <free+0x126>
    1e76:	fc 01       	movw	r30, r24
    1e78:	32 97       	sbiw	r30, 0x02	; 2
    1e7a:	13 82       	std	Z+3, r1	; 0x03
    1e7c:	12 82       	std	Z+2, r1	; 0x02
    1e7e:	00 91 0e 07 	lds	r16, 0x070E	; 0x80070e <__flp>
    1e82:	10 91 0f 07 	lds	r17, 0x070F	; 0x80070f <__flp+0x1>
    1e86:	01 15       	cp	r16, r1
    1e88:	11 05       	cpc	r17, r1
    1e8a:	81 f4       	brne	.+32     	; 0x1eac <free+0x44>
    1e8c:	20 81       	ld	r18, Z
    1e8e:	31 81       	ldd	r19, Z+1	; 0x01
    1e90:	82 0f       	add	r24, r18
    1e92:	93 1f       	adc	r25, r19
    1e94:	20 91 0c 07 	lds	r18, 0x070C	; 0x80070c <__brkval>
    1e98:	30 91 0d 07 	lds	r19, 0x070D	; 0x80070d <__brkval+0x1>
    1e9c:	28 17       	cp	r18, r24
    1e9e:	39 07       	cpc	r19, r25
    1ea0:	79 f5       	brne	.+94     	; 0x1f00 <free+0x98>
    1ea2:	f0 93 0d 07 	sts	0x070D, r31	; 0x80070d <__brkval+0x1>
    1ea6:	e0 93 0c 07 	sts	0x070C, r30	; 0x80070c <__brkval>
    1eaa:	71 c0       	rjmp	.+226    	; 0x1f8e <free+0x126>
    1eac:	d8 01       	movw	r26, r16
    1eae:	40 e0       	ldi	r20, 0x00	; 0
    1eb0:	50 e0       	ldi	r21, 0x00	; 0
    1eb2:	ae 17       	cp	r26, r30
    1eb4:	bf 07       	cpc	r27, r31
    1eb6:	50 f4       	brcc	.+20     	; 0x1ecc <free+0x64>
    1eb8:	12 96       	adiw	r26, 0x02	; 2
    1eba:	2d 91       	ld	r18, X+
    1ebc:	3c 91       	ld	r19, X
    1ebe:	13 97       	sbiw	r26, 0x03	; 3
    1ec0:	ad 01       	movw	r20, r26
    1ec2:	21 15       	cp	r18, r1
    1ec4:	31 05       	cpc	r19, r1
    1ec6:	09 f1       	breq	.+66     	; 0x1f0a <free+0xa2>
    1ec8:	d9 01       	movw	r26, r18
    1eca:	f3 cf       	rjmp	.-26     	; 0x1eb2 <free+0x4a>
    1ecc:	9d 01       	movw	r18, r26
    1ece:	da 01       	movw	r26, r20
    1ed0:	33 83       	std	Z+3, r19	; 0x03
    1ed2:	22 83       	std	Z+2, r18	; 0x02
    1ed4:	60 81       	ld	r22, Z
    1ed6:	71 81       	ldd	r23, Z+1	; 0x01
    1ed8:	86 0f       	add	r24, r22
    1eda:	97 1f       	adc	r25, r23
    1edc:	82 17       	cp	r24, r18
    1ede:	93 07       	cpc	r25, r19
    1ee0:	69 f4       	brne	.+26     	; 0x1efc <free+0x94>
    1ee2:	ec 01       	movw	r28, r24
    1ee4:	28 81       	ld	r18, Y
    1ee6:	39 81       	ldd	r19, Y+1	; 0x01
    1ee8:	26 0f       	add	r18, r22
    1eea:	37 1f       	adc	r19, r23
    1eec:	2e 5f       	subi	r18, 0xFE	; 254
    1eee:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef0:	31 83       	std	Z+1, r19	; 0x01
    1ef2:	20 83       	st	Z, r18
    1ef4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ef8:	93 83       	std	Z+3, r25	; 0x03
    1efa:	82 83       	std	Z+2, r24	; 0x02
    1efc:	45 2b       	or	r20, r21
    1efe:	29 f4       	brne	.+10     	; 0x1f0a <free+0xa2>
    1f00:	f0 93 0f 07 	sts	0x070F, r31	; 0x80070f <__flp+0x1>
    1f04:	e0 93 0e 07 	sts	0x070E, r30	; 0x80070e <__flp>
    1f08:	42 c0       	rjmp	.+132    	; 0x1f8e <free+0x126>
    1f0a:	13 96       	adiw	r26, 0x03	; 3
    1f0c:	fc 93       	st	X, r31
    1f0e:	ee 93       	st	-X, r30
    1f10:	12 97       	sbiw	r26, 0x02	; 2
    1f12:	ed 01       	movw	r28, r26
    1f14:	49 91       	ld	r20, Y+
    1f16:	59 91       	ld	r21, Y+
    1f18:	9e 01       	movw	r18, r28
    1f1a:	24 0f       	add	r18, r20
    1f1c:	35 1f       	adc	r19, r21
    1f1e:	e2 17       	cp	r30, r18
    1f20:	f3 07       	cpc	r31, r19
    1f22:	71 f4       	brne	.+28     	; 0x1f40 <free+0xd8>
    1f24:	80 81       	ld	r24, Z
    1f26:	91 81       	ldd	r25, Z+1	; 0x01
    1f28:	84 0f       	add	r24, r20
    1f2a:	95 1f       	adc	r25, r21
    1f2c:	02 96       	adiw	r24, 0x02	; 2
    1f2e:	11 96       	adiw	r26, 0x01	; 1
    1f30:	9c 93       	st	X, r25
    1f32:	8e 93       	st	-X, r24
    1f34:	82 81       	ldd	r24, Z+2	; 0x02
    1f36:	93 81       	ldd	r25, Z+3	; 0x03
    1f38:	13 96       	adiw	r26, 0x03	; 3
    1f3a:	9c 93       	st	X, r25
    1f3c:	8e 93       	st	-X, r24
    1f3e:	12 97       	sbiw	r26, 0x02	; 2
    1f40:	e0 e0       	ldi	r30, 0x00	; 0
    1f42:	f0 e0       	ldi	r31, 0x00	; 0
    1f44:	d8 01       	movw	r26, r16
    1f46:	12 96       	adiw	r26, 0x02	; 2
    1f48:	8d 91       	ld	r24, X+
    1f4a:	9c 91       	ld	r25, X
    1f4c:	13 97       	sbiw	r26, 0x03	; 3
    1f4e:	00 97       	sbiw	r24, 0x00	; 0
    1f50:	19 f0       	breq	.+6      	; 0x1f58 <free+0xf0>
    1f52:	f8 01       	movw	r30, r16
    1f54:	8c 01       	movw	r16, r24
    1f56:	f6 cf       	rjmp	.-20     	; 0x1f44 <free+0xdc>
    1f58:	8d 91       	ld	r24, X+
    1f5a:	9c 91       	ld	r25, X
    1f5c:	98 01       	movw	r18, r16
    1f5e:	2e 5f       	subi	r18, 0xFE	; 254
    1f60:	3f 4f       	sbci	r19, 0xFF	; 255
    1f62:	82 0f       	add	r24, r18
    1f64:	93 1f       	adc	r25, r19
    1f66:	20 91 0c 07 	lds	r18, 0x070C	; 0x80070c <__brkval>
    1f6a:	30 91 0d 07 	lds	r19, 0x070D	; 0x80070d <__brkval+0x1>
    1f6e:	28 17       	cp	r18, r24
    1f70:	39 07       	cpc	r19, r25
    1f72:	69 f4       	brne	.+26     	; 0x1f8e <free+0x126>
    1f74:	30 97       	sbiw	r30, 0x00	; 0
    1f76:	29 f4       	brne	.+10     	; 0x1f82 <free+0x11a>
    1f78:	10 92 0f 07 	sts	0x070F, r1	; 0x80070f <__flp+0x1>
    1f7c:	10 92 0e 07 	sts	0x070E, r1	; 0x80070e <__flp>
    1f80:	02 c0       	rjmp	.+4      	; 0x1f86 <free+0x11e>
    1f82:	13 82       	std	Z+3, r1	; 0x03
    1f84:	12 82       	std	Z+2, r1	; 0x02
    1f86:	10 93 0d 07 	sts	0x070D, r17	; 0x80070d <__brkval+0x1>
    1f8a:	00 93 0c 07 	sts	0x070C, r16	; 0x80070c <__brkval>
    1f8e:	df 91       	pop	r29
    1f90:	cf 91       	pop	r28
    1f92:	1f 91       	pop	r17
    1f94:	0f 91       	pop	r16
    1f96:	08 95       	ret

00001f98 <memcpy>:
    1f98:	fb 01       	movw	r30, r22
    1f9a:	dc 01       	movw	r26, r24
    1f9c:	02 c0       	rjmp	.+4      	; 0x1fa2 <memcpy+0xa>
    1f9e:	01 90       	ld	r0, Z+
    1fa0:	0d 92       	st	X+, r0
    1fa2:	41 50       	subi	r20, 0x01	; 1
    1fa4:	50 40       	sbci	r21, 0x00	; 0
    1fa6:	d8 f7       	brcc	.-10     	; 0x1f9e <memcpy+0x6>
    1fa8:	08 95       	ret

00001faa <memset>:
    1faa:	dc 01       	movw	r26, r24
    1fac:	01 c0       	rjmp	.+2      	; 0x1fb0 <memset+0x6>
    1fae:	6d 93       	st	X+, r22
    1fb0:	41 50       	subi	r20, 0x01	; 1
    1fb2:	50 40       	sbci	r21, 0x00	; 0
    1fb4:	e0 f7       	brcc	.-8      	; 0x1fae <memset+0x4>
    1fb6:	08 95       	ret

00001fb8 <_exit>:
    1fb8:	f8 94       	cli

00001fba <__stop_program>:
    1fba:	ff cf       	rjmp	.-2      	; 0x1fba <__stop_program>
