
FirstTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800100  0000226c  00002300  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000226c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000662  0080013e  0080013e  0000233e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000233e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002370  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000478  00000000  00000000  000023b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000050ea  00000000  00000000  00002828  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000101b  00000000  00000000  00007912  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002ebd  00000000  00000000  0000892d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e90  00000000  00000000  0000b7ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001955  00000000  00000000  0000c67c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005606  00000000  00000000  0000dfd1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000580  00000000  00000000  000135d7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 a0 06 	jmp	0xd40	; 0xd40 <__vector_13>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 ed 03 	jmp	0x7da	; 0x7da <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 96 07 	jmp	0xf2c	; 0xf2c <__vector_20>
      54:	0c 94 d4 07 	jmp	0xfa8	; 0xfa8 <__vector_21>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 1c 08 	jmp	0x1038	; 0x1038 <__vector_28>
      74:	0c 94 5a 08 	jmp	0x10b4	; 0x10b4 <__vector_29>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec e6       	ldi	r30, 0x6C	; 108
      90:	f2 e2       	ldi	r31, 0x22	; 34
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	ae 33       	cpi	r26, 0x3E	; 62
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	27 e0       	ldi	r18, 0x07	; 7
      a0:	ae e3       	ldi	r26, 0x3E	; 62
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a0 3a       	cpi	r26, 0xA0	; 160
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 9f 03 	call	0x73e	; 0x73e <main>
      b2:	0c 94 34 11 	jmp	0x2268	; 0x2268 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <startup_task>:
	// The parameters are not used
	( void ) pvParameters;

	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1 );
      ba:	61 e0       	ldi	r22, 0x01	; 1
      bc:	70 e0       	ldi	r23, 0x00	; 0
      be:	80 e0       	ldi	r24, 0x00	; 0
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vTaskSetApplicationTaskTag>
	#endif
	
	_x_com_received_chars_queue = xQueueCreate( _COM_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
      c6:	40 e0       	ldi	r20, 0x00	; 0
      c8:	61 e0       	ldi	r22, 0x01	; 1
      ca:	8e e1       	ldi	r24, 0x1E	; 30
      cc:	0e 94 8b 09 	call	0x1316	; 0x1316 <xQueueGenericCreate>
	init_com(_x_com_received_chars_queue);
      d0:	0e 94 d6 03 	call	0x7ac	; 0x7ac <init_com>
	
	// Initialise Mutex
	xMutex = xSemaphoreCreateMutex();
      d4:	81 e0       	ldi	r24, 0x01	; 1
      d6:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <xQueueCreateMutex>
	
	// Initialization of tasks etc. can be done here
	BaseType_t t1 = xTaskCreate(another_task, (const char *)"Another", configMINIMAL_STACK_SIZE, (void *)NULL, 5, NULL);
      da:	e1 2c       	mov	r14, r1
      dc:	f1 2c       	mov	r15, r1
      de:	05 e0       	ldi	r16, 0x05	; 5
      e0:	20 e0       	ldi	r18, 0x00	; 0
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	45 e5       	ldi	r20, 0x55	; 85
      e6:	50 e0       	ldi	r21, 0x00	; 0
      e8:	6e e0       	ldi	r22, 0x0E	; 14
      ea:	71 e0       	ldi	r23, 0x01	; 1
      ec:	82 e4       	ldi	r24, 0x42	; 66
      ee:	92 e0       	ldi	r25, 0x02	; 2
      f0:	0e 94 14 0b 	call	0x1628	; 0x1628 <xTaskCreate>
	BaseType_t t2 = xTaskCreate(obstacles_task, (const char *)"Obstacles", configMINIMAL_STACK_SIZE, (void *)NULL, 4, NULL);
      f4:	04 e0       	ldi	r16, 0x04	; 4
      f6:	20 e0       	ldi	r18, 0x00	; 0
      f8:	30 e0       	ldi	r19, 0x00	; 0
      fa:	45 e5       	ldi	r20, 0x55	; 85
      fc:	50 e0       	ldi	r21, 0x00	; 0
      fe:	66 e1       	ldi	r22, 0x16	; 22
     100:	71 e0       	ldi	r23, 0x01	; 1
     102:	8c e8       	ldi	r24, 0x8C	; 140
     104:	92 e0       	ldi	r25, 0x02	; 2
     106:	0e 94 14 0b 	call	0x1628	; 0x1628 <xTaskCreate>
	
	
	
	// Lets send a start message to the console
	com_send_bytes((uint8_t *)"Then we Start!\n", 15);
     10a:	6f e0       	ldi	r22, 0x0F	; 15
     10c:	80 e2       	ldi	r24, 0x20	; 32
     10e:	91 e0       	ldi	r25, 0x01	; 1
     110:	0e 94 16 04 	call	0x82c	; 0x82c <com_send_bytes>
     114:	ff cf       	rjmp	.-2      	; 0x114 <startup_task+0x5a>

00000116 <update>:
// 			myMatrix[i][j] = 0;
// 		}
// 	}
// }

void update(){
     116:	ef 92       	push	r14
     118:	ff 92       	push	r15
     11a:	0f 93       	push	r16
     11c:	1f 93       	push	r17
     11e:	cf 93       	push	r28
     120:	df 93       	push	r29
     122:	c3 ee       	ldi	r28, 0xE3	; 227
     124:	d2 e0       	ldi	r29, 0x02	; 2
     126:	4b ec       	ldi	r20, 0xCB	; 203
     128:	51 e0       	ldi	r21, 0x01	; 1
     12a:	0f ef       	ldi	r16, 0xFF	; 255
     12c:	12 e0       	ldi	r17, 0x02	; 2
			for (int i = 0; i < 14; i++)
			{
				frame_buf[i] = 0;
				for(int j =0; j < 10 ; j++){
					if(myMatrix[i][j] == 1){
						 frame_buf[i] |= 1<<j;
     12e:	61 e0       	ldi	r22, 0x01	; 1
     130:	70 e0       	ldi	r23, 0x00	; 0
     132:	de 01       	movw	r26, r28
// }

void update(){
			for (int i = 0; i < 14; i++)
			{
				frame_buf[i] = 0;
     134:	19 82       	std	Y+1, r1	; 0x01
     136:	18 82       	st	Y, r1
     138:	fa 01       	movw	r30, r20
				for(int j =0; j < 10 ; j++){
     13a:	80 e0       	ldi	r24, 0x00	; 0
     13c:	90 e0       	ldi	r25, 0x00	; 0
					if(myMatrix[i][j] == 1){
     13e:	21 91       	ld	r18, Z+
     140:	31 91       	ld	r19, Z+
     142:	21 30       	cpi	r18, 0x01	; 1
     144:	31 05       	cpc	r19, r1
     146:	79 f4       	brne	.+30     	; 0x166 <update+0x50>
						 frame_buf[i] |= 1<<j;
     148:	ed 90       	ld	r14, X+
     14a:	fc 90       	ld	r15, X
     14c:	11 97       	sbiw	r26, 0x01	; 1
     14e:	9b 01       	movw	r18, r22
     150:	08 2e       	mov	r0, r24
     152:	02 c0       	rjmp	.+4      	; 0x158 <update+0x42>
     154:	22 0f       	add	r18, r18
     156:	33 1f       	adc	r19, r19
     158:	0a 94       	dec	r0
     15a:	e2 f7       	brpl	.-8      	; 0x154 <update+0x3e>
     15c:	2e 29       	or	r18, r14
     15e:	3f 29       	or	r19, r15
     160:	11 96       	adiw	r26, 0x01	; 1
     162:	3c 93       	st	X, r19
     164:	2e 93       	st	-X, r18

void update(){
			for (int i = 0; i < 14; i++)
			{
				frame_buf[i] = 0;
				for(int j =0; j < 10 ; j++){
     166:	01 96       	adiw	r24, 0x01	; 1
     168:	8a 30       	cpi	r24, 0x0A	; 10
     16a:	91 05       	cpc	r25, r1
     16c:	41 f7       	brne	.-48     	; 0x13e <update+0x28>
     16e:	22 96       	adiw	r28, 0x02	; 2
     170:	4c 5e       	subi	r20, 0xEC	; 236
     172:	5f 4f       	sbci	r21, 0xFF	; 255
// 		}
// 	}
// }

void update(){
			for (int i = 0; i < 14; i++)
     174:	c0 17       	cp	r28, r16
     176:	d1 07       	cpc	r29, r17
     178:	e1 f6       	brne	.-72     	; 0x132 <update+0x1c>
					else {
						
					}				
				}
			}
}
     17a:	df 91       	pop	r29
     17c:	cf 91       	pop	r28
     17e:	1f 91       	pop	r17
     180:	0f 91       	pop	r16
     182:	ff 90       	pop	r15
     184:	ef 90       	pop	r14
     186:	08 95       	ret

00000188 <moveCar>:
	}
}

void moveCar (uint16_t direction, uint16_t car[2]){
	
	switch(direction){
     188:	81 30       	cpi	r24, 0x01	; 1
     18a:	91 05       	cpc	r25, r1
     18c:	09 f4       	brne	.+2      	; 0x190 <moveCar+0x8>
     18e:	62 c0       	rjmp	.+196    	; 0x254 <moveCar+0xcc>
     190:	40 f0       	brcs	.+16     	; 0x1a2 <moveCar+0x1a>
     192:	82 30       	cpi	r24, 0x02	; 2
     194:	91 05       	cpc	r25, r1
     196:	09 f4       	brne	.+2      	; 0x19a <moveCar+0x12>
     198:	bc c0       	rjmp	.+376    	; 0x312 <moveCar+0x18a>
     19a:	03 97       	sbiw	r24, 0x03	; 3
     19c:	09 f4       	brne	.+2      	; 0x1a0 <moveCar+0x18>
     19e:	16 c1       	rjmp	.+556    	; 0x3cc <moveCar+0x244>
     1a0:	08 95       	ret
	case 0: 	
			if((car[1] + 1 <= 9) && myMatrix[car[0]][car[1] + 1] == 0){
     1a2:	db 01       	movw	r26, r22
     1a4:	12 96       	adiw	r26, 0x02	; 2
     1a6:	2d 91       	ld	r18, X+
     1a8:	3c 91       	ld	r19, X
     1aa:	13 97       	sbiw	r26, 0x03	; 3
     1ac:	c9 01       	movw	r24, r18
     1ae:	01 96       	adiw	r24, 0x01	; 1
     1b0:	8a 30       	cpi	r24, 0x0A	; 10
     1b2:	91 05       	cpc	r25, r1
     1b4:	08 f0       	brcs	.+2      	; 0x1b8 <moveCar+0x30>
     1b6:	65 c1       	rjmp	.+714    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
     1b8:	4d 91       	ld	r20, X+
     1ba:	5c 91       	ld	r21, X
     1bc:	da 01       	movw	r26, r20
     1be:	aa 0f       	add	r26, r26
     1c0:	bb 1f       	adc	r27, r27
     1c2:	fa 01       	movw	r30, r20
     1c4:	ee 0f       	add	r30, r30
     1c6:	ff 1f       	adc	r31, r31
     1c8:	ee 0f       	add	r30, r30
     1ca:	ff 1f       	adc	r31, r31
     1cc:	ee 0f       	add	r30, r30
     1ce:	ff 1f       	adc	r31, r31
     1d0:	ea 0f       	add	r30, r26
     1d2:	fb 1f       	adc	r31, r27
     1d4:	e8 0f       	add	r30, r24
     1d6:	f9 1f       	adc	r31, r25
     1d8:	ee 0f       	add	r30, r30
     1da:	ff 1f       	adc	r31, r31
     1dc:	e5 53       	subi	r30, 0x35	; 53
     1de:	fe 4f       	sbci	r31, 0xFE	; 254
     1e0:	80 81       	ld	r24, Z
     1e2:	91 81       	ldd	r25, Z+1	; 0x01
     1e4:	89 2b       	or	r24, r25
     1e6:	09 f0       	breq	.+2      	; 0x1ea <moveCar+0x62>
     1e8:	4c c1       	rjmp	.+664    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
				myMatrix[car[0]][car[1]] = 0;
     1ea:	fd 01       	movw	r30, r26
     1ec:	44 0f       	add	r20, r20
     1ee:	55 1f       	adc	r21, r21
     1f0:	44 0f       	add	r20, r20
     1f2:	55 1f       	adc	r21, r21
     1f4:	44 0f       	add	r20, r20
     1f6:	55 1f       	adc	r21, r21
     1f8:	e4 0f       	add	r30, r20
     1fa:	f5 1f       	adc	r31, r21
     1fc:	e2 0f       	add	r30, r18
     1fe:	f3 1f       	adc	r31, r19
     200:	ee 0f       	add	r30, r30
     202:	ff 1f       	adc	r31, r31
     204:	e5 53       	subi	r30, 0x35	; 53
     206:	fe 4f       	sbci	r31, 0xFE	; 254
     208:	11 82       	std	Z+1, r1	; 0x01
     20a:	10 82       	st	Z, r1
				myMatrix[car[0]][++car[1]] = 1;
     20c:	fb 01       	movw	r30, r22
     20e:	20 81       	ld	r18, Z
     210:	31 81       	ldd	r19, Z+1	; 0x01
     212:	82 81       	ldd	r24, Z+2	; 0x02
     214:	93 81       	ldd	r25, Z+3	; 0x03
     216:	01 96       	adiw	r24, 0x01	; 1
     218:	93 83       	std	Z+3, r25	; 0x03
     21a:	82 83       	std	Z+2, r24	; 0x02
     21c:	f9 01       	movw	r30, r18
     21e:	ee 0f       	add	r30, r30
     220:	ff 1f       	adc	r31, r31
     222:	22 0f       	add	r18, r18
     224:	33 1f       	adc	r19, r19
     226:	22 0f       	add	r18, r18
     228:	33 1f       	adc	r19, r19
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	e2 0f       	add	r30, r18
     230:	f3 1f       	adc	r31, r19
     232:	e8 0f       	add	r30, r24
     234:	f9 1f       	adc	r31, r25
     236:	ee 0f       	add	r30, r30
     238:	ff 1f       	adc	r31, r31
     23a:	e5 53       	subi	r30, 0x35	; 53
     23c:	fe 4f       	sbci	r31, 0xFE	; 254
     23e:	81 e0       	ldi	r24, 0x01	; 1
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	91 83       	std	Z+1, r25	; 0x01
     244:	80 83       	st	Z, r24
				update();
     246:	0e 94 8b 00 	call	0x116	; 0x116 <update>
				vTaskDelay(200);}
     24a:	88 ec       	ldi	r24, 0xC8	; 200
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskDelay>
     252:	08 95       	ret
    break;
	
	
	case 1:
			if(car[1] >= 1 && myMatrix[car[0]][car[1] - 1] == 0){
     254:	db 01       	movw	r26, r22
     256:	12 96       	adiw	r26, 0x02	; 2
     258:	2d 91       	ld	r18, X+
     25a:	3c 91       	ld	r19, X
     25c:	13 97       	sbiw	r26, 0x03	; 3
     25e:	21 15       	cp	r18, r1
     260:	31 05       	cpc	r19, r1
     262:	09 f4       	brne	.+2      	; 0x266 <moveCar+0xde>
     264:	0e c1       	rjmp	.+540    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
     266:	4d 91       	ld	r20, X+
     268:	5c 91       	ld	r21, X
     26a:	11 97       	sbiw	r26, 0x01	; 1
     26c:	fa 01       	movw	r30, r20
     26e:	ee 0f       	add	r30, r30
     270:	ff 1f       	adc	r31, r31
     272:	ca 01       	movw	r24, r20
     274:	88 0f       	add	r24, r24
     276:	99 1f       	adc	r25, r25
     278:	88 0f       	add	r24, r24
     27a:	99 1f       	adc	r25, r25
     27c:	88 0f       	add	r24, r24
     27e:	99 1f       	adc	r25, r25
     280:	e8 0f       	add	r30, r24
     282:	f9 1f       	adc	r31, r25
     284:	c9 01       	movw	r24, r18
     286:	01 97       	sbiw	r24, 0x01	; 1
     288:	e8 0f       	add	r30, r24
     28a:	f9 1f       	adc	r31, r25
     28c:	ee 0f       	add	r30, r30
     28e:	ff 1f       	adc	r31, r31
     290:	e5 53       	subi	r30, 0x35	; 53
     292:	fe 4f       	sbci	r31, 0xFE	; 254
     294:	80 81       	ld	r24, Z
     296:	91 81       	ldd	r25, Z+1	; 0x01
     298:	89 2b       	or	r24, r25
     29a:	09 f0       	breq	.+2      	; 0x29e <moveCar+0x116>
     29c:	f2 c0       	rjmp	.+484    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
				myMatrix[car[0]][car[1]] = 0;
     29e:	fa 01       	movw	r30, r20
     2a0:	ee 0f       	add	r30, r30
     2a2:	ff 1f       	adc	r31, r31
     2a4:	44 0f       	add	r20, r20
     2a6:	55 1f       	adc	r21, r21
     2a8:	44 0f       	add	r20, r20
     2aa:	55 1f       	adc	r21, r21
     2ac:	44 0f       	add	r20, r20
     2ae:	55 1f       	adc	r21, r21
     2b0:	e4 0f       	add	r30, r20
     2b2:	f5 1f       	adc	r31, r21
     2b4:	e2 0f       	add	r30, r18
     2b6:	f3 1f       	adc	r31, r19
     2b8:	ee 0f       	add	r30, r30
     2ba:	ff 1f       	adc	r31, r31
     2bc:	e5 53       	subi	r30, 0x35	; 53
     2be:	fe 4f       	sbci	r31, 0xFE	; 254
     2c0:	11 82       	std	Z+1, r1	; 0x01
     2c2:	10 82       	st	Z, r1
				--car[1];
     2c4:	12 96       	adiw	r26, 0x02	; 2
     2c6:	8d 91       	ld	r24, X+
     2c8:	9c 91       	ld	r25, X
     2ca:	13 97       	sbiw	r26, 0x03	; 3
     2cc:	01 97       	sbiw	r24, 0x01	; 1
     2ce:	13 96       	adiw	r26, 0x03	; 3
     2d0:	9c 93       	st	X, r25
     2d2:	8e 93       	st	-X, r24
     2d4:	12 97       	sbiw	r26, 0x02	; 2
				myMatrix[car[0]][car[1]] = 1;
     2d6:	2d 91       	ld	r18, X+
     2d8:	3c 91       	ld	r19, X
     2da:	f9 01       	movw	r30, r18
     2dc:	ee 0f       	add	r30, r30
     2de:	ff 1f       	adc	r31, r31
     2e0:	22 0f       	add	r18, r18
     2e2:	33 1f       	adc	r19, r19
     2e4:	22 0f       	add	r18, r18
     2e6:	33 1f       	adc	r19, r19
     2e8:	22 0f       	add	r18, r18
     2ea:	33 1f       	adc	r19, r19
     2ec:	e2 0f       	add	r30, r18
     2ee:	f3 1f       	adc	r31, r19
     2f0:	e8 0f       	add	r30, r24
     2f2:	f9 1f       	adc	r31, r25
     2f4:	ee 0f       	add	r30, r30
     2f6:	ff 1f       	adc	r31, r31
     2f8:	e5 53       	subi	r30, 0x35	; 53
     2fa:	fe 4f       	sbci	r31, 0xFE	; 254
     2fc:	81 e0       	ldi	r24, 0x01	; 1
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	91 83       	std	Z+1, r25	; 0x01
     302:	80 83       	st	Z, r24
				update();
     304:	0e 94 8b 00 	call	0x116	; 0x116 <update>
				vTaskDelay(200);
     308:	88 ec       	ldi	r24, 0xC8	; 200
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskDelay>
     310:	08 95       	ret
			}
	
	break;
	case 2:
					if((car[0] + 1 <= 13) && myMatrix[car[0] + 1][car[1]] == 0){
     312:	fb 01       	movw	r30, r22
     314:	20 81       	ld	r18, Z
     316:	31 81       	ldd	r19, Z+1	; 0x01
     318:	c9 01       	movw	r24, r18
     31a:	01 96       	adiw	r24, 0x01	; 1
     31c:	8e 30       	cpi	r24, 0x0E	; 14
     31e:	91 05       	cpc	r25, r1
     320:	08 f0       	brcs	.+2      	; 0x324 <moveCar+0x19c>
     322:	af c0       	rjmp	.+350    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
     324:	42 81       	ldd	r20, Z+2	; 0x02
     326:	53 81       	ldd	r21, Z+3	; 0x03
     328:	fc 01       	movw	r30, r24
     32a:	ee 0f       	add	r30, r30
     32c:	ff 1f       	adc	r31, r31
     32e:	88 0f       	add	r24, r24
     330:	99 1f       	adc	r25, r25
     332:	88 0f       	add	r24, r24
     334:	99 1f       	adc	r25, r25
     336:	88 0f       	add	r24, r24
     338:	99 1f       	adc	r25, r25
     33a:	e8 0f       	add	r30, r24
     33c:	f9 1f       	adc	r31, r25
     33e:	e4 0f       	add	r30, r20
     340:	f5 1f       	adc	r31, r21
     342:	ee 0f       	add	r30, r30
     344:	ff 1f       	adc	r31, r31
     346:	e5 53       	subi	r30, 0x35	; 53
     348:	fe 4f       	sbci	r31, 0xFE	; 254
     34a:	80 81       	ld	r24, Z
     34c:	91 81       	ldd	r25, Z+1	; 0x01
     34e:	89 2b       	or	r24, r25
     350:	09 f0       	breq	.+2      	; 0x354 <moveCar+0x1cc>
     352:	97 c0       	rjmp	.+302    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
					myMatrix[car[0]][car[1]] = 0;
     354:	c9 01       	movw	r24, r18
     356:	88 0f       	add	r24, r24
     358:	99 1f       	adc	r25, r25
     35a:	22 0f       	add	r18, r18
     35c:	33 1f       	adc	r19, r19
     35e:	22 0f       	add	r18, r18
     360:	33 1f       	adc	r19, r19
     362:	22 0f       	add	r18, r18
     364:	33 1f       	adc	r19, r19
     366:	28 0f       	add	r18, r24
     368:	39 1f       	adc	r19, r25
     36a:	f9 01       	movw	r30, r18
     36c:	e4 0f       	add	r30, r20
     36e:	f5 1f       	adc	r31, r21
     370:	ee 0f       	add	r30, r30
     372:	ff 1f       	adc	r31, r31
     374:	e5 53       	subi	r30, 0x35	; 53
     376:	fe 4f       	sbci	r31, 0xFE	; 254
     378:	11 82       	std	Z+1, r1	; 0x01
     37a:	10 82       	st	Z, r1
					myMatrix[++car[0]][car[1]] = 1;
     37c:	db 01       	movw	r26, r22
     37e:	8d 91       	ld	r24, X+
     380:	9c 91       	ld	r25, X
     382:	11 97       	sbiw	r26, 0x01	; 1
     384:	01 96       	adiw	r24, 0x01	; 1
     386:	11 96       	adiw	r26, 0x01	; 1
     388:	9c 93       	st	X, r25
     38a:	8e 93       	st	-X, r24
     38c:	12 96       	adiw	r26, 0x02	; 2
     38e:	ed 91       	ld	r30, X+
     390:	fc 91       	ld	r31, X
     392:	13 97       	sbiw	r26, 0x03	; 3
     394:	9c 01       	movw	r18, r24
     396:	22 0f       	add	r18, r18
     398:	33 1f       	adc	r19, r19
     39a:	88 0f       	add	r24, r24
     39c:	99 1f       	adc	r25, r25
     39e:	88 0f       	add	r24, r24
     3a0:	99 1f       	adc	r25, r25
     3a2:	88 0f       	add	r24, r24
     3a4:	99 1f       	adc	r25, r25
     3a6:	82 0f       	add	r24, r18
     3a8:	93 1f       	adc	r25, r19
     3aa:	e8 0f       	add	r30, r24
     3ac:	f9 1f       	adc	r31, r25
     3ae:	ee 0f       	add	r30, r30
     3b0:	ff 1f       	adc	r31, r31
     3b2:	e5 53       	subi	r30, 0x35	; 53
     3b4:	fe 4f       	sbci	r31, 0xFE	; 254
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	91 83       	std	Z+1, r25	; 0x01
     3bc:	80 83       	st	Z, r24
					update();
     3be:	0e 94 8b 00 	call	0x116	; 0x116 <update>
					vTaskDelay(200);
     3c2:	88 ec       	ldi	r24, 0xC8	; 200
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskDelay>
     3ca:	08 95       	ret
				}
	
	break;
	case 3:
					if((car[0] >= 1) && myMatrix[car[0] - 1][car[1]] == 0){
     3cc:	fb 01       	movw	r30, r22
     3ce:	20 81       	ld	r18, Z
     3d0:	31 81       	ldd	r19, Z+1	; 0x01
     3d2:	21 15       	cp	r18, r1
     3d4:	31 05       	cpc	r19, r1
     3d6:	09 f4       	brne	.+2      	; 0x3da <moveCar+0x252>
     3d8:	54 c0       	rjmp	.+168    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
     3da:	42 81       	ldd	r20, Z+2	; 0x02
     3dc:	53 81       	ldd	r21, Z+3	; 0x03
     3de:	c9 01       	movw	r24, r18
     3e0:	01 97       	sbiw	r24, 0x01	; 1
     3e2:	fc 01       	movw	r30, r24
     3e4:	ee 0f       	add	r30, r30
     3e6:	ff 1f       	adc	r31, r31
     3e8:	88 0f       	add	r24, r24
     3ea:	99 1f       	adc	r25, r25
     3ec:	88 0f       	add	r24, r24
     3ee:	99 1f       	adc	r25, r25
     3f0:	88 0f       	add	r24, r24
     3f2:	99 1f       	adc	r25, r25
     3f4:	e8 0f       	add	r30, r24
     3f6:	f9 1f       	adc	r31, r25
     3f8:	e4 0f       	add	r30, r20
     3fa:	f5 1f       	adc	r31, r21
     3fc:	ee 0f       	add	r30, r30
     3fe:	ff 1f       	adc	r31, r31
     400:	e5 53       	subi	r30, 0x35	; 53
     402:	fe 4f       	sbci	r31, 0xFE	; 254
     404:	80 81       	ld	r24, Z
     406:	91 81       	ldd	r25, Z+1	; 0x01
     408:	89 2b       	or	r24, r25
     40a:	d9 f5       	brne	.+118    	; 0x482 <__FUSE_REGION_LENGTH__+0x82>
					myMatrix[car[0]][car[1]] = 0;
     40c:	c9 01       	movw	r24, r18
     40e:	88 0f       	add	r24, r24
     410:	99 1f       	adc	r25, r25
     412:	22 0f       	add	r18, r18
     414:	33 1f       	adc	r19, r19
     416:	22 0f       	add	r18, r18
     418:	33 1f       	adc	r19, r19
     41a:	22 0f       	add	r18, r18
     41c:	33 1f       	adc	r19, r19
     41e:	28 0f       	add	r18, r24
     420:	39 1f       	adc	r19, r25
     422:	f9 01       	movw	r30, r18
     424:	e4 0f       	add	r30, r20
     426:	f5 1f       	adc	r31, r21
     428:	ee 0f       	add	r30, r30
     42a:	ff 1f       	adc	r31, r31
     42c:	e5 53       	subi	r30, 0x35	; 53
     42e:	fe 4f       	sbci	r31, 0xFE	; 254
     430:	11 82       	std	Z+1, r1	; 0x01
     432:	10 82       	st	Z, r1
					myMatrix[--car[0]][car[1]] = 1;
     434:	db 01       	movw	r26, r22
     436:	8d 91       	ld	r24, X+
     438:	9c 91       	ld	r25, X
     43a:	11 97       	sbiw	r26, 0x01	; 1
     43c:	01 97       	sbiw	r24, 0x01	; 1
     43e:	11 96       	adiw	r26, 0x01	; 1
     440:	9c 93       	st	X, r25
     442:	8e 93       	st	-X, r24
     444:	12 96       	adiw	r26, 0x02	; 2
     446:	ed 91       	ld	r30, X+
     448:	fc 91       	ld	r31, X
     44a:	13 97       	sbiw	r26, 0x03	; 3
     44c:	9c 01       	movw	r18, r24
     44e:	22 0f       	add	r18, r18
     450:	33 1f       	adc	r19, r19
     452:	88 0f       	add	r24, r24
     454:	99 1f       	adc	r25, r25
     456:	88 0f       	add	r24, r24
     458:	99 1f       	adc	r25, r25
     45a:	88 0f       	add	r24, r24
     45c:	99 1f       	adc	r25, r25
     45e:	82 0f       	add	r24, r18
     460:	93 1f       	adc	r25, r19
     462:	e8 0f       	add	r30, r24
     464:	f9 1f       	adc	r31, r25
     466:	ee 0f       	add	r30, r30
     468:	ff 1f       	adc	r31, r31
     46a:	e5 53       	subi	r30, 0x35	; 53
     46c:	fe 4f       	sbci	r31, 0xFE	; 254
     46e:	81 e0       	ldi	r24, 0x01	; 1
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	91 83       	std	Z+1, r25	; 0x01
     474:	80 83       	st	Z, r24
					update();
     476:	0e 94 8b 00 	call	0x116	; 0x116 <update>
					vTaskDelay(200);
     47a:	88 ec       	ldi	r24, 0xC8	; 200
     47c:	90 e0       	ldi	r25, 0x00	; 0
     47e:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskDelay>
     482:	08 95       	ret

00000484 <another_task>:
	// The parameters are not used
	( void ) pvParameters;

	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 2 );
     484:	62 e0       	ldi	r22, 0x02	; 2
     486:	70 e0       	ldi	r23, 0x00	; 0
     488:	80 e0       	ldi	r24, 0x00	; 0
     48a:	90 e0       	ldi	r25, 0x00	; 0
     48c:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vTaskSetApplicationTaskTag>
     490:	eb ec       	ldi	r30, 0xCB	; 203
     492:	f1 e0       	ldi	r31, 0x01	; 1
     494:	23 ee       	ldi	r18, 0xE3	; 227
     496:	32 e0       	ldi	r19, 0x02	; 2
     498:	09 c0       	rjmp	.+18     	; 0x4ac <another_task+0x28>
	BaseType_t result = 0;
	uint8_t byte;
		
		for(int i = 0; i < 14; i++){
			for(int j = 0; j < 10; j++){
				myMatrix[i][j] = 0;
     49a:	11 92       	st	Z+, r1
     49c:	11 92       	st	Z+, r1
	
	BaseType_t result = 0;
	uint8_t byte;
		
		for(int i = 0; i < 14; i++){
			for(int j = 0; j < 10; j++){
     49e:	e8 17       	cp	r30, r24
     4a0:	f9 07       	cpc	r31, r25
     4a2:	d9 f7       	brne	.-10     	; 0x49a <another_task+0x16>
     4a4:	fc 01       	movw	r30, r24
	#endif
	
	BaseType_t result = 0;
	uint8_t byte;
		
		for(int i = 0; i < 14; i++){
     4a6:	28 17       	cp	r18, r24
     4a8:	39 07       	cpc	r19, r25
     4aa:	19 f0       	breq	.+6      	; 0x4b2 <another_task+0x2e>
     4ac:	cf 01       	movw	r24, r30
     4ae:	44 96       	adiw	r24, 0x14	; 20
     4b0:	f4 cf       	rjmp	.-24     	; 0x49a <another_task+0x16>
			for(int j = 0; j < 10; j++){
				myMatrix[i][j] = 0;
			}
		}
	car[0] = 6; //column
     4b2:	e8 e9       	ldi	r30, 0x98	; 152
     4b4:	f7 e0       	ldi	r31, 0x07	; 7
     4b6:	86 e0       	ldi	r24, 0x06	; 6
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	91 83       	std	Z+1, r25	; 0x01
     4bc:	80 83       	st	Z, r24
	car[1] = 9; // row
     4be:	89 e0       	ldi	r24, 0x09	; 9
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	93 83       	std	Z+3, r25	; 0x03
     4c4:	82 83       	std	Z+2, r24	; 0x02
	myMatrix[car[0]][car[1]] = 1;
     4c6:	81 e0       	ldi	r24, 0x01	; 1
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	90 93 56 02 	sts	0x0256, r25	; 0x800256 <myMatrix+0x8b>
     4ce:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <myMatrix+0x8a>
	update();
     4d2:	0e 94 8b 00 	call	0x116	; 0x116 <update>
	while(1)
	{	
		//result = xQueueReceive(_x_com_received_chars_queue, &byte, 1000L);
			
    if((~PINC & (1<<PINC0)) != 0){
     4d6:	30 99       	sbic	0x06, 0	; 6
     4d8:	06 c0       	rjmp	.+12     	; 0x4e6 <another_task+0x62>
			moveCar(0, car); //down
     4da:	68 e9       	ldi	r22, 0x98	; 152
     4dc:	77 e0       	ldi	r23, 0x07	; 7
     4de:	80 e0       	ldi	r24, 0x00	; 0
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	0e 94 c4 00 	call	0x188	; 0x188 <moveCar>
		}

	if((~PINC & (1<<PINC1)) != 0){
     4e6:	31 99       	sbic	0x06, 1	; 6
     4e8:	06 c0       	rjmp	.+12     	; 0x4f6 <another_task+0x72>
		moveCar(2, car);// right
     4ea:	68 e9       	ldi	r22, 0x98	; 152
     4ec:	77 e0       	ldi	r23, 0x07	; 7
     4ee:	82 e0       	ldi	r24, 0x02	; 2
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	0e 94 c4 00 	call	0x188	; 0x188 <moveCar>
	}
	if((~PINC & (1<<PINC6)) != 0){
     4f6:	36 99       	sbic	0x06, 6	; 6
     4f8:	06 c0       	rjmp	.+12     	; 0x506 <another_task+0x82>
		moveCar(1, car); //up
     4fa:	68 e9       	ldi	r22, 0x98	; 152
     4fc:	77 e0       	ldi	r23, 0x07	; 7
     4fe:	81 e0       	ldi	r24, 0x01	; 1
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	0e 94 c4 00 	call	0x188	; 0x188 <moveCar>
	}
	if((~PINC & (1<<PINC7)) != 0){
     506:	37 99       	sbic	0x06, 7	; 6
     508:	e6 cf       	rjmp	.-52     	; 0x4d6 <another_task+0x52>
		moveCar(3,car); //left
     50a:	68 e9       	ldi	r22, 0x98	; 152
     50c:	77 e0       	ldi	r23, 0x07	; 7
     50e:	83 e0       	ldi	r24, 0x03	; 3
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	0e 94 c4 00 	call	0x188	; 0x188 <moveCar>
     516:	df cf       	rjmp	.-66     	; 0x4d6 <another_task+0x52>

00000518 <obstacles_task>:
// 								}
// 								
// 							}
// 						}
										
										if(obstacles[car[0]][car[1]-1] == 0){
     518:	0f 2e       	mov	r0, r31
     51a:	f8 e9       	ldi	r31, 0x98	; 152
     51c:	6f 2e       	mov	r6, r31
     51e:	f7 e0       	ldi	r31, 0x07	; 7
     520:	7f 2e       	mov	r7, r31
     522:	f0 2d       	mov	r31, r0
     524:	0f 2e       	mov	r0, r31
     526:	fb ec       	ldi	r31, 0xCB	; 203
     528:	ef 2e       	mov	r14, r31
     52a:	f1 e0       	ldi	r31, 0x01	; 1
     52c:	ff 2e       	mov	r15, r31
     52e:	f0 2d       	mov	r31, r0
													myMatrix[i][1+j] = obstacles[i][j];
												}
											}
											for (int i = 1; i < 14; i++)
											{
												myMatrix[0][0] = rand()%2;
     530:	0f 2e       	mov	r0, r31
     532:	fb ec       	ldi	r31, 0xCB	; 203
     534:	af 2e       	mov	r10, r31
     536:	f1 e0       	ldi	r31, 0x01	; 1
     538:	bf 2e       	mov	r11, r31
     53a:	f0 2d       	mov	r31, r0
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													obstacles[i][j] = myMatrix[i][j];
												}
											}
											myMatrix[car[0]][car[1]] = 1;
     53c:	44 24       	eor	r4, r4
     53e:	43 94       	inc	r4
     540:	51 2c       	mov	r5, r1
// 								}
// 								
// 							}
// 						}
										
										if(obstacles[car[0]][car[1]-1] == 0){
     542:	d3 01       	movw	r26, r6
     544:	8d 91       	ld	r24, X+
     546:	9c 91       	ld	r25, X
     548:	11 97       	sbiw	r26, 0x01	; 1
     54a:	9c 01       	movw	r18, r24
     54c:	22 0f       	add	r18, r18
     54e:	33 1f       	adc	r19, r19
     550:	88 0f       	add	r24, r24
     552:	99 1f       	adc	r25, r25
     554:	88 0f       	add	r24, r24
     556:	99 1f       	adc	r25, r25
     558:	88 0f       	add	r24, r24
     55a:	99 1f       	adc	r25, r25
     55c:	82 0f       	add	r24, r18
     55e:	93 1f       	adc	r25, r19
     560:	12 96       	adiw	r26, 0x02	; 2
     562:	ed 91       	ld	r30, X+
     564:	fc 91       	ld	r31, X
     566:	13 97       	sbiw	r26, 0x03	; 3
     568:	8e 0f       	add	r24, r30
     56a:	9f 1f       	adc	r25, r31
     56c:	fc 01       	movw	r30, r24
     56e:	e2 5c       	subi	r30, 0xC2	; 194
     570:	fe 4f       	sbci	r31, 0xFE	; 254
     572:	80 81       	ld	r24, Z
     574:	81 11       	cpse	r24, r1
     576:	8e c0       	rjmp	.+284    	; 0x694 <obstacles_task+0x17c>
     578:	cf e3       	ldi	r28, 0x3F	; 63
     57a:	d1 e0       	ldi	r29, 0x01	; 1
     57c:	6d ec       	ldi	r22, 0xCD	; 205
     57e:	71 e0       	ldi	r23, 0x01	; 1
     580:	ae 01       	movw	r20, r28
     582:	0e c0       	rjmp	.+28     	; 0x5a0 <obstacles_task+0x88>
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													// 						if(i != car[0] && j != car[1]){
													// 							myMatrix[i][j] = obstacles[i][j];
													// 							}
													myMatrix[i][1+j] = obstacles[i][j];
     584:	81 91       	ld	r24, Z+
     586:	90 e0       	ldi	r25, 0x00	; 0
     588:	8d 93       	st	X+, r24
     58a:	9d 93       	st	X+, r25
										
										if(obstacles[car[0]][car[1]-1] == 0){
											int count = 0;
											uint8_t aux[14][10];
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
     58c:	e2 17       	cp	r30, r18
     58e:	f3 07       	cpc	r31, r19
     590:	c9 f7       	brne	.-14     	; 0x584 <obstacles_task+0x6c>
     592:	46 5f       	subi	r20, 0xF6	; 246
     594:	5f 4f       	sbci	r21, 0xFF	; 255
     596:	6c 5e       	subi	r22, 0xEC	; 236
     598:	7f 4f       	sbci	r23, 0xFF	; 255
// 						}
										
										if(obstacles[car[0]][car[1]-1] == 0){
											int count = 0;
											uint8_t aux[14][10];
											for(int i = 0; i < 14; i++){
     59a:	4e 15       	cp	r20, r14
     59c:	5f 05       	cpc	r21, r15
     59e:	31 f0       	breq	.+12     	; 0x5ac <obstacles_task+0x94>
     5a0:	9a 01       	movw	r18, r20
     5a2:	27 5f       	subi	r18, 0xF7	; 247
     5a4:	3f 4f       	sbci	r19, 0xFF	; 255
										 {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
										 {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
										 {0,0,0,0,0,0,0,0,0,0,0,0,0,0},
										 {0,0,0,0,0,0,0,0,0,0,0,0,0,0}};
//-----------------------------------------
void obstacles_task(void *pvParameters){
     5a6:	db 01       	movw	r26, r22
     5a8:	fa 01       	movw	r30, r20
     5aa:	ec cf       	rjmp	.-40     	; 0x584 <obstacles_task+0x6c>
     5ac:	0f 2e       	mov	r0, r31
     5ae:	ff ed       	ldi	r31, 0xDF	; 223
     5b0:	8f 2e       	mov	r8, r31
     5b2:	f1 e0       	ldi	r31, 0x01	; 1
     5b4:	9f 2e       	mov	r9, r31
     5b6:	f0 2d       	mov	r31, r0
// 						}
										
										if(obstacles[car[0]][car[1]-1] == 0){
											int count = 0;
											uint8_t aux[14][10];
											for(int i = 0; i < 14; i++){
     5b8:	01 e0       	ldi	r16, 0x01	; 1
     5ba:	10 e0       	ldi	r17, 0x00	; 0
     5bc:	c1 2c       	mov	r12, r1
     5be:	d1 2c       	mov	r13, r1
													myMatrix[i][1+j] = obstacles[i][j];
												}
											}
											for (int i = 1; i < 14; i++)
											{
												myMatrix[0][0] = rand()%2;
     5c0:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <rand>
     5c4:	81 70       	andi	r24, 0x01	; 1
     5c6:	90 78       	andi	r25, 0x80	; 128
     5c8:	99 23       	and	r25, r25
     5ca:	24 f4       	brge	.+8      	; 0x5d4 <obstacles_task+0xbc>
     5cc:	01 97       	sbiw	r24, 0x01	; 1
     5ce:	8e 6f       	ori	r24, 0xFE	; 254
     5d0:	9f 6f       	ori	r25, 0xFF	; 255
     5d2:	01 96       	adiw	r24, 0x01	; 1
     5d4:	f5 01       	movw	r30, r10
     5d6:	91 83       	std	Z+1, r25	; 0x01
     5d8:	80 83       	st	Z, r24
												if(count < 2 || i == 13) {
     5da:	f2 e0       	ldi	r31, 0x02	; 2
     5dc:	cf 16       	cp	r12, r31
     5de:	d1 04       	cpc	r13, r1
     5e0:	24 f0       	brlt	.+8      	; 0x5ea <obstacles_task+0xd2>
     5e2:	0d 30       	cpi	r16, 0x0D	; 13
     5e4:	11 05       	cpc	r17, r1
     5e6:	d9 f4       	brne	.+54     	; 0x61e <obstacles_task+0x106>
     5e8:	5c c0       	rjmp	.+184    	; 0x6a2 <obstacles_task+0x18a>
												myMatrix[i][0] = rand()%2;
     5ea:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <rand>
     5ee:	81 70       	andi	r24, 0x01	; 1
     5f0:	90 78       	andi	r25, 0x80	; 128
     5f2:	99 23       	and	r25, r25
     5f4:	24 f4       	brge	.+8      	; 0x5fe <obstacles_task+0xe6>
     5f6:	01 97       	sbiw	r24, 0x01	; 1
     5f8:	8e 6f       	ori	r24, 0xFE	; 254
     5fa:	9f 6f       	ori	r25, 0xFF	; 255
     5fc:	01 96       	adiw	r24, 0x01	; 1
     5fe:	d4 01       	movw	r26, r8
     600:	8d 93       	st	X+, r24
     602:	9c 93       	st	X, r25
													if(myMatrix[i][0] == 1)
     604:	01 97       	sbiw	r24, 0x01	; 1
     606:	19 f4       	brne	.+6      	; 0x60e <obstacles_task+0xf6>
													count++;
     608:	bf ef       	ldi	r27, 0xFF	; 255
     60a:	cb 1a       	sub	r12, r27
     60c:	db 0a       	sbc	r13, r27
													if(i % 4 == 0) count = 0;
     60e:	c8 01       	movw	r24, r16
     610:	83 70       	andi	r24, 0x03	; 3
     612:	99 27       	eor	r25, r25
     614:	89 2b       	or	r24, r25
     616:	31 f4       	brne	.+12     	; 0x624 <obstacles_task+0x10c>
     618:	c1 2c       	mov	r12, r1
     61a:	d1 2c       	mov	r13, r1
     61c:	03 c0       	rjmp	.+6      	; 0x624 <obstacles_task+0x10c>
												}
												else {
												myMatrix[i][0] = 0;
     61e:	f4 01       	movw	r30, r8
     620:	11 82       	std	Z+1, r1	; 0x01
     622:	10 82       	st	Z, r1
													// 							myMatrix[i][j] = obstacles[i][j];
													// 							}
													myMatrix[i][1+j] = obstacles[i][j];
												}
											}
											for (int i = 1; i < 14; i++)
     624:	0f 5f       	subi	r16, 0xFF	; 255
     626:	1f 4f       	sbci	r17, 0xFF	; 255
     628:	f4 e1       	ldi	r31, 0x14	; 20
     62a:	8f 0e       	add	r8, r31
     62c:	91 1c       	adc	r9, r1
     62e:	0e 30       	cpi	r16, 0x0E	; 14
     630:	11 05       	cpc	r17, r1
     632:	31 f6       	brne	.-116    	; 0x5c0 <obstacles_task+0xa8>
     634:	4b ec       	ldi	r20, 0xCB	; 203
     636:	51 e0       	ldi	r21, 0x01	; 1
     638:	0c c0       	rjmp	.+24     	; 0x652 <obstacles_task+0x13a>
												}
												 //column - row
											}
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													obstacles[i][j] = myMatrix[i][j];
     63a:	80 81       	ld	r24, Z
     63c:	32 96       	adiw	r30, 0x02	; 2
     63e:	8d 93       	st	X+, r24
												myMatrix[i][0] = 0;
												}
												 //column - row
											}
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
     640:	2a 17       	cp	r18, r26
     642:	3b 07       	cpc	r19, r27
     644:	d1 f7       	brne	.-12     	; 0x63a <obstacles_task+0x122>
     646:	4c 5e       	subi	r20, 0xEC	; 236
     648:	5f 4f       	sbci	r21, 0xFF	; 255
     64a:	2a 96       	adiw	r28, 0x0a	; 10
												else {
												myMatrix[i][0] = 0;
												}
												 //column - row
											}
											for(int i = 0; i < 14; i++){
     64c:	ce 15       	cp	r28, r14
     64e:	df 05       	cpc	r29, r15
     650:	31 f0       	breq	.+12     	; 0x65e <obstacles_task+0x146>
     652:	9e 01       	movw	r18, r28
     654:	27 5f       	subi	r18, 0xF7	; 247
     656:	3f 4f       	sbci	r19, 0xFF	; 255
												myMatrix[0][0] = rand()%2;
												if(count < 2 || i == 13) {
												myMatrix[i][0] = rand()%2;
													if(myMatrix[i][0] == 1)
													count++;
													if(i % 4 == 0) count = 0;
     658:	de 01       	movw	r26, r28
     65a:	fa 01       	movw	r30, r20
     65c:	ee cf       	rjmp	.-36     	; 0x63a <obstacles_task+0x122>
											for(int i = 0; i < 14; i++){
												for(int j = 0; j < 9; j++){
													obstacles[i][j] = myMatrix[i][j];
												}
											}
											myMatrix[car[0]][car[1]] = 1;
     65e:	d3 01       	movw	r26, r6
     660:	8d 91       	ld	r24, X+
     662:	9c 91       	ld	r25, X
     664:	11 97       	sbiw	r26, 0x01	; 1
     666:	fc 01       	movw	r30, r24
     668:	ee 0f       	add	r30, r30
     66a:	ff 1f       	adc	r31, r31
     66c:	88 0f       	add	r24, r24
     66e:	99 1f       	adc	r25, r25
     670:	88 0f       	add	r24, r24
     672:	99 1f       	adc	r25, r25
     674:	88 0f       	add	r24, r24
     676:	99 1f       	adc	r25, r25
     678:	e8 0f       	add	r30, r24
     67a:	f9 1f       	adc	r31, r25
     67c:	12 96       	adiw	r26, 0x02	; 2
     67e:	8d 91       	ld	r24, X+
     680:	9c 91       	ld	r25, X
     682:	13 97       	sbiw	r26, 0x03	; 3
     684:	e8 0f       	add	r30, r24
     686:	f9 1f       	adc	r31, r25
     688:	ee 0f       	add	r30, r30
     68a:	ff 1f       	adc	r31, r31
     68c:	e5 53       	subi	r30, 0x35	; 53
     68e:	fe 4f       	sbci	r31, 0xFE	; 254
     690:	51 82       	std	Z+1, r5	; 0x01
     692:	40 82       	st	Z, r4
	
	
										}

											update();
     694:	0e 94 8b 00 	call	0x116	; 0x116 <update>
											vTaskDelay(1600);
     698:	80 e4       	ldi	r24, 0x40	; 64
     69a:	96 e0       	ldi	r25, 0x06	; 6
     69c:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vTaskDelay>
					}
     6a0:	50 cf       	rjmp	.-352    	; 0x542 <obstacles_task+0x2a>
											}
											for (int i = 1; i < 14; i++)
											{
												myMatrix[0][0] = rand()%2;
												if(count < 2 || i == 13) {
												myMatrix[i][0] = rand()%2;
     6a2:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <rand>
     6a6:	81 70       	andi	r24, 0x01	; 1
     6a8:	90 78       	andi	r25, 0x80	; 128
     6aa:	99 23       	and	r25, r25
     6ac:	24 f4       	brge	.+8      	; 0x6b6 <obstacles_task+0x19e>
     6ae:	01 97       	sbiw	r24, 0x01	; 1
     6b0:	8e 6f       	ori	r24, 0xFE	; 254
     6b2:	9f 6f       	ori	r25, 0xFF	; 255
     6b4:	01 96       	adiw	r24, 0x01	; 1
     6b6:	f4 01       	movw	r30, r8
     6b8:	91 83       	std	Z+1, r25	; 0x01
     6ba:	80 83       	st	Z, r24
													if(myMatrix[i][0] == 1)
     6bc:	01 97       	sbiw	r24, 0x01	; 1
     6be:	09 f0       	breq	.+2      	; 0x6c2 <obstacles_task+0x1aa>
     6c0:	b1 cf       	rjmp	.-158    	; 0x624 <obstacles_task+0x10c>
     6c2:	a2 cf       	rjmp	.-188    	; 0x608 <obstacles_task+0xf0>

000006c4 <prepare_shiftregister>:

// Prepare shift register setting SER = 1
void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     6c4:	5a 9a       	sbi	0x0b, 2	; 11
     6c6:	08 95       	ret

000006c8 <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     6c8:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     6ca:	5d 98       	cbi	0x0b, 5	; 11
	
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     6cc:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     6ce:	5c 98       	cbi	0x0b, 4	; 11
	
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     6d0:	5a 98       	cbi	0x0b, 2	; 11
     6d2:	08 95       	ret

000006d4 <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     6d4:	80 95       	com	r24
     6d6:	82 b9       	out	0x02, r24	; 2
	
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     6d8:	85 b1       	in	r24, 0x05	; 5
     6da:	83 60       	ori	r24, 0x03	; 3
     6dc:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     6de:	85 b1       	in	r24, 0x05	; 5
     6e0:	93 70       	andi	r25, 0x03	; 3
     6e2:	90 95       	com	r25
     6e4:	89 23       	and	r24, r25
     6e6:	85 b9       	out	0x05, r24	; 5
     6e8:	08 95       	ret

000006ea <handle_display>:
}

//-----------------------------------------
void handle_display(void)
{
     6ea:	cf 93       	push	r28
	static uint8_t col = 0;
	
	if (col == 0)
     6ec:	c0 91 3e 01 	lds	r28, 0x013E	; 0x80013e <__data_end>
     6f0:	c1 11       	cpse	r28, r1
     6f2:	0e c0       	rjmp	.+28     	; 0x710 <handle_display+0x26>
	{
		prepare_shiftregister();
     6f4:	0e 94 62 03 	call	0x6c4	; 0x6c4 <prepare_shiftregister>
	}
	
	load_col_value(frame_buf[col]);
     6f8:	80 91 e3 02 	lds	r24, 0x02E3	; 0x8002e3 <frame_buf>
     6fc:	90 91 e4 02 	lds	r25, 0x02E4	; 0x8002e4 <frame_buf+0x1>
     700:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     704:	0e 94 64 03 	call	0x6c8	; 0x6c8 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     708:	81 e0       	ldi	r24, 0x01	; 1
     70a:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <__data_end>
     70e:	14 c0       	rjmp	.+40     	; 0x738 <handle_display+0x4e>
	if (col == 0)
	{
		prepare_shiftregister();
	}
	
	load_col_value(frame_buf[col]);
     710:	ec 2f       	mov	r30, r28
     712:	f0 e0       	ldi	r31, 0x00	; 0
     714:	ee 0f       	add	r30, r30
     716:	ff 1f       	adc	r31, r31
     718:	ed 51       	subi	r30, 0x1D	; 29
     71a:	fd 4f       	sbci	r31, 0xFD	; 253
     71c:	80 81       	ld	r24, Z
     71e:	91 81       	ldd	r25, Z+1	; 0x01
     720:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     724:	0e 94 64 03 	call	0x6c8	; 0x6c8 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     728:	cf 5f       	subi	r28, 0xFF	; 255
	if (col > 13)
     72a:	ce 30       	cpi	r28, 0x0E	; 14
     72c:	18 f4       	brcc	.+6      	; 0x734 <handle_display+0x4a>
	load_col_value(frame_buf[col]);
	
	clock_shift_register_and_prepare_for_next_col();
	
	// count column up - prepare for next
	col++;
     72e:	c0 93 3e 01 	sts	0x013E, r28	; 0x80013e <__data_end>
     732:	02 c0       	rjmp	.+4      	; 0x738 <handle_display+0x4e>
	if (col > 13)
	{
		col = 0;
     734:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <__data_end>
	}
}
     738:	cf 91       	pop	r28
     73a:	08 95       	ret

0000073c <vApplicationIdleHook>:

//-----------------------------------------
void vApplicationIdleHook( void )
{
     73c:	08 95       	ret

0000073e <main>:

//-----------------------------------------
int main(void)
{
	
	init_board();
     73e:	0e 94 1f 04 	call	0x83e	; 0x83e <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     742:	5e 98       	cbi	0x0b, 6	; 11
	
	//Create task to blink gpio
	BaseType_t t1 = xTaskCreate(startup_task, (const char *)"Startup", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY, NULL);
     744:	e1 2c       	mov	r14, r1
     746:	f1 2c       	mov	r15, r1
     748:	00 e0       	ldi	r16, 0x00	; 0
     74a:	20 e0       	ldi	r18, 0x00	; 0
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	45 e5       	ldi	r20, 0x55	; 85
     750:	50 e0       	ldi	r21, 0x00	; 0
     752:	60 e3       	ldi	r22, 0x30	; 48
     754:	71 e0       	ldi	r23, 0x01	; 1
     756:	8d e5       	ldi	r24, 0x5D	; 93
     758:	90 e0       	ldi	r25, 0x00	; 0
     75a:	0e 94 14 0b 	call	0x1628	; 0x1628 <xTaskCreate>

	// Start the display handler timer
	init_display_timer(handle_display);
     75e:	85 e7       	ldi	r24, 0x75	; 117
     760:	93 e0       	ldi	r25, 0x03	; 3
     762:	0e 94 db 03 	call	0x7b6	; 0x7b6 <init_display_timer>
	
	sei();
     766:	78 94       	sei
	
	//Start the scheduler
	vTaskStartScheduler();
     768:	0e 94 29 0c 	call	0x1852	; 0x1852 <vTaskStartScheduler>
     76c:	ff cf       	rjmp	.-2      	; 0x76c <main+0x2e>

0000076e <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
     772:	00 d0       	rcall	.+0      	; 0x774 <_com_call_back+0x6>
     774:	cd b7       	in	r28, 0x3d	; 61
     776:	de b7       	in	r29, 0x3e	; 62
     778:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     77a:	80 91 47 03 	lds	r24, 0x0347	; 0x800347 <_x_rx_com_queue>
     77e:	90 91 48 03 	lds	r25, 0x0348	; 0x800348 <_x_rx_com_queue+0x1>
     782:	00 97       	sbiw	r24, 0x00	; 0
     784:	71 f0       	breq	.+28     	; 0x7a2 <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     786:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     788:	20 e0       	ldi	r18, 0x00	; 0
     78a:	ae 01       	movw	r20, r28
     78c:	4f 5f       	subi	r20, 0xFF	; 255
     78e:	5f 4f       	sbci	r21, 0xFF	; 255
     790:	be 01       	movw	r22, r28
     792:	6e 5f       	subi	r22, 0xFE	; 254
     794:	7f 4f       	sbci	r23, 0xFF	; 255
     796:	0e 94 77 0a 	call	0x14ee	; 0x14ee <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     79a:	89 81       	ldd	r24, Y+1	; 0x01
     79c:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     79e:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
		}
	}
}
     7a2:	0f 90       	pop	r0
     7a4:	0f 90       	pop	r0
     7a6:	df 91       	pop	r29
     7a8:	cf 91       	pop	r28
     7aa:	08 95       	ret

000007ac <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     7ac:	90 93 48 03 	sts	0x0348, r25	; 0x800348 <_x_rx_com_queue+0x1>
     7b0:	80 93 47 03 	sts	0x0347, r24	; 0x800347 <_x_rx_com_queue>
     7b4:	08 95       	ret

000007b6 <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     7b6:	90 93 46 03 	sts	0x0346, r25	; 0x800346 <cb_ptr+0x1>
     7ba:	80 93 45 03 	sts	0x0345, r24	; 0x800345 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     7be:	8a e0       	ldi	r24, 0x0A	; 10
     7c0:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     7c2:	84 b5       	in	r24, 0x24	; 36
     7c4:	82 60       	ori	r24, 0x02	; 2
     7c6:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     7c8:	ee e6       	ldi	r30, 0x6E	; 110
     7ca:	f0 e0       	ldi	r31, 0x00	; 0
     7cc:	80 81       	ld	r24, Z
     7ce:	82 60       	ori	r24, 0x02	; 2
     7d0:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     7d2:	85 b5       	in	r24, 0x25	; 37
     7d4:	85 60       	ori	r24, 0x05	; 5
     7d6:	85 bd       	out	0x25, r24	; 37
     7d8:	08 95       	ret

000007da <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     7da:	1f 92       	push	r1
     7dc:	0f 92       	push	r0
     7de:	0f b6       	in	r0, 0x3f	; 63
     7e0:	0f 92       	push	r0
     7e2:	11 24       	eor	r1, r1
     7e4:	2f 93       	push	r18
     7e6:	3f 93       	push	r19
     7e8:	4f 93       	push	r20
     7ea:	5f 93       	push	r21
     7ec:	6f 93       	push	r22
     7ee:	7f 93       	push	r23
     7f0:	8f 93       	push	r24
     7f2:	9f 93       	push	r25
     7f4:	af 93       	push	r26
     7f6:	bf 93       	push	r27
     7f8:	ef 93       	push	r30
     7fa:	ff 93       	push	r31
	if (cb_ptr)
     7fc:	e0 91 45 03 	lds	r30, 0x0345	; 0x800345 <cb_ptr>
     800:	f0 91 46 03 	lds	r31, 0x0346	; 0x800346 <cb_ptr+0x1>
     804:	30 97       	sbiw	r30, 0x00	; 0
     806:	09 f0       	breq	.+2      	; 0x80a <__vector_16+0x30>
	{
		cb_ptr();
     808:	09 95       	icall
	}
}
     80a:	ff 91       	pop	r31
     80c:	ef 91       	pop	r30
     80e:	bf 91       	pop	r27
     810:	af 91       	pop	r26
     812:	9f 91       	pop	r25
     814:	8f 91       	pop	r24
     816:	7f 91       	pop	r23
     818:	6f 91       	pop	r22
     81a:	5f 91       	pop	r21
     81c:	4f 91       	pop	r20
     81e:	3f 91       	pop	r19
     820:	2f 91       	pop	r18
     822:	0f 90       	pop	r0
     824:	0f be       	out	0x3f, r0	; 63
     826:	0f 90       	pop	r0
     828:	1f 90       	pop	r1
     82a:	18 95       	reti

0000082c <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     82c:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     82e:	bc 01       	movw	r22, r24
     830:	80 91 49 03 	lds	r24, 0x0349	; 0x800349 <_com_serial_instance>
     834:	90 91 4a 03 	lds	r25, 0x034A	; 0x80034a <_com_serial_instance+0x1>
     838:	0e 94 53 07 	call	0xea6	; 0xea6 <serial_send_bytes>
     83c:	08 95       	ret

0000083e <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     83e:	8f 92       	push	r8
     840:	9f 92       	push	r9
     842:	af 92       	push	r10
     844:	bf 92       	push	r11
     846:	cf 92       	push	r12
     848:	df 92       	push	r13
     84a:	ef 92       	push	r14
     84c:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     84e:	82 e2       	ldi	r24, 0x22	; 34
     850:	93 e0       	ldi	r25, 0x03	; 3
     852:	0e 94 78 04 	call	0x8f0	; 0x8f0 <buffer_init>
	buffer_init(&_com_tx_buffer);
     856:	8f ef       	ldi	r24, 0xFF	; 255
     858:	92 e0       	ldi	r25, 0x02	; 2
     85a:	0e 94 78 04 	call	0x8f0	; 0x8f0 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     85e:	0f 2e       	mov	r0, r31
     860:	f7 eb       	ldi	r31, 0xB7	; 183
     862:	8f 2e       	mov	r8, r31
     864:	f3 e0       	ldi	r31, 0x03	; 3
     866:	9f 2e       	mov	r9, r31
     868:	f0 2d       	mov	r31, r0
     86a:	0f 2e       	mov	r0, r31
     86c:	ff ef       	ldi	r31, 0xFF	; 255
     86e:	af 2e       	mov	r10, r31
     870:	f2 e0       	ldi	r31, 0x02	; 2
     872:	bf 2e       	mov	r11, r31
     874:	f0 2d       	mov	r31, r0
     876:	0f 2e       	mov	r0, r31
     878:	f2 e2       	ldi	r31, 0x22	; 34
     87a:	cf 2e       	mov	r12, r31
     87c:	f3 e0       	ldi	r31, 0x03	; 3
     87e:	df 2e       	mov	r13, r31
     880:	f0 2d       	mov	r31, r0
     882:	e1 2c       	mov	r14, r1
     884:	00 e0       	ldi	r16, 0x00	; 0
     886:	23 e0       	ldi	r18, 0x03	; 3
     888:	40 e0       	ldi	r20, 0x00	; 0
     88a:	52 ec       	ldi	r21, 0xC2	; 194
     88c:	61 e0       	ldi	r22, 0x01	; 1
     88e:	70 e0       	ldi	r23, 0x00	; 0
     890:	80 e0       	ldi	r24, 0x00	; 0
     892:	0e 94 d9 06 	call	0xdb2	; 0xdb2 <serial_new_instance>
     896:	90 93 4a 03 	sts	0x034A, r25	; 0x80034a <_com_serial_instance+0x1>
     89a:	80 93 49 03 	sts	0x0349, r24	; 0x800349 <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     89e:	88 b1       	in	r24, 0x08	; 8
     8a0:	83 6c       	ori	r24, 0xC3	; 195
     8a2:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     8a4:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     8a6:	8a b1       	in	r24, 0x0a	; 10
     8a8:	84 67       	ori	r24, 0x74	; 116
     8aa:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     8ac:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     8ae:	81 b1       	in	r24, 0x01	; 1
     8b0:	8f ef       	ldi	r24, 0xFF	; 255
     8b2:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     8b4:	84 b1       	in	r24, 0x04	; 4
     8b6:	83 60       	ori	r24, 0x03	; 3
     8b8:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     8ba:	84 b1       	in	r24, 0x04	; 4
     8bc:	8c 63       	ori	r24, 0x3C	; 60
     8be:	84 b9       	out	0x04, r24	; 4
}
     8c0:	0f 91       	pop	r16
     8c2:	ef 90       	pop	r14
     8c4:	df 90       	pop	r13
     8c6:	cf 90       	pop	r12
     8c8:	bf 90       	pop	r11
     8ca:	af 90       	pop	r10
     8cc:	9f 90       	pop	r9
     8ce:	8f 90       	pop	r8
     8d0:	08 95       	ret

000008d2 <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     8d2:	95 b1       	in	r25, 0x05	; 5
     8d4:	93 7c       	andi	r25, 0xC3	; 195
     8d6:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     8d8:	25 b1       	in	r18, 0x05	; 5
     8da:	34 e0       	ldi	r19, 0x04	; 4
     8dc:	83 9f       	mul	r24, r19
     8de:	c0 01       	movw	r24, r0
     8e0:	11 24       	eor	r1, r1
     8e2:	82 2b       	or	r24, r18
     8e4:	85 b9       	out	0x05, r24	; 5
     8e6:	08 95       	ret

000008e8 <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     8e8:	85 b1       	in	r24, 0x05	; 5
     8ea:	83 7c       	andi	r24, 0xC3	; 195
     8ec:	85 b9       	out	0x05, r24	; 5
     8ee:	08 95       	ret

000008f0 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     8f0:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     8f2:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     8f4:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     8f6:	12 a2       	std	Z+34, r1	; 0x22
     8f8:	08 95       	ret

000008fa <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     8fa:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     8fc:	82 a1       	ldd	r24, Z+34	; 0x22
     8fe:	88 23       	and	r24, r24
     900:	d9 f0       	breq	.+54     	; 0x938 <__stack+0x39>
		*item = buffer->storage[buffer->out_i];
     902:	81 a1       	ldd	r24, Z+33	; 0x21
     904:	df 01       	movw	r26, r30
     906:	a8 0f       	add	r26, r24
     908:	b1 1d       	adc	r27, r1
     90a:	8c 91       	ld	r24, X
     90c:	db 01       	movw	r26, r22
     90e:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     910:	21 a1       	ldd	r18, Z+33	; 0x21
     912:	30 e0       	ldi	r19, 0x00	; 0
     914:	2f 5f       	subi	r18, 0xFF	; 255
     916:	3f 4f       	sbci	r19, 0xFF	; 255
     918:	2f 71       	andi	r18, 0x1F	; 31
     91a:	30 78       	andi	r19, 0x80	; 128
     91c:	33 23       	and	r19, r19
     91e:	34 f4       	brge	.+12     	; 0x92c <__stack+0x2d>
     920:	21 50       	subi	r18, 0x01	; 1
     922:	31 09       	sbc	r19, r1
     924:	20 6e       	ori	r18, 0xE0	; 224
     926:	3f 6f       	ori	r19, 0xFF	; 255
     928:	2f 5f       	subi	r18, 0xFF	; 255
     92a:	3f 4f       	sbci	r19, 0xFF	; 255
     92c:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     92e:	82 a1       	ldd	r24, Z+34	; 0x22
     930:	81 50       	subi	r24, 0x01	; 1
     932:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     934:	80 e0       	ldi	r24, 0x00	; 0
     936:	08 95       	ret
	}
	return BUFFER_EMPTY;
     938:	81 e0       	ldi	r24, 0x01	; 1
}
     93a:	08 95       	ret

0000093c <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     93c:	fc 01       	movw	r30, r24
     93e:	42 a1       	ldd	r20, Z+34	; 0x22
     940:	40 32       	cpi	r20, 0x20	; 32
     942:	b8 f4       	brcc	.+46     	; 0x972 <buffer_put_item+0x36>
		buffer->storage[buffer->in_i] = item;
     944:	20 a1       	ldd	r18, Z+32	; 0x20
     946:	30 e0       	ldi	r19, 0x00	; 0
     948:	e2 0f       	add	r30, r18
     94a:	f3 1f       	adc	r31, r19
     94c:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     94e:	2f 5f       	subi	r18, 0xFF	; 255
     950:	3f 4f       	sbci	r19, 0xFF	; 255
     952:	2f 71       	andi	r18, 0x1F	; 31
     954:	30 78       	andi	r19, 0x80	; 128
     956:	33 23       	and	r19, r19
     958:	34 f4       	brge	.+12     	; 0x966 <buffer_put_item+0x2a>
     95a:	21 50       	subi	r18, 0x01	; 1
     95c:	31 09       	sbc	r19, r1
     95e:	20 6e       	ori	r18, 0xE0	; 224
     960:	3f 6f       	ori	r19, 0xFF	; 255
     962:	2f 5f       	subi	r18, 0xFF	; 255
     964:	3f 4f       	sbci	r19, 0xFF	; 255
     966:	fc 01       	movw	r30, r24
     968:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     96a:	4f 5f       	subi	r20, 0xFF	; 255
     96c:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	08 95       	ret
	}
	return BUFFER_FULL;
     972:	82 e0       	ldi	r24, 0x02	; 2
}
     974:	08 95       	ret

00000976 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     976:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     978:	03 96       	adiw	r24, 0x03	; 3
     97a:	92 83       	std	Z+2, r25	; 0x02
     97c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     97e:	2f ef       	ldi	r18, 0xFF	; 255
     980:	3f ef       	ldi	r19, 0xFF	; 255
     982:	34 83       	std	Z+4, r19	; 0x04
     984:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     986:	96 83       	std	Z+6, r25	; 0x06
     988:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     98a:	90 87       	std	Z+8, r25	; 0x08
     98c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     98e:	10 82       	st	Z, r1
     990:	08 95       	ret

00000992 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     992:	fc 01       	movw	r30, r24
     994:	11 86       	std	Z+9, r1	; 0x09
     996:	10 86       	std	Z+8, r1	; 0x08
     998:	08 95       	ret

0000099a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	9c 01       	movw	r18, r24
     9a0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9a2:	dc 01       	movw	r26, r24
     9a4:	11 96       	adiw	r26, 0x01	; 1
     9a6:	cd 91       	ld	r28, X+
     9a8:	dc 91       	ld	r29, X
     9aa:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9ac:	d3 83       	std	Z+3, r29	; 0x03
     9ae:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9b0:	8c 81       	ldd	r24, Y+4	; 0x04
     9b2:	9d 81       	ldd	r25, Y+5	; 0x05
     9b4:	95 83       	std	Z+5, r25	; 0x05
     9b6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9b8:	8c 81       	ldd	r24, Y+4	; 0x04
     9ba:	9d 81       	ldd	r25, Y+5	; 0x05
     9bc:	dc 01       	movw	r26, r24
     9be:	13 96       	adiw	r26, 0x03	; 3
     9c0:	7c 93       	st	X, r23
     9c2:	6e 93       	st	-X, r22
     9c4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9c6:	7d 83       	std	Y+5, r23	; 0x05
     9c8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9ca:	31 87       	std	Z+9, r19	; 0x09
     9cc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     9ce:	f9 01       	movw	r30, r18
     9d0:	80 81       	ld	r24, Z
     9d2:	8f 5f       	subi	r24, 0xFF	; 255
     9d4:	80 83       	st	Z, r24
}
     9d6:	df 91       	pop	r29
     9d8:	cf 91       	pop	r28
     9da:	08 95       	ret

000009dc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9dc:	cf 93       	push	r28
     9de:	df 93       	push	r29
     9e0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     9e2:	48 81       	ld	r20, Y
     9e4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9e6:	4f 3f       	cpi	r20, 0xFF	; 255
     9e8:	2f ef       	ldi	r18, 0xFF	; 255
     9ea:	52 07       	cpc	r21, r18
     9ec:	21 f4       	brne	.+8      	; 0x9f6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9ee:	fc 01       	movw	r30, r24
     9f0:	a7 81       	ldd	r26, Z+7	; 0x07
     9f2:	b0 85       	ldd	r27, Z+8	; 0x08
     9f4:	0d c0       	rjmp	.+26     	; 0xa10 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9f6:	dc 01       	movw	r26, r24
     9f8:	13 96       	adiw	r26, 0x03	; 3
     9fa:	01 c0       	rjmp	.+2      	; 0x9fe <vListInsert+0x22>
     9fc:	df 01       	movw	r26, r30
     9fe:	12 96       	adiw	r26, 0x02	; 2
     a00:	ed 91       	ld	r30, X+
     a02:	fc 91       	ld	r31, X
     a04:	13 97       	sbiw	r26, 0x03	; 3
     a06:	20 81       	ld	r18, Z
     a08:	31 81       	ldd	r19, Z+1	; 0x01
     a0a:	42 17       	cp	r20, r18
     a0c:	53 07       	cpc	r21, r19
     a0e:	b0 f7       	brcc	.-20     	; 0x9fc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a10:	12 96       	adiw	r26, 0x02	; 2
     a12:	ed 91       	ld	r30, X+
     a14:	fc 91       	ld	r31, X
     a16:	13 97       	sbiw	r26, 0x03	; 3
     a18:	fb 83       	std	Y+3, r31	; 0x03
     a1a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a1c:	d5 83       	std	Z+5, r29	; 0x05
     a1e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a20:	bd 83       	std	Y+5, r27	; 0x05
     a22:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a24:	13 96       	adiw	r26, 0x03	; 3
     a26:	dc 93       	st	X, r29
     a28:	ce 93       	st	-X, r28
     a2a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a2c:	99 87       	std	Y+9, r25	; 0x09
     a2e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a30:	fc 01       	movw	r30, r24
     a32:	20 81       	ld	r18, Z
     a34:	2f 5f       	subi	r18, 0xFF	; 255
     a36:	20 83       	st	Z, r18
}
     a38:	df 91       	pop	r29
     a3a:	cf 91       	pop	r28
     a3c:	08 95       	ret

00000a3e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
     a42:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a44:	a0 85       	ldd	r26, Z+8	; 0x08
     a46:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a48:	c2 81       	ldd	r28, Z+2	; 0x02
     a4a:	d3 81       	ldd	r29, Z+3	; 0x03
     a4c:	84 81       	ldd	r24, Z+4	; 0x04
     a4e:	95 81       	ldd	r25, Z+5	; 0x05
     a50:	9d 83       	std	Y+5, r25	; 0x05
     a52:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a54:	c4 81       	ldd	r28, Z+4	; 0x04
     a56:	d5 81       	ldd	r29, Z+5	; 0x05
     a58:	82 81       	ldd	r24, Z+2	; 0x02
     a5a:	93 81       	ldd	r25, Z+3	; 0x03
     a5c:	9b 83       	std	Y+3, r25	; 0x03
     a5e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a60:	11 96       	adiw	r26, 0x01	; 1
     a62:	8d 91       	ld	r24, X+
     a64:	9c 91       	ld	r25, X
     a66:	12 97       	sbiw	r26, 0x02	; 2
     a68:	e8 17       	cp	r30, r24
     a6a:	f9 07       	cpc	r31, r25
     a6c:	31 f4       	brne	.+12     	; 0xa7a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a6e:	84 81       	ldd	r24, Z+4	; 0x04
     a70:	95 81       	ldd	r25, Z+5	; 0x05
     a72:	12 96       	adiw	r26, 0x02	; 2
     a74:	9c 93       	st	X, r25
     a76:	8e 93       	st	-X, r24
     a78:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     a7a:	11 86       	std	Z+9, r1	; 0x09
     a7c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a7e:	8c 91       	ld	r24, X
     a80:	81 50       	subi	r24, 0x01	; 1
     a82:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     a84:	df 91       	pop	r29
     a86:	cf 91       	pop	r28
     a88:	08 95       	ret

00000a8a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a8a:	31 e1       	ldi	r19, 0x11	; 17
     a8c:	fc 01       	movw	r30, r24
     a8e:	30 83       	st	Z, r19
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	22 e2       	ldi	r18, 0x22	; 34
     a94:	20 83       	st	Z, r18
     a96:	31 97       	sbiw	r30, 0x01	; 1
     a98:	a3 e3       	ldi	r26, 0x33	; 51
     a9a:	a0 83       	st	Z, r26
     a9c:	31 97       	sbiw	r30, 0x01	; 1
     a9e:	60 83       	st	Z, r22
     aa0:	31 97       	sbiw	r30, 0x01	; 1
     aa2:	70 83       	st	Z, r23
     aa4:	31 97       	sbiw	r30, 0x01	; 1
     aa6:	10 82       	st	Z, r1
     aa8:	31 97       	sbiw	r30, 0x01	; 1
     aaa:	60 e8       	ldi	r22, 0x80	; 128
     aac:	60 83       	st	Z, r22
     aae:	31 97       	sbiw	r30, 0x01	; 1
     ab0:	10 82       	st	Z, r1
     ab2:	31 97       	sbiw	r30, 0x01	; 1
     ab4:	62 e0       	ldi	r22, 0x02	; 2
     ab6:	60 83       	st	Z, r22
     ab8:	31 97       	sbiw	r30, 0x01	; 1
     aba:	63 e0       	ldi	r22, 0x03	; 3
     abc:	60 83       	st	Z, r22
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	64 e0       	ldi	r22, 0x04	; 4
     ac2:	60 83       	st	Z, r22
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	65 e0       	ldi	r22, 0x05	; 5
     ac8:	60 83       	st	Z, r22
     aca:	31 97       	sbiw	r30, 0x01	; 1
     acc:	66 e0       	ldi	r22, 0x06	; 6
     ace:	60 83       	st	Z, r22
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	67 e0       	ldi	r22, 0x07	; 7
     ad4:	60 83       	st	Z, r22
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	68 e0       	ldi	r22, 0x08	; 8
     ada:	60 83       	st	Z, r22
     adc:	31 97       	sbiw	r30, 0x01	; 1
     ade:	69 e0       	ldi	r22, 0x09	; 9
     ae0:	60 83       	st	Z, r22
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	60 e1       	ldi	r22, 0x10	; 16
     ae6:	60 83       	st	Z, r22
     ae8:	31 97       	sbiw	r30, 0x01	; 1
     aea:	30 83       	st	Z, r19
     aec:	31 97       	sbiw	r30, 0x01	; 1
     aee:	32 e1       	ldi	r19, 0x12	; 18
     af0:	30 83       	st	Z, r19
     af2:	31 97       	sbiw	r30, 0x01	; 1
     af4:	33 e1       	ldi	r19, 0x13	; 19
     af6:	30 83       	st	Z, r19
     af8:	31 97       	sbiw	r30, 0x01	; 1
     afa:	34 e1       	ldi	r19, 0x14	; 20
     afc:	30 83       	st	Z, r19
     afe:	31 97       	sbiw	r30, 0x01	; 1
     b00:	35 e1       	ldi	r19, 0x15	; 21
     b02:	30 83       	st	Z, r19
     b04:	31 97       	sbiw	r30, 0x01	; 1
     b06:	36 e1       	ldi	r19, 0x16	; 22
     b08:	30 83       	st	Z, r19
     b0a:	31 97       	sbiw	r30, 0x01	; 1
     b0c:	37 e1       	ldi	r19, 0x17	; 23
     b0e:	30 83       	st	Z, r19
     b10:	31 97       	sbiw	r30, 0x01	; 1
     b12:	38 e1       	ldi	r19, 0x18	; 24
     b14:	30 83       	st	Z, r19
     b16:	31 97       	sbiw	r30, 0x01	; 1
     b18:	39 e1       	ldi	r19, 0x19	; 25
     b1a:	30 83       	st	Z, r19
     b1c:	31 97       	sbiw	r30, 0x01	; 1
     b1e:	30 e2       	ldi	r19, 0x20	; 32
     b20:	30 83       	st	Z, r19
     b22:	31 97       	sbiw	r30, 0x01	; 1
     b24:	31 e2       	ldi	r19, 0x21	; 33
     b26:	30 83       	st	Z, r19
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	20 83       	st	Z, r18
     b2c:	31 97       	sbiw	r30, 0x01	; 1
     b2e:	23 e2       	ldi	r18, 0x23	; 35
     b30:	20 83       	st	Z, r18
     b32:	31 97       	sbiw	r30, 0x01	; 1
     b34:	40 83       	st	Z, r20
     b36:	31 97       	sbiw	r30, 0x01	; 1
     b38:	50 83       	st	Z, r21
     b3a:	31 97       	sbiw	r30, 0x01	; 1
     b3c:	26 e2       	ldi	r18, 0x26	; 38
     b3e:	20 83       	st	Z, r18
     b40:	31 97       	sbiw	r30, 0x01	; 1
     b42:	27 e2       	ldi	r18, 0x27	; 39
     b44:	20 83       	st	Z, r18
     b46:	31 97       	sbiw	r30, 0x01	; 1
     b48:	28 e2       	ldi	r18, 0x28	; 40
     b4a:	20 83       	st	Z, r18
     b4c:	31 97       	sbiw	r30, 0x01	; 1
     b4e:	29 e2       	ldi	r18, 0x29	; 41
     b50:	20 83       	st	Z, r18
     b52:	31 97       	sbiw	r30, 0x01	; 1
     b54:	20 e3       	ldi	r18, 0x30	; 48
     b56:	20 83       	st	Z, r18
     b58:	31 97       	sbiw	r30, 0x01	; 1
     b5a:	21 e3       	ldi	r18, 0x31	; 49
     b5c:	20 83       	st	Z, r18
     b5e:	86 97       	sbiw	r24, 0x26	; 38
     b60:	08 95       	ret

00000b62 <xPortStartScheduler>:
     b62:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     b66:	85 ee       	ldi	r24, 0xE5	; 229
     b68:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     b6c:	8b e0       	ldi	r24, 0x0B	; 11
     b6e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     b72:	ef e6       	ldi	r30, 0x6F	; 111
     b74:	f0 e0       	ldi	r31, 0x00	; 0
     b76:	80 81       	ld	r24, Z
     b78:	82 60       	ori	r24, 0x02	; 2
     b7a:	80 83       	st	Z, r24
     b7c:	a0 91 96 07 	lds	r26, 0x0796	; 0x800796 <pxCurrentTCB>
     b80:	b0 91 97 07 	lds	r27, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
     b84:	cd 91       	ld	r28, X+
     b86:	cd bf       	out	0x3d, r28	; 61
     b88:	dd 91       	ld	r29, X+
     b8a:	de bf       	out	0x3e, r29	; 62
     b8c:	ff 91       	pop	r31
     b8e:	ef 91       	pop	r30
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	bf 91       	pop	r27
     b96:	af 91       	pop	r26
     b98:	9f 91       	pop	r25
     b9a:	8f 91       	pop	r24
     b9c:	7f 91       	pop	r23
     b9e:	6f 91       	pop	r22
     ba0:	5f 91       	pop	r21
     ba2:	4f 91       	pop	r20
     ba4:	3f 91       	pop	r19
     ba6:	2f 91       	pop	r18
     ba8:	1f 91       	pop	r17
     baa:	0f 91       	pop	r16
     bac:	ff 90       	pop	r15
     bae:	ef 90       	pop	r14
     bb0:	df 90       	pop	r13
     bb2:	cf 90       	pop	r12
     bb4:	bf 90       	pop	r11
     bb6:	af 90       	pop	r10
     bb8:	9f 90       	pop	r9
     bba:	8f 90       	pop	r8
     bbc:	7f 90       	pop	r7
     bbe:	6f 90       	pop	r6
     bc0:	5f 90       	pop	r5
     bc2:	4f 90       	pop	r4
     bc4:	3f 90       	pop	r3
     bc6:	2f 90       	pop	r2
     bc8:	1f 90       	pop	r1
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	0f 90       	pop	r0
     bd0:	08 95       	ret
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	08 95       	ret

00000bd6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     bd6:	0f 92       	push	r0
     bd8:	0f b6       	in	r0, 0x3f	; 63
     bda:	f8 94       	cli
     bdc:	0f 92       	push	r0
     bde:	1f 92       	push	r1
     be0:	11 24       	eor	r1, r1
     be2:	2f 92       	push	r2
     be4:	3f 92       	push	r3
     be6:	4f 92       	push	r4
     be8:	5f 92       	push	r5
     bea:	6f 92       	push	r6
     bec:	7f 92       	push	r7
     bee:	8f 92       	push	r8
     bf0:	9f 92       	push	r9
     bf2:	af 92       	push	r10
     bf4:	bf 92       	push	r11
     bf6:	cf 92       	push	r12
     bf8:	df 92       	push	r13
     bfa:	ef 92       	push	r14
     bfc:	ff 92       	push	r15
     bfe:	0f 93       	push	r16
     c00:	1f 93       	push	r17
     c02:	2f 93       	push	r18
     c04:	3f 93       	push	r19
     c06:	4f 93       	push	r20
     c08:	5f 93       	push	r21
     c0a:	6f 93       	push	r22
     c0c:	7f 93       	push	r23
     c0e:	8f 93       	push	r24
     c10:	9f 93       	push	r25
     c12:	af 93       	push	r26
     c14:	bf 93       	push	r27
     c16:	cf 93       	push	r28
     c18:	df 93       	push	r29
     c1a:	ef 93       	push	r30
     c1c:	ff 93       	push	r31
     c1e:	a0 91 96 07 	lds	r26, 0x0796	; 0x800796 <pxCurrentTCB>
     c22:	b0 91 97 07 	lds	r27, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
     c26:	0d b6       	in	r0, 0x3d	; 61
     c28:	0d 92       	st	X+, r0
     c2a:	0e b6       	in	r0, 0x3e	; 62
     c2c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c2e:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c32:	a0 91 96 07 	lds	r26, 0x0796	; 0x800796 <pxCurrentTCB>
     c36:	b0 91 97 07 	lds	r27, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
     c3a:	cd 91       	ld	r28, X+
     c3c:	cd bf       	out	0x3d, r28	; 61
     c3e:	dd 91       	ld	r29, X+
     c40:	de bf       	out	0x3e, r29	; 62
     c42:	ff 91       	pop	r31
     c44:	ef 91       	pop	r30
     c46:	df 91       	pop	r29
     c48:	cf 91       	pop	r28
     c4a:	bf 91       	pop	r27
     c4c:	af 91       	pop	r26
     c4e:	9f 91       	pop	r25
     c50:	8f 91       	pop	r24
     c52:	7f 91       	pop	r23
     c54:	6f 91       	pop	r22
     c56:	5f 91       	pop	r21
     c58:	4f 91       	pop	r20
     c5a:	3f 91       	pop	r19
     c5c:	2f 91       	pop	r18
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	ff 90       	pop	r15
     c64:	ef 90       	pop	r14
     c66:	df 90       	pop	r13
     c68:	cf 90       	pop	r12
     c6a:	bf 90       	pop	r11
     c6c:	af 90       	pop	r10
     c6e:	9f 90       	pop	r9
     c70:	8f 90       	pop	r8
     c72:	7f 90       	pop	r7
     c74:	6f 90       	pop	r6
     c76:	5f 90       	pop	r5
     c78:	4f 90       	pop	r4
     c7a:	3f 90       	pop	r3
     c7c:	2f 90       	pop	r2
     c7e:	1f 90       	pop	r1
     c80:	0f 90       	pop	r0
     c82:	0f be       	out	0x3f, r0	; 63
     c84:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c86:	08 95       	ret

00000c88 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     c88:	0f 92       	push	r0
     c8a:	0f b6       	in	r0, 0x3f	; 63
     c8c:	f8 94       	cli
     c8e:	0f 92       	push	r0
     c90:	1f 92       	push	r1
     c92:	11 24       	eor	r1, r1
     c94:	2f 92       	push	r2
     c96:	3f 92       	push	r3
     c98:	4f 92       	push	r4
     c9a:	5f 92       	push	r5
     c9c:	6f 92       	push	r6
     c9e:	7f 92       	push	r7
     ca0:	8f 92       	push	r8
     ca2:	9f 92       	push	r9
     ca4:	af 92       	push	r10
     ca6:	bf 92       	push	r11
     ca8:	cf 92       	push	r12
     caa:	df 92       	push	r13
     cac:	ef 92       	push	r14
     cae:	ff 92       	push	r15
     cb0:	0f 93       	push	r16
     cb2:	1f 93       	push	r17
     cb4:	2f 93       	push	r18
     cb6:	3f 93       	push	r19
     cb8:	4f 93       	push	r20
     cba:	5f 93       	push	r21
     cbc:	6f 93       	push	r22
     cbe:	7f 93       	push	r23
     cc0:	8f 93       	push	r24
     cc2:	9f 93       	push	r25
     cc4:	af 93       	push	r26
     cc6:	bf 93       	push	r27
     cc8:	cf 93       	push	r28
     cca:	df 93       	push	r29
     ccc:	ef 93       	push	r30
     cce:	ff 93       	push	r31
     cd0:	a0 91 96 07 	lds	r26, 0x0796	; 0x800796 <pxCurrentTCB>
     cd4:	b0 91 97 07 	lds	r27, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
     cd8:	0d b6       	in	r0, 0x3d	; 61
     cda:	0d 92       	st	X+, r0
     cdc:	0e b6       	in	r0, 0x3e	; 62
     cde:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     ce0:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <xTaskIncrementTick>
     ce4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ce6:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     cea:	a0 91 96 07 	lds	r26, 0x0796	; 0x800796 <pxCurrentTCB>
     cee:	b0 91 97 07 	lds	r27, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
     cf2:	cd 91       	ld	r28, X+
     cf4:	cd bf       	out	0x3d, r28	; 61
     cf6:	dd 91       	ld	r29, X+
     cf8:	de bf       	out	0x3e, r29	; 62
     cfa:	ff 91       	pop	r31
     cfc:	ef 91       	pop	r30
     cfe:	df 91       	pop	r29
     d00:	cf 91       	pop	r28
     d02:	bf 91       	pop	r27
     d04:	af 91       	pop	r26
     d06:	9f 91       	pop	r25
     d08:	8f 91       	pop	r24
     d0a:	7f 91       	pop	r23
     d0c:	6f 91       	pop	r22
     d0e:	5f 91       	pop	r21
     d10:	4f 91       	pop	r20
     d12:	3f 91       	pop	r19
     d14:	2f 91       	pop	r18
     d16:	1f 91       	pop	r17
     d18:	0f 91       	pop	r16
     d1a:	ff 90       	pop	r15
     d1c:	ef 90       	pop	r14
     d1e:	df 90       	pop	r13
     d20:	cf 90       	pop	r12
     d22:	bf 90       	pop	r11
     d24:	af 90       	pop	r10
     d26:	9f 90       	pop	r9
     d28:	8f 90       	pop	r8
     d2a:	7f 90       	pop	r7
     d2c:	6f 90       	pop	r6
     d2e:	5f 90       	pop	r5
     d30:	4f 90       	pop	r4
     d32:	3f 90       	pop	r3
     d34:	2f 90       	pop	r2
     d36:	1f 90       	pop	r1
     d38:	0f 90       	pop	r0
     d3a:	0f be       	out	0x3f, r0	; 63
     d3c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d3e:	08 95       	ret

00000d40 <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     d40:	0e 94 44 06 	call	0xc88	; 0xc88 <vPortYieldFromTick>
		asm volatile ( "reti" );
     d44:	18 95       	reti

00000d46 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d46:	cf 93       	push	r28
     d48:	df 93       	push	r29
     d4a:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     d4c:	0e 94 53 0c 	call	0x18a6	; 0x18a6 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     d50:	80 91 4b 03 	lds	r24, 0x034B	; 0x80034b <pucAlignedHeap.2084>
     d54:	90 91 4c 03 	lds	r25, 0x034C	; 0x80034c <pucAlignedHeap.2084+0x1>
     d58:	89 2b       	or	r24, r25
     d5a:	31 f4       	brne	.+12     	; 0xd68 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     d5c:	80 e5       	ldi	r24, 0x50	; 80
     d5e:	93 e0       	ldi	r25, 0x03	; 3
     d60:	90 93 4c 03 	sts	0x034C, r25	; 0x80034c <pucAlignedHeap.2084+0x1>
     d64:	80 93 4b 03 	sts	0x034B, r24	; 0x80034b <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     d68:	20 91 4d 03 	lds	r18, 0x034D	; 0x80034d <xNextFreeByte>
     d6c:	30 91 4e 03 	lds	r19, 0x034E	; 0x80034e <xNextFreeByte+0x1>
     d70:	c9 01       	movw	r24, r18
     d72:	8c 0f       	add	r24, r28
     d74:	9d 1f       	adc	r25, r29
     d76:	87 3e       	cpi	r24, 0xE7	; 231
     d78:	43 e0       	ldi	r20, 0x03	; 3
     d7a:	94 07       	cpc	r25, r20
     d7c:	70 f4       	brcc	.+28     	; 0xd9a <pvPortMalloc+0x54>
     d7e:	28 17       	cp	r18, r24
     d80:	39 07       	cpc	r19, r25
     d82:	70 f4       	brcc	.+28     	; 0xda0 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     d84:	c0 91 4b 03 	lds	r28, 0x034B	; 0x80034b <pucAlignedHeap.2084>
     d88:	d0 91 4c 03 	lds	r29, 0x034C	; 0x80034c <pucAlignedHeap.2084+0x1>
     d8c:	c2 0f       	add	r28, r18
     d8e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     d90:	90 93 4e 03 	sts	0x034E, r25	; 0x80034e <xNextFreeByte+0x1>
     d94:	80 93 4d 03 	sts	0x034D, r24	; 0x80034d <xNextFreeByte>
     d98:	05 c0       	rjmp	.+10     	; 0xda4 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     d9a:	c0 e0       	ldi	r28, 0x00	; 0
     d9c:	d0 e0       	ldi	r29, 0x00	; 0
     d9e:	02 c0       	rjmp	.+4      	; 0xda4 <pvPortMalloc+0x5e>
     da0:	c0 e0       	ldi	r28, 0x00	; 0
     da2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     da4:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     da8:	ce 01       	movw	r24, r28
     daa:	df 91       	pop	r29
     dac:	cf 91       	pop	r28
     dae:	08 95       	ret

00000db0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     db0:	08 95       	ret

00000db2 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
     db2:	4f 92       	push	r4
     db4:	5f 92       	push	r5
     db6:	6f 92       	push	r6
     db8:	7f 92       	push	r7
     dba:	8f 92       	push	r8
     dbc:	9f 92       	push	r9
     dbe:	af 92       	push	r10
     dc0:	bf 92       	push	r11
     dc2:	cf 92       	push	r12
     dc4:	df 92       	push	r13
     dc6:	ff 92       	push	r15
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	cd b7       	in	r28, 0x3d	; 61
     dd2:	de b7       	in	r29, 0x3e	; 62
     dd4:	f8 2e       	mov	r15, r24
     dd6:	2a 01       	movw	r4, r20
     dd8:	3b 01       	movw	r6, r22
     dda:	88 e0       	ldi	r24, 0x08	; 8
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <malloc>
     de2:	8c 01       	movw	r16, r24
     de4:	8f 2d       	mov	r24, r15
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	88 0f       	add	r24, r24
     dea:	99 1f       	adc	r25, r25
     dec:	fc 01       	movw	r30, r24
     dee:	e9 5c       	subi	r30, 0xC9	; 201
     df0:	f8 4f       	sbci	r31, 0xF8	; 248
     df2:	11 83       	std	Z+1, r17	; 0x01
     df4:	00 83       	st	Z, r16
     df6:	fc 01       	movw	r30, r24
     df8:	e6 5f       	subi	r30, 0xF6	; 246
     dfa:	fe 4f       	sbci	r31, 0xFE	; 254
     dfc:	80 81       	ld	r24, Z
     dfe:	91 81       	ldd	r25, Z+1	; 0x01
     e00:	d8 01       	movw	r26, r16
     e02:	11 96       	adiw	r26, 0x01	; 1
     e04:	9c 93       	st	X, r25
     e06:	8e 93       	st	-X, r24
     e08:	13 96       	adiw	r26, 0x03	; 3
     e0a:	bc 92       	st	X, r11
     e0c:	ae 92       	st	-X, r10
     e0e:	12 97       	sbiw	r26, 0x02	; 2
     e10:	15 96       	adiw	r26, 0x05	; 5
     e12:	dc 92       	st	X, r13
     e14:	ce 92       	st	-X, r12
     e16:	14 97       	sbiw	r26, 0x04	; 4
     e18:	17 96       	adiw	r26, 0x07	; 7
     e1a:	9c 92       	st	X, r9
     e1c:	8e 92       	st	-X, r8
     e1e:	16 97       	sbiw	r26, 0x06	; 6
     e20:	ff b6       	in	r15, 0x3f	; 63
     e22:	f8 94       	cli
     e24:	ed 91       	ld	r30, X+
     e26:	fc 91       	ld	r31, X
     e28:	11 97       	sbiw	r26, 0x01	; 1
     e2a:	36 97       	sbiw	r30, 0x06	; 6
     e2c:	80 81       	ld	r24, Z
     e2e:	82 60       	ori	r24, 0x02	; 2
     e30:	80 83       	st	Z, r24
     e32:	cd 90       	ld	r12, X+
     e34:	dc 90       	ld	r13, X
     e36:	d3 01       	movw	r26, r6
     e38:	c2 01       	movw	r24, r4
     e3a:	88 0f       	add	r24, r24
     e3c:	99 1f       	adc	r25, r25
     e3e:	aa 1f       	adc	r26, r26
     e40:	bb 1f       	adc	r27, r27
     e42:	88 0f       	add	r24, r24
     e44:	99 1f       	adc	r25, r25
     e46:	aa 1f       	adc	r26, r26
     e48:	bb 1f       	adc	r27, r27
     e4a:	9c 01       	movw	r18, r24
     e4c:	ad 01       	movw	r20, r26
     e4e:	22 0f       	add	r18, r18
     e50:	33 1f       	adc	r19, r19
     e52:	44 1f       	adc	r20, r20
     e54:	55 1f       	adc	r21, r21
     e56:	60 e0       	ldi	r22, 0x00	; 0
     e58:	70 e0       	ldi	r23, 0x00	; 0
     e5a:	81 ee       	ldi	r24, 0xE1	; 225
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <__udivmodsi4>
     e62:	21 50       	subi	r18, 0x01	; 1
     e64:	f6 01       	movw	r30, r12
     e66:	32 97       	sbiw	r30, 0x02	; 2
     e68:	20 83       	st	Z, r18
     e6a:	d8 01       	movw	r26, r16
     e6c:	ed 91       	ld	r30, X+
     e6e:	fc 91       	ld	r31, X
     e70:	11 97       	sbiw	r26, 0x01	; 1
     e72:	35 97       	sbiw	r30, 0x05	; 5
     e74:	88 e9       	ldi	r24, 0x98	; 152
     e76:	80 83       	st	Z, r24
     e78:	ed 91       	ld	r30, X+
     e7a:	fc 91       	ld	r31, X
     e7c:	34 97       	sbiw	r30, 0x04	; 4
     e7e:	86 e0       	ldi	r24, 0x06	; 6
     e80:	80 83       	st	Z, r24
     e82:	ff be       	out	0x3f, r15	; 63
     e84:	c8 01       	movw	r24, r16
     e86:	df 91       	pop	r29
     e88:	cf 91       	pop	r28
     e8a:	1f 91       	pop	r17
     e8c:	0f 91       	pop	r16
     e8e:	ff 90       	pop	r15
     e90:	df 90       	pop	r13
     e92:	cf 90       	pop	r12
     e94:	bf 90       	pop	r11
     e96:	af 90       	pop	r10
     e98:	9f 90       	pop	r9
     e9a:	8f 90       	pop	r8
     e9c:	7f 90       	pop	r7
     e9e:	6f 90       	pop	r6
     ea0:	5f 90       	pop	r5
     ea2:	4f 90       	pop	r4
     ea4:	08 95       	ret

00000ea6 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
     ea6:	ef 92       	push	r14
     ea8:	ff 92       	push	r15
     eaa:	0f 93       	push	r16
     eac:	1f 93       	push	r17
     eae:	cf 93       	push	r28
     eb0:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     eb2:	fc 01       	movw	r30, r24
     eb4:	a2 81       	ldd	r26, Z+2	; 0x02
     eb6:	b3 81       	ldd	r27, Z+3	; 0x03
     eb8:	10 97       	sbiw	r26, 0x00	; 0
     eba:	79 f0       	breq	.+30     	; 0xeda <serial_send_bytes+0x34>
     ebc:	e4 2f       	mov	r30, r20
     ebe:	f0 e0       	ldi	r31, 0x00	; 0
     ec0:	92 96       	adiw	r26, 0x22	; 34
     ec2:	5c 91       	ld	r21, X
     ec4:	20 e2       	ldi	r18, 0x20	; 32
     ec6:	30 e0       	ldi	r19, 0x00	; 0
     ec8:	25 1b       	sub	r18, r21
     eca:	31 09       	sbc	r19, r1
     ecc:	2e 17       	cp	r18, r30
     ece:	3f 07       	cpc	r19, r31
     ed0:	1c f1       	brlt	.+70     	; 0xf18 <serial_send_bytes+0x72>
     ed2:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     ed4:	41 11       	cpse	r20, r1
     ed6:	04 c0       	rjmp	.+8      	; 0xee0 <serial_send_bytes+0x3a>
     ed8:	16 c0       	rjmp	.+44     	; 0xf06 <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     eda:	42 30       	cpi	r20, 0x02	; 2
     edc:	f8 f4       	brcc	.+62     	; 0xf1c <serial_send_bytes+0x76>
     ede:	f9 cf       	rjmp	.-14     	; 0xed2 <serial_send_bytes+0x2c>
     ee0:	eb 01       	movw	r28, r22
     ee2:	41 50       	subi	r20, 0x01	; 1
     ee4:	04 2f       	mov	r16, r20
     ee6:	10 e0       	ldi	r17, 0x00	; 0
     ee8:	0f 5f       	subi	r16, 0xFF	; 255
     eea:	1f 4f       	sbci	r17, 0xFF	; 255
     eec:	06 0f       	add	r16, r22
     eee:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
     ef0:	69 91       	ld	r22, Y+
     ef2:	d7 01       	movw	r26, r14
     ef4:	12 96       	adiw	r26, 0x02	; 2
     ef6:	8d 91       	ld	r24, X+
     ef8:	9c 91       	ld	r25, X
     efa:	13 97       	sbiw	r26, 0x03	; 3
     efc:	0e 94 9e 04 	call	0x93c	; 0x93c <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     f00:	c0 17       	cp	r28, r16
     f02:	d1 07       	cpc	r29, r17
     f04:	a9 f7       	brne	.-22     	; 0xef0 <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
     f06:	d7 01       	movw	r26, r14
     f08:	ed 91       	ld	r30, X+
     f0a:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
     f0c:	35 97       	sbiw	r30, 0x05	; 5
     f0e:	80 81       	ld	r24, Z
     f10:	80 62       	ori	r24, 0x20	; 32
     f12:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
     f14:	80 e0       	ldi	r24, 0x00	; 0
     f16:	03 c0       	rjmp	.+6      	; 0xf1e <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
     f18:	82 e0       	ldi	r24, 0x02	; 2
     f1a:	01 c0       	rjmp	.+2      	; 0xf1e <serial_send_bytes+0x78>
     f1c:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
     f1e:	df 91       	pop	r29
     f20:	cf 91       	pop	r28
     f22:	1f 91       	pop	r17
     f24:	0f 91       	pop	r16
     f26:	ff 90       	pop	r15
     f28:	ef 90       	pop	r14
     f2a:	08 95       	ret

00000f2c <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
     f2c:	1f 92       	push	r1
     f2e:	0f 92       	push	r0
     f30:	0f b6       	in	r0, 0x3f	; 63
     f32:	0f 92       	push	r0
     f34:	11 24       	eor	r1, r1
     f36:	2f 93       	push	r18
     f38:	3f 93       	push	r19
     f3a:	4f 93       	push	r20
     f3c:	5f 93       	push	r21
     f3e:	6f 93       	push	r22
     f40:	7f 93       	push	r23
     f42:	8f 93       	push	r24
     f44:	9f 93       	push	r25
     f46:	af 93       	push	r26
     f48:	bf 93       	push	r27
     f4a:	cf 93       	push	r28
     f4c:	ef 93       	push	r30
     f4e:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     f50:	e0 91 37 07 	lds	r30, 0x0737	; 0x800737 <_ser_handle>
     f54:	f0 91 38 07 	lds	r31, 0x0738	; 0x800738 <_ser_handle+0x1>
     f58:	30 97       	sbiw	r30, 0x00	; 0
     f5a:	a1 f0       	breq	.+40     	; 0xf84 <__vector_20+0x58>
		item = UDR0;
     f5c:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
     f60:	6c 2f       	mov	r22, r28
     f62:	84 81       	ldd	r24, Z+4	; 0x04
     f64:	95 81       	ldd	r25, Z+5	; 0x05
     f66:	0e 94 9e 04 	call	0x93c	; 0x93c <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
     f6a:	80 91 37 07 	lds	r24, 0x0737	; 0x800737 <_ser_handle>
     f6e:	90 91 38 07 	lds	r25, 0x0738	; 0x800738 <_ser_handle+0x1>
     f72:	dc 01       	movw	r26, r24
     f74:	16 96       	adiw	r26, 0x06	; 6
     f76:	ed 91       	ld	r30, X+
     f78:	fc 91       	ld	r31, X
     f7a:	17 97       	sbiw	r26, 0x07	; 7
     f7c:	30 97       	sbiw	r30, 0x00	; 0
     f7e:	11 f0       	breq	.+4      	; 0xf84 <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
     f80:	6c 2f       	mov	r22, r28
     f82:	09 95       	icall
		}
	}
}
     f84:	ff 91       	pop	r31
     f86:	ef 91       	pop	r30
     f88:	cf 91       	pop	r28
     f8a:	bf 91       	pop	r27
     f8c:	af 91       	pop	r26
     f8e:	9f 91       	pop	r25
     f90:	8f 91       	pop	r24
     f92:	7f 91       	pop	r23
     f94:	6f 91       	pop	r22
     f96:	5f 91       	pop	r21
     f98:	4f 91       	pop	r20
     f9a:	3f 91       	pop	r19
     f9c:	2f 91       	pop	r18
     f9e:	0f 90       	pop	r0
     fa0:	0f be       	out	0x3f, r0	; 63
     fa2:	0f 90       	pop	r0
     fa4:	1f 90       	pop	r1
     fa6:	18 95       	reti

00000fa8 <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
     fa8:	1f 92       	push	r1
     faa:	0f 92       	push	r0
     fac:	0f b6       	in	r0, 0x3f	; 63
     fae:	0f 92       	push	r0
     fb0:	11 24       	eor	r1, r1
     fb2:	2f 93       	push	r18
     fb4:	3f 93       	push	r19
     fb6:	4f 93       	push	r20
     fb8:	5f 93       	push	r21
     fba:	6f 93       	push	r22
     fbc:	7f 93       	push	r23
     fbe:	8f 93       	push	r24
     fc0:	9f 93       	push	r25
     fc2:	af 93       	push	r26
     fc4:	bf 93       	push	r27
     fc6:	ef 93       	push	r30
     fc8:	ff 93       	push	r31
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	1f 92       	push	r1
     fd0:	cd b7       	in	r28, 0x3d	; 61
     fd2:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     fd4:	e0 91 37 07 	lds	r30, 0x0737	; 0x800737 <_ser_handle>
     fd8:	f0 91 38 07 	lds	r31, 0x0738	; 0x800738 <_ser_handle+0x1>
     fdc:	30 97       	sbiw	r30, 0x00	; 0
     fde:	99 f0       	breq	.+38     	; 0x1006 <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
     fe0:	be 01       	movw	r22, r28
     fe2:	6f 5f       	subi	r22, 0xFF	; 255
     fe4:	7f 4f       	sbci	r23, 0xFF	; 255
     fe6:	82 81       	ldd	r24, Z+2	; 0x02
     fe8:	93 81       	ldd	r25, Z+3	; 0x03
     fea:	0e 94 7d 04 	call	0x8fa	; 0x8fa <buffer_get_item>
     fee:	81 11       	cpse	r24, r1
     ff0:	04 c0       	rjmp	.+8      	; 0xffa <__vector_21+0x52>
			UDR0 = item;
     ff2:	89 81       	ldd	r24, Y+1	; 0x01
     ff4:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     ff8:	0b c0       	rjmp	.+22     	; 0x1010 <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
     ffa:	e1 ec       	ldi	r30, 0xC1	; 193
     ffc:	f0 e0       	ldi	r31, 0x00	; 0
     ffe:	80 81       	ld	r24, Z
    1000:	8f 7d       	andi	r24, 0xDF	; 223
    1002:	80 83       	st	Z, r24
    1004:	05 c0       	rjmp	.+10     	; 0x1010 <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    1006:	e1 ec       	ldi	r30, 0xC1	; 193
    1008:	f0 e0       	ldi	r31, 0x00	; 0
    100a:	80 81       	ld	r24, Z
    100c:	8f 7d       	andi	r24, 0xDF	; 223
    100e:	80 83       	st	Z, r24
	}
}
    1010:	0f 90       	pop	r0
    1012:	df 91       	pop	r29
    1014:	cf 91       	pop	r28
    1016:	ff 91       	pop	r31
    1018:	ef 91       	pop	r30
    101a:	bf 91       	pop	r27
    101c:	af 91       	pop	r26
    101e:	9f 91       	pop	r25
    1020:	8f 91       	pop	r24
    1022:	7f 91       	pop	r23
    1024:	6f 91       	pop	r22
    1026:	5f 91       	pop	r21
    1028:	4f 91       	pop	r20
    102a:	3f 91       	pop	r19
    102c:	2f 91       	pop	r18
    102e:	0f 90       	pop	r0
    1030:	0f be       	out	0x3f, r0	; 63
    1032:	0f 90       	pop	r0
    1034:	1f 90       	pop	r1
    1036:	18 95       	reti

00001038 <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    1038:	1f 92       	push	r1
    103a:	0f 92       	push	r0
    103c:	0f b6       	in	r0, 0x3f	; 63
    103e:	0f 92       	push	r0
    1040:	11 24       	eor	r1, r1
    1042:	2f 93       	push	r18
    1044:	3f 93       	push	r19
    1046:	4f 93       	push	r20
    1048:	5f 93       	push	r21
    104a:	6f 93       	push	r22
    104c:	7f 93       	push	r23
    104e:	8f 93       	push	r24
    1050:	9f 93       	push	r25
    1052:	af 93       	push	r26
    1054:	bf 93       	push	r27
    1056:	cf 93       	push	r28
    1058:	ef 93       	push	r30
    105a:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    105c:	e0 91 39 07 	lds	r30, 0x0739	; 0x800739 <_ser_handle+0x2>
    1060:	f0 91 3a 07 	lds	r31, 0x073A	; 0x80073a <_ser_handle+0x3>
    1064:	30 97       	sbiw	r30, 0x00	; 0
    1066:	a1 f0       	breq	.+40     	; 0x1090 <__vector_28+0x58>
		item = UDR1;
    1068:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    106c:	6c 2f       	mov	r22, r28
    106e:	84 81       	ldd	r24, Z+4	; 0x04
    1070:	95 81       	ldd	r25, Z+5	; 0x05
    1072:	0e 94 9e 04 	call	0x93c	; 0x93c <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    1076:	80 91 39 07 	lds	r24, 0x0739	; 0x800739 <_ser_handle+0x2>
    107a:	90 91 3a 07 	lds	r25, 0x073A	; 0x80073a <_ser_handle+0x3>
    107e:	dc 01       	movw	r26, r24
    1080:	16 96       	adiw	r26, 0x06	; 6
    1082:	ed 91       	ld	r30, X+
    1084:	fc 91       	ld	r31, X
    1086:	17 97       	sbiw	r26, 0x07	; 7
    1088:	30 97       	sbiw	r30, 0x00	; 0
    108a:	11 f0       	breq	.+4      	; 0x1090 <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    108c:	6c 2f       	mov	r22, r28
    108e:	09 95       	icall
		}
	}
}
    1090:	ff 91       	pop	r31
    1092:	ef 91       	pop	r30
    1094:	cf 91       	pop	r28
    1096:	bf 91       	pop	r27
    1098:	af 91       	pop	r26
    109a:	9f 91       	pop	r25
    109c:	8f 91       	pop	r24
    109e:	7f 91       	pop	r23
    10a0:	6f 91       	pop	r22
    10a2:	5f 91       	pop	r21
    10a4:	4f 91       	pop	r20
    10a6:	3f 91       	pop	r19
    10a8:	2f 91       	pop	r18
    10aa:	0f 90       	pop	r0
    10ac:	0f be       	out	0x3f, r0	; 63
    10ae:	0f 90       	pop	r0
    10b0:	1f 90       	pop	r1
    10b2:	18 95       	reti

000010b4 <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    10b4:	1f 92       	push	r1
    10b6:	0f 92       	push	r0
    10b8:	0f b6       	in	r0, 0x3f	; 63
    10ba:	0f 92       	push	r0
    10bc:	11 24       	eor	r1, r1
    10be:	2f 93       	push	r18
    10c0:	3f 93       	push	r19
    10c2:	4f 93       	push	r20
    10c4:	5f 93       	push	r21
    10c6:	6f 93       	push	r22
    10c8:	7f 93       	push	r23
    10ca:	8f 93       	push	r24
    10cc:	9f 93       	push	r25
    10ce:	af 93       	push	r26
    10d0:	bf 93       	push	r27
    10d2:	ef 93       	push	r30
    10d4:	ff 93       	push	r31
    10d6:	cf 93       	push	r28
    10d8:	df 93       	push	r29
    10da:	1f 92       	push	r1
    10dc:	cd b7       	in	r28, 0x3d	; 61
    10de:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    10e0:	e0 91 39 07 	lds	r30, 0x0739	; 0x800739 <_ser_handle+0x2>
    10e4:	f0 91 3a 07 	lds	r31, 0x073A	; 0x80073a <_ser_handle+0x3>
    10e8:	30 97       	sbiw	r30, 0x00	; 0
    10ea:	99 f0       	breq	.+38     	; 0x1112 <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    10ec:	be 01       	movw	r22, r28
    10ee:	6f 5f       	subi	r22, 0xFF	; 255
    10f0:	7f 4f       	sbci	r23, 0xFF	; 255
    10f2:	82 81       	ldd	r24, Z+2	; 0x02
    10f4:	93 81       	ldd	r25, Z+3	; 0x03
    10f6:	0e 94 7d 04 	call	0x8fa	; 0x8fa <buffer_get_item>
    10fa:	81 11       	cpse	r24, r1
    10fc:	04 c0       	rjmp	.+8      	; 0x1106 <__vector_29+0x52>
			UDR1 = item;
    10fe:	89 81       	ldd	r24, Y+1	; 0x01
    1100:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1104:	0b c0       	rjmp	.+22     	; 0x111c <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    1106:	e9 ec       	ldi	r30, 0xC9	; 201
    1108:	f0 e0       	ldi	r31, 0x00	; 0
    110a:	80 81       	ld	r24, Z
    110c:	8f 7d       	andi	r24, 0xDF	; 223
    110e:	80 83       	st	Z, r24
    1110:	05 c0       	rjmp	.+10     	; 0x111c <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    1112:	e9 ec       	ldi	r30, 0xC9	; 201
    1114:	f0 e0       	ldi	r31, 0x00	; 0
    1116:	80 81       	ld	r24, Z
    1118:	8f 7d       	andi	r24, 0xDF	; 223
    111a:	80 83       	st	Z, r24
	}
}
    111c:	0f 90       	pop	r0
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	ff 91       	pop	r31
    1124:	ef 91       	pop	r30
    1126:	bf 91       	pop	r27
    1128:	af 91       	pop	r26
    112a:	9f 91       	pop	r25
    112c:	8f 91       	pop	r24
    112e:	7f 91       	pop	r23
    1130:	6f 91       	pop	r22
    1132:	5f 91       	pop	r21
    1134:	4f 91       	pop	r20
    1136:	3f 91       	pop	r19
    1138:	2f 91       	pop	r18
    113a:	0f 90       	pop	r0
    113c:	0f be       	out	0x3f, r0	; 63
    113e:	0f 90       	pop	r0
    1140:	1f 90       	pop	r1
    1142:	18 95       	reti

00001144 <prvCopyDataToQueue>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1144:	0f 93       	push	r16
    1146:	1f 93       	push	r17
    1148:	cf 93       	push	r28
    114a:	df 93       	push	r29
    114c:	ec 01       	movw	r28, r24
    114e:	04 2f       	mov	r16, r20
    1150:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1152:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1154:	41 11       	cpse	r20, r1
    1156:	0c c0       	rjmp	.+24     	; 0x1170 <prvCopyDataToQueue+0x2c>
    1158:	88 81       	ld	r24, Y
    115a:	99 81       	ldd	r25, Y+1	; 0x01
    115c:	89 2b       	or	r24, r25
    115e:	09 f0       	breq	.+2      	; 0x1162 <prvCopyDataToQueue+0x1e>
    1160:	42 c0       	rjmp	.+132    	; 0x11e6 <prvCopyDataToQueue+0xa2>
    1162:	8a 81       	ldd	r24, Y+2	; 0x02
    1164:	9b 81       	ldd	r25, Y+3	; 0x03
    1166:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <xTaskPriorityDisinherit>
    116a:	1b 82       	std	Y+3, r1	; 0x03
    116c:	1a 82       	std	Y+2, r1	; 0x02
    116e:	42 c0       	rjmp	.+132    	; 0x11f4 <prvCopyDataToQueue+0xb0>
    1170:	01 11       	cpse	r16, r1
    1172:	17 c0       	rjmp	.+46     	; 0x11a2 <prvCopyDataToQueue+0x5e>
    1174:	50 e0       	ldi	r21, 0x00	; 0
    1176:	8c 81       	ldd	r24, Y+4	; 0x04
    1178:	9d 81       	ldd	r25, Y+5	; 0x05
    117a:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <memcpy>
    117e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1180:	8c 81       	ldd	r24, Y+4	; 0x04
    1182:	9d 81       	ldd	r25, Y+5	; 0x05
    1184:	82 0f       	add	r24, r18
    1186:	91 1d       	adc	r25, r1
    1188:	9d 83       	std	Y+5, r25	; 0x05
    118a:	8c 83       	std	Y+4, r24	; 0x04
    118c:	2a 81       	ldd	r18, Y+2	; 0x02
    118e:	3b 81       	ldd	r19, Y+3	; 0x03
    1190:	82 17       	cp	r24, r18
    1192:	93 07       	cpc	r25, r19
    1194:	50 f1       	brcs	.+84     	; 0x11ea <prvCopyDataToQueue+0xa6>
    1196:	88 81       	ld	r24, Y
    1198:	99 81       	ldd	r25, Y+1	; 0x01
    119a:	9d 83       	std	Y+5, r25	; 0x05
    119c:	8c 83       	std	Y+4, r24	; 0x04
    119e:	80 e0       	ldi	r24, 0x00	; 0
    11a0:	29 c0       	rjmp	.+82     	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11a2:	50 e0       	ldi	r21, 0x00	; 0
    11a4:	8e 81       	ldd	r24, Y+6	; 0x06
    11a6:	9f 81       	ldd	r25, Y+7	; 0x07
    11a8:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <memcpy>
    11ac:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11ae:	90 e0       	ldi	r25, 0x00	; 0
    11b0:	91 95       	neg	r25
    11b2:	81 95       	neg	r24
    11b4:	91 09       	sbc	r25, r1
    11b6:	2e 81       	ldd	r18, Y+6	; 0x06
    11b8:	3f 81       	ldd	r19, Y+7	; 0x07
    11ba:	28 0f       	add	r18, r24
    11bc:	39 1f       	adc	r19, r25
    11be:	3f 83       	std	Y+7, r19	; 0x07
    11c0:	2e 83       	std	Y+6, r18	; 0x06
    11c2:	48 81       	ld	r20, Y
    11c4:	59 81       	ldd	r21, Y+1	; 0x01
    11c6:	24 17       	cp	r18, r20
    11c8:	35 07       	cpc	r19, r21
    11ca:	30 f4       	brcc	.+12     	; 0x11d8 <prvCopyDataToQueue+0x94>
    11cc:	2a 81       	ldd	r18, Y+2	; 0x02
    11ce:	3b 81       	ldd	r19, Y+3	; 0x03
    11d0:	82 0f       	add	r24, r18
    11d2:	93 1f       	adc	r25, r19
    11d4:	9f 83       	std	Y+7, r25	; 0x07
    11d6:	8e 83       	std	Y+6, r24	; 0x06
    11d8:	02 30       	cpi	r16, 0x02	; 2
    11da:	49 f4       	brne	.+18     	; 0x11ee <prvCopyDataToQueue+0xaa>
    11dc:	11 23       	and	r17, r17
    11de:	49 f0       	breq	.+18     	; 0x11f2 <prvCopyDataToQueue+0xae>
    11e0:	11 50       	subi	r17, 0x01	; 1
    11e2:	80 e0       	ldi	r24, 0x00	; 0
    11e4:	07 c0       	rjmp	.+14     	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11e6:	80 e0       	ldi	r24, 0x00	; 0
    11e8:	05 c0       	rjmp	.+10     	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	03 c0       	rjmp	.+6      	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	01 c0       	rjmp	.+2      	; 0x11f4 <prvCopyDataToQueue+0xb0>
    11f2:	80 e0       	ldi	r24, 0x00	; 0
    11f4:	1f 5f       	subi	r17, 0xFF	; 255
    11f6:	1a 8f       	std	Y+26, r17	; 0x1a
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	1f 91       	pop	r17
    11fe:	0f 91       	pop	r16
    1200:	08 95       	ret

00001202 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1202:	ef 92       	push	r14
    1204:	ff 92       	push	r15
    1206:	0f 93       	push	r16
    1208:	1f 93       	push	r17
    120a:	cf 93       	push	r28
    120c:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    120e:	0f b6       	in	r0, 0x3f	; 63
    1210:	f8 94       	cli
    1212:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1214:	fc 01       	movw	r30, r24
    1216:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1218:	1c 16       	cp	r1, r28
    121a:	ac f4       	brge	.+42     	; 0x1246 <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    121c:	81 89       	ldd	r24, Z+17	; 0x11
    121e:	81 11       	cpse	r24, r1
    1220:	06 c0       	rjmp	.+12     	; 0x122e <prvUnlockQueue+0x2c>
    1222:	11 c0       	rjmp	.+34     	; 0x1246 <prvUnlockQueue+0x44>
    1224:	f8 01       	movw	r30, r16
    1226:	81 89       	ldd	r24, Z+17	; 0x11
    1228:	81 11       	cpse	r24, r1
    122a:	05 c0       	rjmp	.+10     	; 0x1236 <prvUnlockQueue+0x34>
    122c:	0c c0       	rjmp	.+24     	; 0x1246 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    122e:	78 01       	movw	r14, r16
    1230:	f1 e1       	ldi	r31, 0x11	; 17
    1232:	ef 0e       	add	r14, r31
    1234:	f1 1c       	adc	r15, r1
    1236:	c7 01       	movw	r24, r14
    1238:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <xTaskRemoveFromEventList>
    123c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    123e:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <vTaskMissedYield>
    1242:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1244:	79 f7       	brne	.-34     	; 0x1224 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1246:	8f ef       	ldi	r24, 0xFF	; 255
    1248:	f8 01       	movw	r30, r16
    124a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    124c:	0f 90       	pop	r0
    124e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	f8 94       	cli
    1254:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1256:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1258:	1c 16       	cp	r1, r28
    125a:	ac f4       	brge	.+42     	; 0x1286 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    125c:	80 85       	ldd	r24, Z+8	; 0x08
    125e:	81 11       	cpse	r24, r1
    1260:	06 c0       	rjmp	.+12     	; 0x126e <prvUnlockQueue+0x6c>
    1262:	11 c0       	rjmp	.+34     	; 0x1286 <prvUnlockQueue+0x84>
    1264:	f8 01       	movw	r30, r16
    1266:	80 85       	ldd	r24, Z+8	; 0x08
    1268:	81 11       	cpse	r24, r1
    126a:	05 c0       	rjmp	.+10     	; 0x1276 <prvUnlockQueue+0x74>
    126c:	0c c0       	rjmp	.+24     	; 0x1286 <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    126e:	78 01       	movw	r14, r16
    1270:	f8 e0       	ldi	r31, 0x08	; 8
    1272:	ef 0e       	add	r14, r31
    1274:	f1 1c       	adc	r15, r1
    1276:	c7 01       	movw	r24, r14
    1278:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <xTaskRemoveFromEventList>
    127c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    127e:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <vTaskMissedYield>
    1282:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1284:	79 f7       	brne	.-34     	; 0x1264 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1286:	8f ef       	ldi	r24, 0xFF	; 255
    1288:	f8 01       	movw	r30, r16
    128a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    128c:	0f 90       	pop	r0
    128e:	0f be       	out	0x3f, r0	; 63
}
    1290:	cf 91       	pop	r28
    1292:	1f 91       	pop	r17
    1294:	0f 91       	pop	r16
    1296:	ff 90       	pop	r15
    1298:	ef 90       	pop	r14
    129a:	08 95       	ret

0000129c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
    12a0:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    12a2:	0f b6       	in	r0, 0x3f	; 63
    12a4:	f8 94       	cli
    12a6:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    12a8:	48 81       	ld	r20, Y
    12aa:	59 81       	ldd	r21, Y+1	; 0x01
    12ac:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12ae:	30 e0       	ldi	r19, 0x00	; 0
    12b0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    12b2:	72 9f       	mul	r23, r18
    12b4:	c0 01       	movw	r24, r0
    12b6:	73 9f       	mul	r23, r19
    12b8:	90 0d       	add	r25, r0
    12ba:	11 24       	eor	r1, r1
    12bc:	fa 01       	movw	r30, r20
    12be:	e8 0f       	add	r30, r24
    12c0:	f9 1f       	adc	r31, r25
    12c2:	fb 83       	std	Y+3, r31	; 0x03
    12c4:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    12c6:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    12c8:	5d 83       	std	Y+5, r21	; 0x05
    12ca:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    12cc:	82 1b       	sub	r24, r18
    12ce:	93 0b       	sbc	r25, r19
    12d0:	84 0f       	add	r24, r20
    12d2:	95 1f       	adc	r25, r21
    12d4:	9f 83       	std	Y+7, r25	; 0x07
    12d6:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    12d8:	8f ef       	ldi	r24, 0xFF	; 255
    12da:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    12dc:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    12de:	61 11       	cpse	r22, r1
    12e0:	0c c0       	rjmp	.+24     	; 0x12fa <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12e2:	88 85       	ldd	r24, Y+8	; 0x08
    12e4:	88 23       	and	r24, r24
    12e6:	89 f0       	breq	.+34     	; 0x130a <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12e8:	ce 01       	movw	r24, r28
    12ea:	08 96       	adiw	r24, 0x08	; 8
    12ec:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <xTaskRemoveFromEventList>
    12f0:	88 23       	and	r24, r24
    12f2:	59 f0       	breq	.+22     	; 0x130a <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
    12f4:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
    12f8:	08 c0       	rjmp	.+16     	; 0x130a <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    12fa:	ce 01       	movw	r24, r28
    12fc:	08 96       	adiw	r24, 0x08	; 8
    12fe:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1302:	ce 01       	movw	r24, r28
    1304:	41 96       	adiw	r24, 0x11	; 17
    1306:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    130a:	0f 90       	pop	r0
    130c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	08 95       	ret

00001316 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1316:	ff 92       	push	r15
    1318:	0f 93       	push	r16
    131a:	1f 93       	push	r17
    131c:	cf 93       	push	r28
    131e:	df 93       	push	r29
    1320:	08 2f       	mov	r16, r24
    1322:	16 2f       	mov	r17, r22
    1324:	f4 2e       	mov	r15, r20
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1326:	66 23       	and	r22, r22
    1328:	c9 f0       	breq	.+50     	; 0x135c <xQueueGenericCreate+0x46>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    132a:	86 9f       	mul	r24, r22
    132c:	c0 01       	movw	r24, r0
    132e:	11 24       	eor	r1, r1
    1330:	81 96       	adiw	r24, 0x21	; 33
    1332:	0e 94 a3 06 	call	0xd46	; 0xd46 <pvPortMalloc>
    1336:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1338:	00 97       	sbiw	r24, 0x00	; 0
    133a:	49 f4       	brne	.+18     	; 0x134e <xQueueGenericCreate+0x38>
    133c:	16 c0       	rjmp	.+44     	; 0x136a <xQueueGenericCreate+0x54>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    133e:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1340:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1342:	61 e0       	ldi	r22, 0x01	; 1
    1344:	ce 01       	movw	r24, r28
    1346:	0e 94 4e 09 	call	0x129c	; 0x129c <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    134a:	f8 a2       	std	Y+32, r15	; 0x20
    134c:	0e c0       	rjmp	.+28     	; 0x136a <xQueueGenericCreate+0x54>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    134e:	81 96       	adiw	r24, 0x21	; 33
    1350:	99 83       	std	Y+1, r25	; 0x01
    1352:	88 83       	st	Y, r24
    1354:	f4 cf       	rjmp	.-24     	; 0x133e <xQueueGenericCreate+0x28>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1356:	d9 83       	std	Y+1, r29	; 0x01
    1358:	c8 83       	st	Y, r28
    135a:	f1 cf       	rjmp	.-30     	; 0x133e <xQueueGenericCreate+0x28>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    135c:	81 e2       	ldi	r24, 0x21	; 33
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	0e 94 a3 06 	call	0xd46	; 0xd46 <pvPortMalloc>
    1364:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1366:	89 2b       	or	r24, r25
    1368:	b1 f7       	brne	.-20     	; 0x1356 <xQueueGenericCreate+0x40>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    136a:	ce 01       	movw	r24, r28
    136c:	df 91       	pop	r29
    136e:	cf 91       	pop	r28
    1370:	1f 91       	pop	r17
    1372:	0f 91       	pop	r16
    1374:	ff 90       	pop	r15
    1376:	08 95       	ret

00001378 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1378:	9f 92       	push	r9
    137a:	af 92       	push	r10
    137c:	bf 92       	push	r11
    137e:	cf 92       	push	r12
    1380:	df 92       	push	r13
    1382:	ef 92       	push	r14
    1384:	ff 92       	push	r15
    1386:	0f 93       	push	r16
    1388:	1f 93       	push	r17
    138a:	cf 93       	push	r28
    138c:	df 93       	push	r29
    138e:	00 d0       	rcall	.+0      	; 0x1390 <xQueueGenericSend+0x18>
    1390:	00 d0       	rcall	.+0      	; 0x1392 <xQueueGenericSend+0x1a>
    1392:	1f 92       	push	r1
    1394:	cd b7       	in	r28, 0x3d	; 61
    1396:	de b7       	in	r29, 0x3e	; 62
    1398:	8c 01       	movw	r16, r24
    139a:	6b 01       	movw	r12, r22
    139c:	5d 83       	std	Y+5, r21	; 0x05
    139e:	4c 83       	std	Y+4, r20	; 0x04
    13a0:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    13a2:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    13a4:	99 24       	eor	r9, r9
    13a6:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13a8:	7c 01       	movw	r14, r24
    13aa:	88 e0       	ldi	r24, 0x08	; 8
    13ac:	e8 0e       	add	r14, r24
    13ae:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    13b0:	0f b6       	in	r0, 0x3f	; 63
    13b2:	f8 94       	cli
    13b4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13b6:	f8 01       	movw	r30, r16
    13b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    13ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    13bc:	98 17       	cp	r25, r24
    13be:	18 f0       	brcs	.+6      	; 0x13c6 <xQueueGenericSend+0x4e>
    13c0:	f2 e0       	ldi	r31, 0x02	; 2
    13c2:	af 12       	cpse	r10, r31
    13c4:	19 c0       	rjmp	.+50     	; 0x13f8 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13c6:	4a 2d       	mov	r20, r10
    13c8:	b6 01       	movw	r22, r12
    13ca:	c8 01       	movw	r24, r16
    13cc:	0e 94 a2 08 	call	0x1144	; 0x1144 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13d0:	f8 01       	movw	r30, r16
    13d2:	91 89       	ldd	r25, Z+17	; 0x11
    13d4:	99 23       	and	r25, r25
    13d6:	49 f0       	breq	.+18     	; 0x13ea <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13d8:	c8 01       	movw	r24, r16
    13da:	41 96       	adiw	r24, 0x11	; 17
    13dc:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <xTaskRemoveFromEventList>
    13e0:	88 23       	and	r24, r24
    13e2:	31 f0       	breq	.+12     	; 0x13f0 <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    13e4:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
    13e8:	03 c0       	rjmp	.+6      	; 0x13f0 <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    13ea:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    13ec:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    13f0:	0f 90       	pop	r0
    13f2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	50 c0       	rjmp	.+160    	; 0x1498 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    13f8:	8c 81       	ldd	r24, Y+4	; 0x04
    13fa:	9d 81       	ldd	r25, Y+5	; 0x05
    13fc:	89 2b       	or	r24, r25
    13fe:	21 f4       	brne	.+8      	; 0x1408 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1400:	0f 90       	pop	r0
    1402:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1404:	80 e0       	ldi	r24, 0x00	; 0
    1406:	48 c0       	rjmp	.+144    	; 0x1498 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
    1408:	b1 10       	cpse	r11, r1
    140a:	05 c0       	rjmp	.+10     	; 0x1416 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    140c:	ce 01       	movw	r24, r28
    140e:	01 96       	adiw	r24, 0x01	; 1
    1410:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1414:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1416:	0f 90       	pop	r0
    1418:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    141a:	0e 94 53 0c 	call	0x18a6	; 0x18a6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    141e:	0f b6       	in	r0, 0x3f	; 63
    1420:	f8 94       	cli
    1422:	0f 92       	push	r0
    1424:	f8 01       	movw	r30, r16
    1426:	85 8d       	ldd	r24, Z+29	; 0x1d
    1428:	8f 3f       	cpi	r24, 0xFF	; 255
    142a:	09 f4       	brne	.+2      	; 0x142e <xQueueGenericSend+0xb6>
    142c:	15 8e       	std	Z+29, r1	; 0x1d
    142e:	f8 01       	movw	r30, r16
    1430:	86 8d       	ldd	r24, Z+30	; 0x1e
    1432:	8f 3f       	cpi	r24, 0xFF	; 255
    1434:	09 f4       	brne	.+2      	; 0x1438 <xQueueGenericSend+0xc0>
    1436:	16 8e       	std	Z+30, r1	; 0x1e
    1438:	0f 90       	pop	r0
    143a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    143c:	be 01       	movw	r22, r28
    143e:	6c 5f       	subi	r22, 0xFC	; 252
    1440:	7f 4f       	sbci	r23, 0xFF	; 255
    1442:	ce 01       	movw	r24, r28
    1444:	01 96       	adiw	r24, 0x01	; 1
    1446:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskCheckForTimeOut>
    144a:	81 11       	cpse	r24, r1
    144c:	1f c0       	rjmp	.+62     	; 0x148c <xQueueGenericSend+0x114>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1454:	f8 01       	movw	r30, r16
    1456:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1458:	0f 90       	pop	r0
    145a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    145c:	83 8d       	ldd	r24, Z+27	; 0x1b
    145e:	98 13       	cpse	r25, r24
    1460:	0f c0       	rjmp	.+30     	; 0x1480 <xQueueGenericSend+0x108>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1462:	6c 81       	ldd	r22, Y+4	; 0x04
    1464:	7d 81       	ldd	r23, Y+5	; 0x05
    1466:	c7 01       	movw	r24, r14
    1468:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    146c:	c8 01       	movw	r24, r16
    146e:	0e 94 01 09 	call	0x1202	; 0x1202 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1472:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskResumeAll>
    1476:	81 11       	cpse	r24, r1
    1478:	9b cf       	rjmp	.-202    	; 0x13b0 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    147a:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
    147e:	98 cf       	rjmp	.-208    	; 0x13b0 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1480:	c8 01       	movw	r24, r16
    1482:	0e 94 01 09 	call	0x1202	; 0x1202 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1486:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskResumeAll>
    148a:	92 cf       	rjmp	.-220    	; 0x13b0 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    148c:	c8 01       	movw	r24, r16
    148e:	0e 94 01 09 	call	0x1202	; 0x1202 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1492:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1496:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1498:	0f 90       	pop	r0
    149a:	0f 90       	pop	r0
    149c:	0f 90       	pop	r0
    149e:	0f 90       	pop	r0
    14a0:	0f 90       	pop	r0
    14a2:	df 91       	pop	r29
    14a4:	cf 91       	pop	r28
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	ff 90       	pop	r15
    14ac:	ef 90       	pop	r14
    14ae:	df 90       	pop	r13
    14b0:	cf 90       	pop	r12
    14b2:	bf 90       	pop	r11
    14b4:	af 90       	pop	r10
    14b6:	9f 90       	pop	r9
    14b8:	08 95       	ret

000014ba <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    14be:	48 2f       	mov	r20, r24
    14c0:	60 e0       	ldi	r22, 0x00	; 0
    14c2:	81 e0       	ldi	r24, 0x01	; 1
    14c4:	0e 94 8b 09 	call	0x1316	; 0x1316 <xQueueGenericCreate>
    14c8:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    14ca:	00 97       	sbiw	r24, 0x00	; 0
    14cc:	61 f0       	breq	.+24     	; 0x14e6 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    14ce:	1b 82       	std	Y+3, r1	; 0x03
    14d0:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    14d2:	19 82       	std	Y+1, r1	; 0x01
    14d4:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    14d6:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    14d8:	20 e0       	ldi	r18, 0x00	; 0
    14da:	40 e0       	ldi	r20, 0x00	; 0
    14dc:	50 e0       	ldi	r21, 0x00	; 0
    14de:	60 e0       	ldi	r22, 0x00	; 0
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	0e 94 bc 09 	call	0x1378	; 0x1378 <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    14e6:	ce 01       	movw	r24, r28
    14e8:	df 91       	pop	r29
    14ea:	cf 91       	pop	r28
    14ec:	08 95       	ret

000014ee <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    14ee:	ef 92       	push	r14
    14f0:	ff 92       	push	r15
    14f2:	0f 93       	push	r16
    14f4:	1f 93       	push	r17
    14f6:	cf 93       	push	r28
    14f8:	df 93       	push	r29
    14fa:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    14fc:	fc 01       	movw	r30, r24
    14fe:	52 8d       	ldd	r21, Z+26	; 0x1a
    1500:	33 8d       	ldd	r19, Z+27	; 0x1b
    1502:	53 17       	cp	r21, r19
    1504:	10 f0       	brcs	.+4      	; 0x150a <xQueueGenericSendFromISR+0x1c>
    1506:	22 30       	cpi	r18, 0x02	; 2
    1508:	f1 f4       	brne	.+60     	; 0x1546 <xQueueGenericSendFromISR+0x58>
    150a:	42 2f       	mov	r20, r18
    150c:	78 01       	movw	r14, r16
    150e:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1510:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1512:	0e 94 a2 08 	call	0x1144	; 0x1144 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1516:	1f 3f       	cpi	r17, 0xFF	; 255
    1518:	81 f4       	brne	.+32     	; 0x153a <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    151a:	89 89       	ldd	r24, Y+17	; 0x11
    151c:	88 23       	and	r24, r24
    151e:	a9 f0       	breq	.+42     	; 0x154a <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1520:	ce 01       	movw	r24, r28
    1522:	41 96       	adiw	r24, 0x11	; 17
    1524:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <xTaskRemoveFromEventList>
    1528:	88 23       	and	r24, r24
    152a:	89 f0       	breq	.+34     	; 0x154e <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    152c:	e1 14       	cp	r14, r1
    152e:	f1 04       	cpc	r15, r1
    1530:	81 f0       	breq	.+32     	; 0x1552 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	f7 01       	movw	r30, r14
    1536:	80 83       	st	Z, r24
    1538:	0d c0       	rjmp	.+26     	; 0x1554 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    153a:	ff 24       	eor	r15, r15
    153c:	f3 94       	inc	r15
    153e:	f1 0e       	add	r15, r17
    1540:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
    1542:	81 e0       	ldi	r24, 0x01	; 1
    1544:	07 c0       	rjmp	.+14     	; 0x1554 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1546:	80 e0       	ldi	r24, 0x00	; 0
    1548:	05 c0       	rjmp	.+10     	; 0x1554 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	03 c0       	rjmp	.+6      	; 0x1554 <xQueueGenericSendFromISR+0x66>
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	01 c0       	rjmp	.+2      	; 0x1554 <xQueueGenericSendFromISR+0x66>
    1552:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1554:	df 91       	pop	r29
    1556:	cf 91       	pop	r28
    1558:	1f 91       	pop	r17
    155a:	0f 91       	pop	r16
    155c:	ff 90       	pop	r15
    155e:	ef 90       	pop	r14
    1560:	08 95       	ret

00001562 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1562:	e0 91 5e 07 	lds	r30, 0x075E	; 0x80075e <pxDelayedTaskList>
    1566:	f0 91 5f 07 	lds	r31, 0x075F	; 0x80075f <pxDelayedTaskList+0x1>
    156a:	80 81       	ld	r24, Z
    156c:	81 11       	cpse	r24, r1
    156e:	07 c0       	rjmp	.+14     	; 0x157e <prvResetNextTaskUnblockTime+0x1c>
    1570:	8f ef       	ldi	r24, 0xFF	; 255
    1572:	9f ef       	ldi	r25, 0xFF	; 255
    1574:	90 93 3f 07 	sts	0x073F, r25	; 0x80073f <xNextTaskUnblockTime+0x1>
    1578:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <xNextTaskUnblockTime>
    157c:	08 95       	ret
    157e:	e0 91 5e 07 	lds	r30, 0x075E	; 0x80075e <pxDelayedTaskList>
    1582:	f0 91 5f 07 	lds	r31, 0x075F	; 0x80075f <pxDelayedTaskList+0x1>
    1586:	05 80       	ldd	r0, Z+5	; 0x05
    1588:	f6 81       	ldd	r31, Z+6	; 0x06
    158a:	e0 2d       	mov	r30, r0
    158c:	06 80       	ldd	r0, Z+6	; 0x06
    158e:	f7 81       	ldd	r31, Z+7	; 0x07
    1590:	e0 2d       	mov	r30, r0
    1592:	82 81       	ldd	r24, Z+2	; 0x02
    1594:	93 81       	ldd	r25, Z+3	; 0x03
    1596:	90 93 3f 07 	sts	0x073F, r25	; 0x80073f <xNextTaskUnblockTime+0x1>
    159a:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <xNextTaskUnblockTime>
    159e:	08 95       	ret

000015a0 <prvAddCurrentTaskToDelayedList>:
    15a0:	0f 93       	push	r16
    15a2:	1f 93       	push	r17
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	ec 01       	movw	r28, r24
    15aa:	00 91 46 07 	lds	r16, 0x0746	; 0x800746 <xTickCount>
    15ae:	10 91 47 07 	lds	r17, 0x0747	; 0x800747 <xTickCount+0x1>
    15b2:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <pxCurrentTCB>
    15b6:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    15ba:	02 96       	adiw	r24, 0x02	; 2
    15bc:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    15c0:	c0 0f       	add	r28, r16
    15c2:	d1 1f       	adc	r29, r17
    15c4:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    15c8:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    15cc:	d3 83       	std	Z+3, r29	; 0x03
    15ce:	c2 83       	std	Z+2, r28	; 0x02
    15d0:	c0 17       	cp	r28, r16
    15d2:	d1 07       	cpc	r29, r17
    15d4:	68 f4       	brcc	.+26     	; 0x15f0 <prvAddCurrentTaskToDelayedList+0x50>
    15d6:	60 91 96 07 	lds	r22, 0x0796	; 0x800796 <pxCurrentTCB>
    15da:	70 91 97 07 	lds	r23, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    15de:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <pxOverflowDelayedTaskList>
    15e2:	90 91 5d 07 	lds	r25, 0x075D	; 0x80075d <pxOverflowDelayedTaskList+0x1>
    15e6:	6e 5f       	subi	r22, 0xFE	; 254
    15e8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ea:	0e 94 ee 04 	call	0x9dc	; 0x9dc <vListInsert>
    15ee:	17 c0       	rjmp	.+46     	; 0x161e <prvAddCurrentTaskToDelayedList+0x7e>
    15f0:	60 91 96 07 	lds	r22, 0x0796	; 0x800796 <pxCurrentTCB>
    15f4:	70 91 97 07 	lds	r23, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    15f8:	80 91 5e 07 	lds	r24, 0x075E	; 0x80075e <pxDelayedTaskList>
    15fc:	90 91 5f 07 	lds	r25, 0x075F	; 0x80075f <pxDelayedTaskList+0x1>
    1600:	6e 5f       	subi	r22, 0xFE	; 254
    1602:	7f 4f       	sbci	r23, 0xFF	; 255
    1604:	0e 94 ee 04 	call	0x9dc	; 0x9dc <vListInsert>
    1608:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <xNextTaskUnblockTime>
    160c:	90 91 3f 07 	lds	r25, 0x073F	; 0x80073f <xNextTaskUnblockTime+0x1>
    1610:	c8 17       	cp	r28, r24
    1612:	d9 07       	cpc	r29, r25
    1614:	20 f4       	brcc	.+8      	; 0x161e <prvAddCurrentTaskToDelayedList+0x7e>
    1616:	d0 93 3f 07 	sts	0x073F, r29	; 0x80073f <xNextTaskUnblockTime+0x1>
    161a:	c0 93 3e 07 	sts	0x073E, r28	; 0x80073e <xNextTaskUnblockTime>
    161e:	df 91       	pop	r29
    1620:	cf 91       	pop	r28
    1622:	1f 91       	pop	r17
    1624:	0f 91       	pop	r16
    1626:	08 95       	ret

00001628 <xTaskCreate>:
    1628:	4f 92       	push	r4
    162a:	5f 92       	push	r5
    162c:	6f 92       	push	r6
    162e:	7f 92       	push	r7
    1630:	8f 92       	push	r8
    1632:	9f 92       	push	r9
    1634:	af 92       	push	r10
    1636:	bf 92       	push	r11
    1638:	cf 92       	push	r12
    163a:	df 92       	push	r13
    163c:	ef 92       	push	r14
    163e:	ff 92       	push	r15
    1640:	0f 93       	push	r16
    1642:	cf 93       	push	r28
    1644:	df 93       	push	r29
    1646:	4c 01       	movw	r8, r24
    1648:	6b 01       	movw	r12, r22
    164a:	5a 01       	movw	r10, r20
    164c:	29 01       	movw	r4, r18
    164e:	ca 01       	movw	r24, r20
    1650:	0e 94 a3 06 	call	0xd46	; 0xd46 <pvPortMalloc>
    1654:	3c 01       	movw	r6, r24
    1656:	89 2b       	or	r24, r25
    1658:	09 f4       	brne	.+2      	; 0x165c <xTaskCreate+0x34>
    165a:	ea c0       	rjmp	.+468    	; 0x1830 <xTaskCreate+0x208>
    165c:	8c e2       	ldi	r24, 0x2C	; 44
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	0e 94 a3 06 	call	0xd46	; 0xd46 <pvPortMalloc>
    1664:	ec 01       	movw	r28, r24
    1666:	89 2b       	or	r24, r25
    1668:	b1 f0       	breq	.+44     	; 0x1696 <xTaskCreate+0x6e>
    166a:	78 8e       	std	Y+24, r7	; 0x18
    166c:	6f 8a       	std	Y+23, r6	; 0x17
    166e:	a5 01       	movw	r20, r10
    1670:	65 ea       	ldi	r22, 0xA5	; 165
    1672:	70 e0       	ldi	r23, 0x00	; 0
    1674:	c3 01       	movw	r24, r6
    1676:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <memset>
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	a8 1a       	sub	r10, r24
    167e:	b1 08       	sbc	r11, r1
    1680:	8f 89       	ldd	r24, Y+23	; 0x17
    1682:	98 8d       	ldd	r25, Y+24	; 0x18
    1684:	a8 0e       	add	r10, r24
    1686:	b9 1e       	adc	r11, r25
    1688:	d6 01       	movw	r26, r12
    168a:	8c 91       	ld	r24, X
    168c:	89 8f       	std	Y+25, r24	; 0x19
    168e:	8c 91       	ld	r24, X
    1690:	81 11       	cpse	r24, r1
    1692:	05 c0       	rjmp	.+10     	; 0x169e <xTaskCreate+0x76>
    1694:	18 c0       	rjmp	.+48     	; 0x16c6 <xTaskCreate+0x9e>
    1696:	c3 01       	movw	r24, r6
    1698:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortFree>
    169c:	c9 c0       	rjmp	.+402    	; 0x1830 <xTaskCreate+0x208>
    169e:	ae 01       	movw	r20, r28
    16a0:	46 5e       	subi	r20, 0xE6	; 230
    16a2:	5f 4f       	sbci	r21, 0xFF	; 255
    16a4:	f6 01       	movw	r30, r12
    16a6:	31 96       	adiw	r30, 0x01	; 1
    16a8:	b8 e0       	ldi	r27, 0x08	; 8
    16aa:	cb 0e       	add	r12, r27
    16ac:	d1 1c       	adc	r13, r1
    16ae:	cf 01       	movw	r24, r30
    16b0:	21 91       	ld	r18, Z+
    16b2:	da 01       	movw	r26, r20
    16b4:	2d 93       	st	X+, r18
    16b6:	ad 01       	movw	r20, r26
    16b8:	dc 01       	movw	r26, r24
    16ba:	8c 91       	ld	r24, X
    16bc:	88 23       	and	r24, r24
    16be:	19 f0       	breq	.+6      	; 0x16c6 <xTaskCreate+0x9e>
    16c0:	ec 15       	cp	r30, r12
    16c2:	fd 05       	cpc	r31, r13
    16c4:	a1 f7       	brne	.-24     	; 0x16ae <xTaskCreate+0x86>
    16c6:	18 a2       	std	Y+32, r1	; 0x20
    16c8:	04 30       	cpi	r16, 0x04	; 4
    16ca:	08 f0       	brcs	.+2      	; 0x16ce <xTaskCreate+0xa6>
    16cc:	03 e0       	ldi	r16, 0x03	; 3
    16ce:	0e 8b       	std	Y+22, r16	; 0x16
    16d0:	0b a3       	std	Y+35, r16	; 0x23
    16d2:	1c a2       	std	Y+36, r1	; 0x24
    16d4:	6e 01       	movw	r12, r28
    16d6:	b2 e0       	ldi	r27, 0x02	; 2
    16d8:	cb 0e       	add	r12, r27
    16da:	d1 1c       	adc	r13, r1
    16dc:	c6 01       	movw	r24, r12
    16de:	0e 94 c9 04 	call	0x992	; 0x992 <vListInitialiseItem>
    16e2:	ce 01       	movw	r24, r28
    16e4:	0c 96       	adiw	r24, 0x0c	; 12
    16e6:	0e 94 c9 04 	call	0x992	; 0x992 <vListInitialiseItem>
    16ea:	d9 87       	std	Y+9, r29	; 0x09
    16ec:	c8 87       	std	Y+8, r28	; 0x08
    16ee:	84 e0       	ldi	r24, 0x04	; 4
    16f0:	90 e0       	ldi	r25, 0x00	; 0
    16f2:	80 1b       	sub	r24, r16
    16f4:	91 09       	sbc	r25, r1
    16f6:	9d 87       	std	Y+13, r25	; 0x0d
    16f8:	8c 87       	std	Y+12, r24	; 0x0c
    16fa:	db 8b       	std	Y+19, r29	; 0x13
    16fc:	ca 8b       	std	Y+18, r28	; 0x12
    16fe:	1e a2       	std	Y+38, r1	; 0x26
    1700:	1d a2       	std	Y+37, r1	; 0x25
    1702:	1f a2       	std	Y+39, r1	; 0x27
    1704:	18 a6       	std	Y+40, r1	; 0x28
    1706:	19 a6       	std	Y+41, r1	; 0x29
    1708:	1a a6       	std	Y+42, r1	; 0x2a
    170a:	1b a6       	std	Y+43, r1	; 0x2b
    170c:	a2 01       	movw	r20, r4
    170e:	b4 01       	movw	r22, r8
    1710:	c5 01       	movw	r24, r10
    1712:	0e 94 45 05 	call	0xa8a	; 0xa8a <pxPortInitialiseStack>
    1716:	99 83       	std	Y+1, r25	; 0x01
    1718:	88 83       	st	Y, r24
    171a:	e1 14       	cp	r14, r1
    171c:	f1 04       	cpc	r15, r1
    171e:	19 f0       	breq	.+6      	; 0x1726 <xTaskCreate+0xfe>
    1720:	f7 01       	movw	r30, r14
    1722:	d1 83       	std	Z+1, r29	; 0x01
    1724:	c0 83       	st	Z, r28
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	0f 92       	push	r0
    172c:	80 91 48 07 	lds	r24, 0x0748	; 0x800748 <uxCurrentNumberOfTasks>
    1730:	8f 5f       	subi	r24, 0xFF	; 255
    1732:	80 93 48 07 	sts	0x0748, r24	; 0x800748 <uxCurrentNumberOfTasks>
    1736:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <pxCurrentTCB>
    173a:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    173e:	89 2b       	or	r24, r25
    1740:	a9 f5       	brne	.+106    	; 0x17ac <xTaskCreate+0x184>
    1742:	d0 93 97 07 	sts	0x0797, r29	; 0x800797 <pxCurrentTCB+0x1>
    1746:	c0 93 96 07 	sts	0x0796, r28	; 0x800796 <pxCurrentTCB>
    174a:	80 91 48 07 	lds	r24, 0x0748	; 0x800748 <uxCurrentNumberOfTasks>
    174e:	81 30       	cpi	r24, 0x01	; 1
    1750:	e9 f5       	brne	.+122    	; 0x17cc <xTaskCreate+0x1a4>
    1752:	82 e7       	ldi	r24, 0x72	; 114
    1754:	97 e0       	ldi	r25, 0x07	; 7
    1756:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    175a:	8b e7       	ldi	r24, 0x7B	; 123
    175c:	97 e0       	ldi	r25, 0x07	; 7
    175e:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    1762:	84 e8       	ldi	r24, 0x84	; 132
    1764:	97 e0       	ldi	r25, 0x07	; 7
    1766:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    176a:	8d e8       	ldi	r24, 0x8D	; 141
    176c:	97 e0       	ldi	r25, 0x07	; 7
    176e:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    1772:	89 e6       	ldi	r24, 0x69	; 105
    1774:	97 e0       	ldi	r25, 0x07	; 7
    1776:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    177a:	80 e6       	ldi	r24, 0x60	; 96
    177c:	97 e0       	ldi	r25, 0x07	; 7
    177e:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    1782:	83 e5       	ldi	r24, 0x53	; 83
    1784:	97 e0       	ldi	r25, 0x07	; 7
    1786:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    178a:	8a e4       	ldi	r24, 0x4A	; 74
    178c:	97 e0       	ldi	r25, 0x07	; 7
    178e:	0e 94 bb 04 	call	0x976	; 0x976 <vListInitialise>
    1792:	89 e6       	ldi	r24, 0x69	; 105
    1794:	97 e0       	ldi	r25, 0x07	; 7
    1796:	90 93 5f 07 	sts	0x075F, r25	; 0x80075f <pxDelayedTaskList+0x1>
    179a:	80 93 5e 07 	sts	0x075E, r24	; 0x80075e <pxDelayedTaskList>
    179e:	80 e6       	ldi	r24, 0x60	; 96
    17a0:	97 e0       	ldi	r25, 0x07	; 7
    17a2:	90 93 5d 07 	sts	0x075D, r25	; 0x80075d <pxOverflowDelayedTaskList+0x1>
    17a6:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <pxOverflowDelayedTaskList>
    17aa:	10 c0       	rjmp	.+32     	; 0x17cc <xTaskCreate+0x1a4>
    17ac:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <xSchedulerRunning>
    17b0:	81 11       	cpse	r24, r1
    17b2:	0c c0       	rjmp	.+24     	; 0x17cc <xTaskCreate+0x1a4>
    17b4:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    17b8:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    17bc:	96 89       	ldd	r25, Z+22	; 0x16
    17be:	8e 89       	ldd	r24, Y+22	; 0x16
    17c0:	89 17       	cp	r24, r25
    17c2:	20 f0       	brcs	.+8      	; 0x17cc <xTaskCreate+0x1a4>
    17c4:	d0 93 97 07 	sts	0x0797, r29	; 0x800797 <pxCurrentTCB+0x1>
    17c8:	c0 93 96 07 	sts	0x0796, r28	; 0x800796 <pxCurrentTCB>
    17cc:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxTaskNumber>
    17d0:	8f 5f       	subi	r24, 0xFF	; 255
    17d2:	80 93 40 07 	sts	0x0740, r24	; 0x800740 <uxTaskNumber>
    17d6:	89 a3       	std	Y+33, r24	; 0x21
    17d8:	8e 89       	ldd	r24, Y+22	; 0x16
    17da:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <uxTopReadyPriority>
    17de:	98 17       	cp	r25, r24
    17e0:	10 f4       	brcc	.+4      	; 0x17e6 <xTaskCreate+0x1be>
    17e2:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <uxTopReadyPriority>
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	9c 01       	movw	r18, r24
    17ea:	22 0f       	add	r18, r18
    17ec:	33 1f       	adc	r19, r19
    17ee:	22 0f       	add	r18, r18
    17f0:	33 1f       	adc	r19, r19
    17f2:	22 0f       	add	r18, r18
    17f4:	33 1f       	adc	r19, r19
    17f6:	82 0f       	add	r24, r18
    17f8:	93 1f       	adc	r25, r19
    17fa:	b6 01       	movw	r22, r12
    17fc:	8e 58       	subi	r24, 0x8E	; 142
    17fe:	98 4f       	sbci	r25, 0xF8	; 248
    1800:	0e 94 cd 04 	call	0x99a	; 0x99a <vListInsertEnd>
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <xSchedulerRunning>
    180c:	88 23       	and	r24, r24
    180e:	61 f0       	breq	.+24     	; 0x1828 <xTaskCreate+0x200>
    1810:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    1814:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    1818:	96 89       	ldd	r25, Z+22	; 0x16
    181a:	8e 89       	ldd	r24, Y+22	; 0x16
    181c:	98 17       	cp	r25, r24
    181e:	30 f4       	brcc	.+12     	; 0x182c <xTaskCreate+0x204>
    1820:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	05 c0       	rjmp	.+10     	; 0x1832 <xTaskCreate+0x20a>
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	03 c0       	rjmp	.+6      	; 0x1832 <xTaskCreate+0x20a>
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	01 c0       	rjmp	.+2      	; 0x1832 <xTaskCreate+0x20a>
    1830:	8f ef       	ldi	r24, 0xFF	; 255
    1832:	df 91       	pop	r29
    1834:	cf 91       	pop	r28
    1836:	0f 91       	pop	r16
    1838:	ff 90       	pop	r15
    183a:	ef 90       	pop	r14
    183c:	df 90       	pop	r13
    183e:	cf 90       	pop	r12
    1840:	bf 90       	pop	r11
    1842:	af 90       	pop	r10
    1844:	9f 90       	pop	r9
    1846:	8f 90       	pop	r8
    1848:	7f 90       	pop	r7
    184a:	6f 90       	pop	r6
    184c:	5f 90       	pop	r5
    184e:	4f 90       	pop	r4
    1850:	08 95       	ret

00001852 <vTaskStartScheduler>:
    1852:	ef 92       	push	r14
    1854:	ff 92       	push	r15
    1856:	0f 93       	push	r16
    1858:	0f 2e       	mov	r0, r31
    185a:	fc e3       	ldi	r31, 0x3C	; 60
    185c:	ef 2e       	mov	r14, r31
    185e:	f7 e0       	ldi	r31, 0x07	; 7
    1860:	ff 2e       	mov	r15, r31
    1862:	f0 2d       	mov	r31, r0
    1864:	00 e0       	ldi	r16, 0x00	; 0
    1866:	20 e0       	ldi	r18, 0x00	; 0
    1868:	30 e0       	ldi	r19, 0x00	; 0
    186a:	45 e5       	ldi	r20, 0x55	; 85
    186c:	50 e0       	ldi	r21, 0x00	; 0
    186e:	68 e3       	ldi	r22, 0x38	; 56
    1870:	71 e0       	ldi	r23, 0x01	; 1
    1872:	87 ea       	ldi	r24, 0xA7	; 167
    1874:	9d e0       	ldi	r25, 0x0D	; 13
    1876:	0e 94 14 0b 	call	0x1628	; 0x1628 <xTaskCreate>
    187a:	81 30       	cpi	r24, 0x01	; 1
    187c:	81 f4       	brne	.+32     	; 0x189e <vTaskStartScheduler+0x4c>
    187e:	f8 94       	cli
    1880:	8f ef       	ldi	r24, 0xFF	; 255
    1882:	9f ef       	ldi	r25, 0xFF	; 255
    1884:	90 93 3f 07 	sts	0x073F, r25	; 0x80073f <xNextTaskUnblockTime+0x1>
    1888:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <xNextTaskUnblockTime>
    188c:	81 e0       	ldi	r24, 0x01	; 1
    188e:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <xSchedulerRunning>
    1892:	10 92 47 07 	sts	0x0747, r1	; 0x800747 <xTickCount+0x1>
    1896:	10 92 46 07 	sts	0x0746, r1	; 0x800746 <xTickCount>
    189a:	0e 94 b1 05 	call	0xb62	; 0xb62 <xPortStartScheduler>
    189e:	0f 91       	pop	r16
    18a0:	ff 90       	pop	r15
    18a2:	ef 90       	pop	r14
    18a4:	08 95       	ret

000018a6 <vTaskSuspendAll>:
    18a6:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxSchedulerSuspended>
    18aa:	8f 5f       	subi	r24, 0xFF	; 255
    18ac:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <uxSchedulerSuspended>
    18b0:	08 95       	ret

000018b2 <xTaskIncrementTick>:
    18b2:	cf 92       	push	r12
    18b4:	df 92       	push	r13
    18b6:	ef 92       	push	r14
    18b8:	ff 92       	push	r15
    18ba:	0f 93       	push	r16
    18bc:	1f 93       	push	r17
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29
    18c2:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxSchedulerSuspended>
    18c6:	81 11       	cpse	r24, r1
    18c8:	99 c0       	rjmp	.+306    	; 0x19fc <xTaskIncrementTick+0x14a>
    18ca:	e0 90 46 07 	lds	r14, 0x0746	; 0x800746 <xTickCount>
    18ce:	f0 90 47 07 	lds	r15, 0x0747	; 0x800747 <xTickCount+0x1>
    18d2:	8f ef       	ldi	r24, 0xFF	; 255
    18d4:	e8 1a       	sub	r14, r24
    18d6:	f8 0a       	sbc	r15, r24
    18d8:	f0 92 47 07 	sts	0x0747, r15	; 0x800747 <xTickCount+0x1>
    18dc:	e0 92 46 07 	sts	0x0746, r14	; 0x800746 <xTickCount>
    18e0:	e1 14       	cp	r14, r1
    18e2:	f1 04       	cpc	r15, r1
    18e4:	b9 f4       	brne	.+46     	; 0x1914 <xTaskIncrementTick+0x62>
    18e6:	80 91 5e 07 	lds	r24, 0x075E	; 0x80075e <pxDelayedTaskList>
    18ea:	90 91 5f 07 	lds	r25, 0x075F	; 0x80075f <pxDelayedTaskList+0x1>
    18ee:	20 91 5c 07 	lds	r18, 0x075C	; 0x80075c <pxOverflowDelayedTaskList>
    18f2:	30 91 5d 07 	lds	r19, 0x075D	; 0x80075d <pxOverflowDelayedTaskList+0x1>
    18f6:	30 93 5f 07 	sts	0x075F, r19	; 0x80075f <pxDelayedTaskList+0x1>
    18fa:	20 93 5e 07 	sts	0x075E, r18	; 0x80075e <pxDelayedTaskList>
    18fe:	90 93 5d 07 	sts	0x075D, r25	; 0x80075d <pxOverflowDelayedTaskList+0x1>
    1902:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <pxOverflowDelayedTaskList>
    1906:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <xNumOfOverflows>
    190a:	8f 5f       	subi	r24, 0xFF	; 255
    190c:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <xNumOfOverflows>
    1910:	0e 94 b1 0a 	call	0x1562	; 0x1562 <prvResetNextTaskUnblockTime>
    1914:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <xNextTaskUnblockTime>
    1918:	90 91 3f 07 	lds	r25, 0x073F	; 0x80073f <xNextTaskUnblockTime+0x1>
    191c:	e8 16       	cp	r14, r24
    191e:	f9 06       	cpc	r15, r25
    1920:	10 f4       	brcc	.+4      	; 0x1926 <xTaskIncrementTick+0x74>
    1922:	d1 2c       	mov	r13, r1
    1924:	53 c0       	rjmp	.+166    	; 0x19cc <xTaskIncrementTick+0x11a>
    1926:	d1 2c       	mov	r13, r1
    1928:	cc 24       	eor	r12, r12
    192a:	c3 94       	inc	r12
    192c:	e0 91 5e 07 	lds	r30, 0x075E	; 0x80075e <pxDelayedTaskList>
    1930:	f0 91 5f 07 	lds	r31, 0x075F	; 0x80075f <pxDelayedTaskList+0x1>
    1934:	80 81       	ld	r24, Z
    1936:	81 11       	cpse	r24, r1
    1938:	07 c0       	rjmp	.+14     	; 0x1948 <xTaskIncrementTick+0x96>
    193a:	8f ef       	ldi	r24, 0xFF	; 255
    193c:	9f ef       	ldi	r25, 0xFF	; 255
    193e:	90 93 3f 07 	sts	0x073F, r25	; 0x80073f <xNextTaskUnblockTime+0x1>
    1942:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <xNextTaskUnblockTime>
    1946:	42 c0       	rjmp	.+132    	; 0x19cc <xTaskIncrementTick+0x11a>
    1948:	e0 91 5e 07 	lds	r30, 0x075E	; 0x80075e <pxDelayedTaskList>
    194c:	f0 91 5f 07 	lds	r31, 0x075F	; 0x80075f <pxDelayedTaskList+0x1>
    1950:	05 80       	ldd	r0, Z+5	; 0x05
    1952:	f6 81       	ldd	r31, Z+6	; 0x06
    1954:	e0 2d       	mov	r30, r0
    1956:	c6 81       	ldd	r28, Z+6	; 0x06
    1958:	d7 81       	ldd	r29, Z+7	; 0x07
    195a:	8a 81       	ldd	r24, Y+2	; 0x02
    195c:	9b 81       	ldd	r25, Y+3	; 0x03
    195e:	e8 16       	cp	r14, r24
    1960:	f9 06       	cpc	r15, r25
    1962:	28 f4       	brcc	.+10     	; 0x196e <xTaskIncrementTick+0xbc>
    1964:	90 93 3f 07 	sts	0x073F, r25	; 0x80073f <xNextTaskUnblockTime+0x1>
    1968:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <xNextTaskUnblockTime>
    196c:	2f c0       	rjmp	.+94     	; 0x19cc <xTaskIncrementTick+0x11a>
    196e:	8e 01       	movw	r16, r28
    1970:	0e 5f       	subi	r16, 0xFE	; 254
    1972:	1f 4f       	sbci	r17, 0xFF	; 255
    1974:	c8 01       	movw	r24, r16
    1976:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    197a:	8c 89       	ldd	r24, Y+20	; 0x14
    197c:	9d 89       	ldd	r25, Y+21	; 0x15
    197e:	89 2b       	or	r24, r25
    1980:	21 f0       	breq	.+8      	; 0x198a <xTaskIncrementTick+0xd8>
    1982:	ce 01       	movw	r24, r28
    1984:	0c 96       	adiw	r24, 0x0c	; 12
    1986:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    198a:	8e 89       	ldd	r24, Y+22	; 0x16
    198c:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <uxTopReadyPriority>
    1990:	98 17       	cp	r25, r24
    1992:	10 f4       	brcc	.+4      	; 0x1998 <xTaskIncrementTick+0xe6>
    1994:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <uxTopReadyPriority>
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	9c 01       	movw	r18, r24
    199c:	22 0f       	add	r18, r18
    199e:	33 1f       	adc	r19, r19
    19a0:	22 0f       	add	r18, r18
    19a2:	33 1f       	adc	r19, r19
    19a4:	22 0f       	add	r18, r18
    19a6:	33 1f       	adc	r19, r19
    19a8:	82 0f       	add	r24, r18
    19aa:	93 1f       	adc	r25, r19
    19ac:	b8 01       	movw	r22, r16
    19ae:	8e 58       	subi	r24, 0x8E	; 142
    19b0:	98 4f       	sbci	r25, 0xF8	; 248
    19b2:	0e 94 cd 04 	call	0x99a	; 0x99a <vListInsertEnd>
    19b6:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    19ba:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    19be:	9e 89       	ldd	r25, Y+22	; 0x16
    19c0:	86 89       	ldd	r24, Z+22	; 0x16
    19c2:	98 17       	cp	r25, r24
    19c4:	08 f4       	brcc	.+2      	; 0x19c8 <xTaskIncrementTick+0x116>
    19c6:	b2 cf       	rjmp	.-156    	; 0x192c <xTaskIncrementTick+0x7a>
    19c8:	dc 2c       	mov	r13, r12
    19ca:	b0 cf       	rjmp	.-160    	; 0x192c <xTaskIncrementTick+0x7a>
    19cc:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    19d0:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    19d4:	86 89       	ldd	r24, Z+22	; 0x16
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	fc 01       	movw	r30, r24
    19da:	ee 0f       	add	r30, r30
    19dc:	ff 1f       	adc	r31, r31
    19de:	ee 0f       	add	r30, r30
    19e0:	ff 1f       	adc	r31, r31
    19e2:	ee 0f       	add	r30, r30
    19e4:	ff 1f       	adc	r31, r31
    19e6:	8e 0f       	add	r24, r30
    19e8:	9f 1f       	adc	r25, r31
    19ea:	fc 01       	movw	r30, r24
    19ec:	ee 58       	subi	r30, 0x8E	; 142
    19ee:	f8 4f       	sbci	r31, 0xF8	; 248
    19f0:	80 81       	ld	r24, Z
    19f2:	82 30       	cpi	r24, 0x02	; 2
    19f4:	48 f0       	brcs	.+18     	; 0x1a08 <xTaskIncrementTick+0x156>
    19f6:	dd 24       	eor	r13, r13
    19f8:	d3 94       	inc	r13
    19fa:	06 c0       	rjmp	.+12     	; 0x1a08 <xTaskIncrementTick+0x156>
    19fc:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxPendedTicks>
    1a00:	8f 5f       	subi	r24, 0xFF	; 255
    1a02:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <uxPendedTicks>
    1a06:	d1 2c       	mov	r13, r1
    1a08:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <xYieldPending>
    1a0c:	88 23       	and	r24, r24
    1a0e:	11 f0       	breq	.+4      	; 0x1a14 <xTaskIncrementTick+0x162>
    1a10:	dd 24       	eor	r13, r13
    1a12:	d3 94       	inc	r13
    1a14:	8d 2d       	mov	r24, r13
    1a16:	df 91       	pop	r29
    1a18:	cf 91       	pop	r28
    1a1a:	1f 91       	pop	r17
    1a1c:	0f 91       	pop	r16
    1a1e:	ff 90       	pop	r15
    1a20:	ef 90       	pop	r14
    1a22:	df 90       	pop	r13
    1a24:	cf 90       	pop	r12
    1a26:	08 95       	ret

00001a28 <xTaskResumeAll>:
    1a28:	df 92       	push	r13
    1a2a:	ef 92       	push	r14
    1a2c:	ff 92       	push	r15
    1a2e:	0f 93       	push	r16
    1a30:	1f 93       	push	r17
    1a32:	cf 93       	push	r28
    1a34:	df 93       	push	r29
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	0f 92       	push	r0
    1a3c:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxSchedulerSuspended>
    1a40:	81 50       	subi	r24, 0x01	; 1
    1a42:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <uxSchedulerSuspended>
    1a46:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxSchedulerSuspended>
    1a4a:	81 11       	cpse	r24, r1
    1a4c:	5f c0       	rjmp	.+190    	; 0x1b0c <xTaskResumeAll+0xe4>
    1a4e:	80 91 48 07 	lds	r24, 0x0748	; 0x800748 <uxCurrentNumberOfTasks>
    1a52:	81 11       	cpse	r24, r1
    1a54:	33 c0       	rjmp	.+102    	; 0x1abc <xTaskResumeAll+0x94>
    1a56:	5d c0       	rjmp	.+186    	; 0x1b12 <xTaskResumeAll+0xea>
    1a58:	d7 01       	movw	r26, r14
    1a5a:	15 96       	adiw	r26, 0x05	; 5
    1a5c:	ed 91       	ld	r30, X+
    1a5e:	fc 91       	ld	r31, X
    1a60:	16 97       	sbiw	r26, 0x06	; 6
    1a62:	c6 81       	ldd	r28, Z+6	; 0x06
    1a64:	d7 81       	ldd	r29, Z+7	; 0x07
    1a66:	ce 01       	movw	r24, r28
    1a68:	0c 96       	adiw	r24, 0x0c	; 12
    1a6a:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    1a6e:	8e 01       	movw	r16, r28
    1a70:	0e 5f       	subi	r16, 0xFE	; 254
    1a72:	1f 4f       	sbci	r17, 0xFF	; 255
    1a74:	c8 01       	movw	r24, r16
    1a76:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    1a7a:	8e 89       	ldd	r24, Y+22	; 0x16
    1a7c:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <uxTopReadyPriority>
    1a80:	98 17       	cp	r25, r24
    1a82:	10 f4       	brcc	.+4      	; 0x1a88 <xTaskResumeAll+0x60>
    1a84:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <uxTopReadyPriority>
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	9c 01       	movw	r18, r24
    1a8c:	22 0f       	add	r18, r18
    1a8e:	33 1f       	adc	r19, r19
    1a90:	22 0f       	add	r18, r18
    1a92:	33 1f       	adc	r19, r19
    1a94:	22 0f       	add	r18, r18
    1a96:	33 1f       	adc	r19, r19
    1a98:	82 0f       	add	r24, r18
    1a9a:	93 1f       	adc	r25, r19
    1a9c:	b8 01       	movw	r22, r16
    1a9e:	8e 58       	subi	r24, 0x8E	; 142
    1aa0:	98 4f       	sbci	r25, 0xF8	; 248
    1aa2:	0e 94 cd 04 	call	0x99a	; 0x99a <vListInsertEnd>
    1aa6:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    1aaa:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    1aae:	9e 89       	ldd	r25, Y+22	; 0x16
    1ab0:	86 89       	ldd	r24, Z+22	; 0x16
    1ab2:	98 17       	cp	r25, r24
    1ab4:	68 f0       	brcs	.+26     	; 0x1ad0 <xTaskResumeAll+0xa8>
    1ab6:	d0 92 42 07 	sts	0x0742, r13	; 0x800742 <xYieldPending>
    1aba:	0a c0       	rjmp	.+20     	; 0x1ad0 <xTaskResumeAll+0xa8>
    1abc:	c0 e0       	ldi	r28, 0x00	; 0
    1abe:	d0 e0       	ldi	r29, 0x00	; 0
    1ac0:	0f 2e       	mov	r0, r31
    1ac2:	f3 e5       	ldi	r31, 0x53	; 83
    1ac4:	ef 2e       	mov	r14, r31
    1ac6:	f7 e0       	ldi	r31, 0x07	; 7
    1ac8:	ff 2e       	mov	r15, r31
    1aca:	f0 2d       	mov	r31, r0
    1acc:	dd 24       	eor	r13, r13
    1ace:	d3 94       	inc	r13
    1ad0:	f7 01       	movw	r30, r14
    1ad2:	80 81       	ld	r24, Z
    1ad4:	81 11       	cpse	r24, r1
    1ad6:	c0 cf       	rjmp	.-128    	; 0x1a58 <xTaskResumeAll+0x30>
    1ad8:	cd 2b       	or	r28, r29
    1ada:	11 f0       	breq	.+4      	; 0x1ae0 <xTaskResumeAll+0xb8>
    1adc:	0e 94 b1 0a 	call	0x1562	; 0x1562 <prvResetNextTaskUnblockTime>
    1ae0:	c0 91 43 07 	lds	r28, 0x0743	; 0x800743 <uxPendedTicks>
    1ae4:	cc 23       	and	r28, r28
    1ae6:	51 f0       	breq	.+20     	; 0x1afc <xTaskResumeAll+0xd4>
    1ae8:	d1 e0       	ldi	r29, 0x01	; 1
    1aea:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <xTaskIncrementTick>
    1aee:	81 11       	cpse	r24, r1
    1af0:	d0 93 42 07 	sts	0x0742, r29	; 0x800742 <xYieldPending>
    1af4:	c1 50       	subi	r28, 0x01	; 1
    1af6:	c9 f7       	brne	.-14     	; 0x1aea <xTaskResumeAll+0xc2>
    1af8:	10 92 43 07 	sts	0x0743, r1	; 0x800743 <uxPendedTicks>
    1afc:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <xYieldPending>
    1b00:	88 23       	and	r24, r24
    1b02:	31 f0       	breq	.+12     	; 0x1b10 <xTaskResumeAll+0xe8>
    1b04:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
    1b08:	81 e0       	ldi	r24, 0x01	; 1
    1b0a:	03 c0       	rjmp	.+6      	; 0x1b12 <xTaskResumeAll+0xea>
    1b0c:	80 e0       	ldi	r24, 0x00	; 0
    1b0e:	01 c0       	rjmp	.+2      	; 0x1b12 <xTaskResumeAll+0xea>
    1b10:	80 e0       	ldi	r24, 0x00	; 0
    1b12:	0f 90       	pop	r0
    1b14:	0f be       	out	0x3f, r0	; 63
    1b16:	df 91       	pop	r29
    1b18:	cf 91       	pop	r28
    1b1a:	1f 91       	pop	r17
    1b1c:	0f 91       	pop	r16
    1b1e:	ff 90       	pop	r15
    1b20:	ef 90       	pop	r14
    1b22:	df 90       	pop	r13
    1b24:	08 95       	ret

00001b26 <vTaskDelay>:
    1b26:	cf 93       	push	r28
    1b28:	df 93       	push	r29
    1b2a:	ec 01       	movw	r28, r24
    1b2c:	89 2b       	or	r24, r25
    1b2e:	51 f0       	breq	.+20     	; 0x1b44 <vTaskDelay+0x1e>
    1b30:	0e 94 53 0c 	call	0x18a6	; 0x18a6 <vTaskSuspendAll>
    1b34:	60 e0       	ldi	r22, 0x00	; 0
    1b36:	ce 01       	movw	r24, r28
    1b38:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <prvAddCurrentTaskToDelayedList>
    1b3c:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskResumeAll>
    1b40:	81 11       	cpse	r24, r1
    1b42:	02 c0       	rjmp	.+4      	; 0x1b48 <vTaskDelay+0x22>
    1b44:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
    1b48:	df 91       	pop	r29
    1b4a:	cf 91       	pop	r28
    1b4c:	08 95       	ret

00001b4e <prvIdleTask>:
    1b4e:	0a e4       	ldi	r16, 0x4A	; 74
    1b50:	17 e0       	ldi	r17, 0x07	; 7
    1b52:	0f 2e       	mov	r0, r31
    1b54:	f2 e7       	ldi	r31, 0x72	; 114
    1b56:	ef 2e       	mov	r14, r31
    1b58:	f7 e0       	ldi	r31, 0x07	; 7
    1b5a:	ff 2e       	mov	r15, r31
    1b5c:	f0 2d       	mov	r31, r0
    1b5e:	29 c0       	rjmp	.+82     	; 0x1bb2 <prvIdleTask+0x64>
    1b60:	0e 94 53 0c 	call	0x18a6	; 0x18a6 <vTaskSuspendAll>
    1b64:	d8 01       	movw	r26, r16
    1b66:	cc 91       	ld	r28, X
    1b68:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskResumeAll>
    1b6c:	cc 23       	and	r28, r28
    1b6e:	09 f1       	breq	.+66     	; 0x1bb2 <prvIdleTask+0x64>
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	f8 94       	cli
    1b74:	0f 92       	push	r0
    1b76:	d8 01       	movw	r26, r16
    1b78:	15 96       	adiw	r26, 0x05	; 5
    1b7a:	ed 91       	ld	r30, X+
    1b7c:	fc 91       	ld	r31, X
    1b7e:	16 97       	sbiw	r26, 0x06	; 6
    1b80:	c6 81       	ldd	r28, Z+6	; 0x06
    1b82:	d7 81       	ldd	r29, Z+7	; 0x07
    1b84:	ce 01       	movw	r24, r28
    1b86:	02 96       	adiw	r24, 0x02	; 2
    1b88:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    1b8c:	80 91 48 07 	lds	r24, 0x0748	; 0x800748 <uxCurrentNumberOfTasks>
    1b90:	81 50       	subi	r24, 0x01	; 1
    1b92:	80 93 48 07 	sts	0x0748, r24	; 0x800748 <uxCurrentNumberOfTasks>
    1b96:	80 91 49 07 	lds	r24, 0x0749	; 0x800749 <uxDeletedTasksWaitingCleanUp>
    1b9a:	81 50       	subi	r24, 0x01	; 1
    1b9c:	80 93 49 07 	sts	0x0749, r24	; 0x800749 <uxDeletedTasksWaitingCleanUp>
    1ba0:	0f 90       	pop	r0
    1ba2:	0f be       	out	0x3f, r0	; 63
    1ba4:	8f 89       	ldd	r24, Y+23	; 0x17
    1ba6:	98 8d       	ldd	r25, Y+24	; 0x18
    1ba8:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortFree>
    1bac:	ce 01       	movw	r24, r28
    1bae:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortFree>
    1bb2:	80 91 49 07 	lds	r24, 0x0749	; 0x800749 <uxDeletedTasksWaitingCleanUp>
    1bb6:	81 11       	cpse	r24, r1
    1bb8:	d3 cf       	rjmp	.-90     	; 0x1b60 <prvIdleTask+0x12>
    1bba:	f7 01       	movw	r30, r14
    1bbc:	80 81       	ld	r24, Z
    1bbe:	82 30       	cpi	r24, 0x02	; 2
    1bc0:	10 f0       	brcs	.+4      	; 0x1bc6 <prvIdleTask+0x78>
    1bc2:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <vPortYield>
    1bc6:	0e 94 9e 03 	call	0x73c	; 0x73c <vApplicationIdleHook>
    1bca:	f3 cf       	rjmp	.-26     	; 0x1bb2 <prvIdleTask+0x64>

00001bcc <vTaskSetApplicationTaskTag>:
    1bcc:	00 97       	sbiw	r24, 0x00	; 0
    1bce:	21 f4       	brne	.+8      	; 0x1bd8 <vTaskSetApplicationTaskTag+0xc>
    1bd0:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <pxCurrentTCB>
    1bd4:	90 91 97 07 	lds	r25, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	0f 92       	push	r0
    1bde:	fc 01       	movw	r30, r24
    1be0:	76 a3       	std	Z+38, r23	; 0x26
    1be2:	65 a3       	std	Z+37, r22	; 0x25
    1be4:	0f 90       	pop	r0
    1be6:	0f be       	out	0x3f, r0	; 63
    1be8:	08 95       	ret

00001bea <vTaskSwitchContext>:
    1bea:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxSchedulerSuspended>
    1bee:	88 23       	and	r24, r24
    1bf0:	21 f0       	breq	.+8      	; 0x1bfa <vTaskSwitchContext+0x10>
    1bf2:	81 e0       	ldi	r24, 0x01	; 1
    1bf4:	80 93 42 07 	sts	0x0742, r24	; 0x800742 <xYieldPending>
    1bf8:	08 95       	ret
    1bfa:	10 92 42 07 	sts	0x0742, r1	; 0x800742 <xYieldPending>
    1bfe:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    1c02:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    1c06:	85 a1       	ldd	r24, Z+37	; 0x25
    1c08:	0e 94 74 04 	call	0x8e8	; 0x8e8 <switch_out>
    1c0c:	20 91 45 07 	lds	r18, 0x0745	; 0x800745 <uxTopReadyPriority>
    1c10:	82 2f       	mov	r24, r18
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	fc 01       	movw	r30, r24
    1c16:	ee 0f       	add	r30, r30
    1c18:	ff 1f       	adc	r31, r31
    1c1a:	ee 0f       	add	r30, r30
    1c1c:	ff 1f       	adc	r31, r31
    1c1e:	ee 0f       	add	r30, r30
    1c20:	ff 1f       	adc	r31, r31
    1c22:	e8 0f       	add	r30, r24
    1c24:	f9 1f       	adc	r31, r25
    1c26:	ee 58       	subi	r30, 0x8E	; 142
    1c28:	f8 4f       	sbci	r31, 0xF8	; 248
    1c2a:	30 81       	ld	r19, Z
    1c2c:	31 11       	cpse	r19, r1
    1c2e:	11 c0       	rjmp	.+34     	; 0x1c52 <vTaskSwitchContext+0x68>
    1c30:	21 50       	subi	r18, 0x01	; 1
    1c32:	82 2f       	mov	r24, r18
    1c34:	90 e0       	ldi	r25, 0x00	; 0
    1c36:	fc 01       	movw	r30, r24
    1c38:	ee 0f       	add	r30, r30
    1c3a:	ff 1f       	adc	r31, r31
    1c3c:	ee 0f       	add	r30, r30
    1c3e:	ff 1f       	adc	r31, r31
    1c40:	ee 0f       	add	r30, r30
    1c42:	ff 1f       	adc	r31, r31
    1c44:	e8 0f       	add	r30, r24
    1c46:	f9 1f       	adc	r31, r25
    1c48:	ee 58       	subi	r30, 0x8E	; 142
    1c4a:	f8 4f       	sbci	r31, 0xF8	; 248
    1c4c:	30 81       	ld	r19, Z
    1c4e:	33 23       	and	r19, r19
    1c50:	79 f3       	breq	.-34     	; 0x1c30 <vTaskSwitchContext+0x46>
    1c52:	ac 01       	movw	r20, r24
    1c54:	44 0f       	add	r20, r20
    1c56:	55 1f       	adc	r21, r21
    1c58:	44 0f       	add	r20, r20
    1c5a:	55 1f       	adc	r21, r21
    1c5c:	44 0f       	add	r20, r20
    1c5e:	55 1f       	adc	r21, r21
    1c60:	48 0f       	add	r20, r24
    1c62:	59 1f       	adc	r21, r25
    1c64:	da 01       	movw	r26, r20
    1c66:	ae 58       	subi	r26, 0x8E	; 142
    1c68:	b8 4f       	sbci	r27, 0xF8	; 248
    1c6a:	11 96       	adiw	r26, 0x01	; 1
    1c6c:	ed 91       	ld	r30, X+
    1c6e:	fc 91       	ld	r31, X
    1c70:	12 97       	sbiw	r26, 0x02	; 2
    1c72:	02 80       	ldd	r0, Z+2	; 0x02
    1c74:	f3 81       	ldd	r31, Z+3	; 0x03
    1c76:	e0 2d       	mov	r30, r0
    1c78:	12 96       	adiw	r26, 0x02	; 2
    1c7a:	fc 93       	st	X, r31
    1c7c:	ee 93       	st	-X, r30
    1c7e:	11 97       	sbiw	r26, 0x01	; 1
    1c80:	4b 58       	subi	r20, 0x8B	; 139
    1c82:	58 4f       	sbci	r21, 0xF8	; 248
    1c84:	e4 17       	cp	r30, r20
    1c86:	f5 07       	cpc	r31, r21
    1c88:	29 f4       	brne	.+10     	; 0x1c94 <vTaskSwitchContext+0xaa>
    1c8a:	42 81       	ldd	r20, Z+2	; 0x02
    1c8c:	53 81       	ldd	r21, Z+3	; 0x03
    1c8e:	fd 01       	movw	r30, r26
    1c90:	52 83       	std	Z+2, r21	; 0x02
    1c92:	41 83       	std	Z+1, r20	; 0x01
    1c94:	fc 01       	movw	r30, r24
    1c96:	ee 0f       	add	r30, r30
    1c98:	ff 1f       	adc	r31, r31
    1c9a:	ee 0f       	add	r30, r30
    1c9c:	ff 1f       	adc	r31, r31
    1c9e:	ee 0f       	add	r30, r30
    1ca0:	ff 1f       	adc	r31, r31
    1ca2:	8e 0f       	add	r24, r30
    1ca4:	9f 1f       	adc	r25, r31
    1ca6:	fc 01       	movw	r30, r24
    1ca8:	ee 58       	subi	r30, 0x8E	; 142
    1caa:	f8 4f       	sbci	r31, 0xF8	; 248
    1cac:	01 80       	ldd	r0, Z+1	; 0x01
    1cae:	f2 81       	ldd	r31, Z+2	; 0x02
    1cb0:	e0 2d       	mov	r30, r0
    1cb2:	86 81       	ldd	r24, Z+6	; 0x06
    1cb4:	97 81       	ldd	r25, Z+7	; 0x07
    1cb6:	90 93 97 07 	sts	0x0797, r25	; 0x800797 <pxCurrentTCB+0x1>
    1cba:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <pxCurrentTCB>
    1cbe:	20 93 45 07 	sts	0x0745, r18	; 0x800745 <uxTopReadyPriority>
    1cc2:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    1cc6:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    1cca:	85 a1       	ldd	r24, Z+37	; 0x25
    1ccc:	0e 94 69 04 	call	0x8d2	; 0x8d2 <switch_in>
    1cd0:	08 95       	ret

00001cd2 <vTaskPlaceOnEventList>:
    1cd2:	cf 93       	push	r28
    1cd4:	df 93       	push	r29
    1cd6:	eb 01       	movw	r28, r22
    1cd8:	60 91 96 07 	lds	r22, 0x0796	; 0x800796 <pxCurrentTCB>
    1cdc:	70 91 97 07 	lds	r23, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    1ce0:	64 5f       	subi	r22, 0xF4	; 244
    1ce2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce4:	0e 94 ee 04 	call	0x9dc	; 0x9dc <vListInsert>
    1ce8:	61 e0       	ldi	r22, 0x01	; 1
    1cea:	ce 01       	movw	r24, r28
    1cec:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <prvAddCurrentTaskToDelayedList>
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	08 95       	ret

00001cf6 <xTaskRemoveFromEventList>:
    1cf6:	0f 93       	push	r16
    1cf8:	1f 93       	push	r17
    1cfa:	cf 93       	push	r28
    1cfc:	df 93       	push	r29
    1cfe:	dc 01       	movw	r26, r24
    1d00:	15 96       	adiw	r26, 0x05	; 5
    1d02:	ed 91       	ld	r30, X+
    1d04:	fc 91       	ld	r31, X
    1d06:	16 97       	sbiw	r26, 0x06	; 6
    1d08:	c6 81       	ldd	r28, Z+6	; 0x06
    1d0a:	d7 81       	ldd	r29, Z+7	; 0x07
    1d0c:	8e 01       	movw	r16, r28
    1d0e:	04 5f       	subi	r16, 0xF4	; 244
    1d10:	1f 4f       	sbci	r17, 0xFF	; 255
    1d12:	c8 01       	movw	r24, r16
    1d14:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    1d18:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <uxSchedulerSuspended>
    1d1c:	81 11       	cpse	r24, r1
    1d1e:	1c c0       	rjmp	.+56     	; 0x1d58 <xTaskRemoveFromEventList+0x62>
    1d20:	0a 50       	subi	r16, 0x0A	; 10
    1d22:	11 09       	sbc	r17, r1
    1d24:	c8 01       	movw	r24, r16
    1d26:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
    1d2a:	8e 89       	ldd	r24, Y+22	; 0x16
    1d2c:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <uxTopReadyPriority>
    1d30:	98 17       	cp	r25, r24
    1d32:	10 f4       	brcc	.+4      	; 0x1d38 <xTaskRemoveFromEventList+0x42>
    1d34:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <uxTopReadyPriority>
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	9c 01       	movw	r18, r24
    1d3c:	22 0f       	add	r18, r18
    1d3e:	33 1f       	adc	r19, r19
    1d40:	22 0f       	add	r18, r18
    1d42:	33 1f       	adc	r19, r19
    1d44:	22 0f       	add	r18, r18
    1d46:	33 1f       	adc	r19, r19
    1d48:	82 0f       	add	r24, r18
    1d4a:	93 1f       	adc	r25, r19
    1d4c:	b8 01       	movw	r22, r16
    1d4e:	8e 58       	subi	r24, 0x8E	; 142
    1d50:	98 4f       	sbci	r25, 0xF8	; 248
    1d52:	0e 94 cd 04 	call	0x99a	; 0x99a <vListInsertEnd>
    1d56:	05 c0       	rjmp	.+10     	; 0x1d62 <xTaskRemoveFromEventList+0x6c>
    1d58:	b8 01       	movw	r22, r16
    1d5a:	83 e5       	ldi	r24, 0x53	; 83
    1d5c:	97 e0       	ldi	r25, 0x07	; 7
    1d5e:	0e 94 cd 04 	call	0x99a	; 0x99a <vListInsertEnd>
    1d62:	e0 91 96 07 	lds	r30, 0x0796	; 0x800796 <pxCurrentTCB>
    1d66:	f0 91 97 07 	lds	r31, 0x0797	; 0x800797 <pxCurrentTCB+0x1>
    1d6a:	9e 89       	ldd	r25, Y+22	; 0x16
    1d6c:	86 89       	ldd	r24, Z+22	; 0x16
    1d6e:	89 17       	cp	r24, r25
    1d70:	20 f4       	brcc	.+8      	; 0x1d7a <xTaskRemoveFromEventList+0x84>
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	80 93 42 07 	sts	0x0742, r24	; 0x800742 <xYieldPending>
    1d78:	01 c0       	rjmp	.+2      	; 0x1d7c <xTaskRemoveFromEventList+0x86>
    1d7a:	80 e0       	ldi	r24, 0x00	; 0
    1d7c:	df 91       	pop	r29
    1d7e:	cf 91       	pop	r28
    1d80:	1f 91       	pop	r17
    1d82:	0f 91       	pop	r16
    1d84:	08 95       	ret

00001d86 <vTaskSetTimeOutState>:
    1d86:	20 91 41 07 	lds	r18, 0x0741	; 0x800741 <xNumOfOverflows>
    1d8a:	fc 01       	movw	r30, r24
    1d8c:	20 83       	st	Z, r18
    1d8e:	20 91 46 07 	lds	r18, 0x0746	; 0x800746 <xTickCount>
    1d92:	30 91 47 07 	lds	r19, 0x0747	; 0x800747 <xTickCount+0x1>
    1d96:	32 83       	std	Z+2, r19	; 0x02
    1d98:	21 83       	std	Z+1, r18	; 0x01
    1d9a:	08 95       	ret

00001d9c <xTaskCheckForTimeOut>:
    1d9c:	cf 93       	push	r28
    1d9e:	df 93       	push	r29
    1da0:	fc 01       	movw	r30, r24
    1da2:	0f b6       	in	r0, 0x3f	; 63
    1da4:	f8 94       	cli
    1da6:	0f 92       	push	r0
    1da8:	20 91 46 07 	lds	r18, 0x0746	; 0x800746 <xTickCount>
    1dac:	30 91 47 07 	lds	r19, 0x0747	; 0x800747 <xTickCount+0x1>
    1db0:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <xNumOfOverflows>
    1db4:	90 81       	ld	r25, Z
    1db6:	98 17       	cp	r25, r24
    1db8:	29 f0       	breq	.+10     	; 0x1dc4 <xTaskCheckForTimeOut+0x28>
    1dba:	81 81       	ldd	r24, Z+1	; 0x01
    1dbc:	92 81       	ldd	r25, Z+2	; 0x02
    1dbe:	28 17       	cp	r18, r24
    1dc0:	39 07       	cpc	r19, r25
    1dc2:	b0 f4       	brcc	.+44     	; 0x1df0 <xTaskCheckForTimeOut+0x54>
    1dc4:	a1 81       	ldd	r26, Z+1	; 0x01
    1dc6:	b2 81       	ldd	r27, Z+2	; 0x02
    1dc8:	eb 01       	movw	r28, r22
    1dca:	48 81       	ld	r20, Y
    1dcc:	59 81       	ldd	r21, Y+1	; 0x01
    1dce:	c9 01       	movw	r24, r18
    1dd0:	8a 1b       	sub	r24, r26
    1dd2:	9b 0b       	sbc	r25, r27
    1dd4:	84 17       	cp	r24, r20
    1dd6:	95 07       	cpc	r25, r21
    1dd8:	68 f4       	brcc	.+26     	; 0x1df4 <xTaskCheckForTimeOut+0x58>
    1dda:	cf 01       	movw	r24, r30
    1ddc:	a2 1b       	sub	r26, r18
    1dde:	b3 0b       	sbc	r27, r19
    1de0:	4a 0f       	add	r20, r26
    1de2:	5b 1f       	adc	r21, r27
    1de4:	59 83       	std	Y+1, r21	; 0x01
    1de6:	48 83       	st	Y, r20
    1de8:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <vTaskSetTimeOutState>
    1dec:	80 e0       	ldi	r24, 0x00	; 0
    1dee:	03 c0       	rjmp	.+6      	; 0x1df6 <xTaskCheckForTimeOut+0x5a>
    1df0:	81 e0       	ldi	r24, 0x01	; 1
    1df2:	01 c0       	rjmp	.+2      	; 0x1df6 <xTaskCheckForTimeOut+0x5a>
    1df4:	81 e0       	ldi	r24, 0x01	; 1
    1df6:	0f 90       	pop	r0
    1df8:	0f be       	out	0x3f, r0	; 63
    1dfa:	df 91       	pop	r29
    1dfc:	cf 91       	pop	r28
    1dfe:	08 95       	ret

00001e00 <vTaskMissedYield>:
    1e00:	81 e0       	ldi	r24, 0x01	; 1
    1e02:	80 93 42 07 	sts	0x0742, r24	; 0x800742 <xYieldPending>
    1e06:	08 95       	ret

00001e08 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1e08:	0f 93       	push	r16
    1e0a:	1f 93       	push	r17
    1e0c:	cf 93       	push	r28
    1e0e:	df 93       	push	r29
    1e10:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1e12:	89 2b       	or	r24, r25
    1e14:	79 f1       	breq	.+94     	; 0x1e74 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1e16:	84 a1       	ldd	r24, Z+36	; 0x24
    1e18:	81 50       	subi	r24, 0x01	; 1
    1e1a:	84 a3       	std	Z+36, r24	; 0x24

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1e1c:	26 89       	ldd	r18, Z+22	; 0x16
    1e1e:	93 a1       	ldd	r25, Z+35	; 0x23
    1e20:	29 17       	cp	r18, r25
    1e22:	51 f1       	breq	.+84     	; 0x1e78 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1e24:	81 11       	cpse	r24, r1
    1e26:	2a c0       	rjmp	.+84     	; 0x1e7c <xTaskPriorityDisinherit+0x74>
    1e28:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1e2a:	8f 01       	movw	r16, r30
    1e2c:	0e 5f       	subi	r16, 0xFE	; 254
    1e2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e30:	c8 01       	movw	r24, r16
    1e32:	0e 94 1f 05 	call	0xa3e	; 0xa3e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1e36:	8b a1       	ldd	r24, Y+35	; 0x23
    1e38:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e3a:	24 e0       	ldi	r18, 0x04	; 4
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	28 1b       	sub	r18, r24
    1e40:	31 09       	sbc	r19, r1
    1e42:	3d 87       	std	Y+13, r19	; 0x0d
    1e44:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    1e46:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <uxTopReadyPriority>
    1e4a:	98 17       	cp	r25, r24
    1e4c:	10 f4       	brcc	.+4      	; 0x1e52 <xTaskPriorityDisinherit+0x4a>
    1e4e:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <uxTopReadyPriority>
    1e52:	90 e0       	ldi	r25, 0x00	; 0
    1e54:	9c 01       	movw	r18, r24
    1e56:	22 0f       	add	r18, r18
    1e58:	33 1f       	adc	r19, r19
    1e5a:	22 0f       	add	r18, r18
    1e5c:	33 1f       	adc	r19, r19
    1e5e:	22 0f       	add	r18, r18
    1e60:	33 1f       	adc	r19, r19
    1e62:	82 0f       	add	r24, r18
    1e64:	93 1f       	adc	r25, r19
    1e66:	b8 01       	movw	r22, r16
    1e68:	8e 58       	subi	r24, 0x8E	; 142
    1e6a:	98 4f       	sbci	r25, 0xF8	; 248
    1e6c:	0e 94 cd 04 	call	0x99a	; 0x99a <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    1e70:	81 e0       	ldi	r24, 0x01	; 1
    1e72:	05 c0       	rjmp	.+10     	; 0x1e7e <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1e74:	80 e0       	ldi	r24, 0x00	; 0
    1e76:	03 c0       	rjmp	.+6      	; 0x1e7e <xTaskPriorityDisinherit+0x76>
    1e78:	80 e0       	ldi	r24, 0x00	; 0
    1e7a:	01 c0       	rjmp	.+2      	; 0x1e7e <xTaskPriorityDisinherit+0x76>
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1e7e:	df 91       	pop	r29
    1e80:	cf 91       	pop	r28
    1e82:	1f 91       	pop	r17
    1e84:	0f 91       	pop	r16
    1e86:	08 95       	ret

00001e88 <__udivmodsi4>:
    1e88:	a1 e2       	ldi	r26, 0x21	; 33
    1e8a:	1a 2e       	mov	r1, r26
    1e8c:	aa 1b       	sub	r26, r26
    1e8e:	bb 1b       	sub	r27, r27
    1e90:	fd 01       	movw	r30, r26
    1e92:	0d c0       	rjmp	.+26     	; 0x1eae <__udivmodsi4_ep>

00001e94 <__udivmodsi4_loop>:
    1e94:	aa 1f       	adc	r26, r26
    1e96:	bb 1f       	adc	r27, r27
    1e98:	ee 1f       	adc	r30, r30
    1e9a:	ff 1f       	adc	r31, r31
    1e9c:	a2 17       	cp	r26, r18
    1e9e:	b3 07       	cpc	r27, r19
    1ea0:	e4 07       	cpc	r30, r20
    1ea2:	f5 07       	cpc	r31, r21
    1ea4:	20 f0       	brcs	.+8      	; 0x1eae <__udivmodsi4_ep>
    1ea6:	a2 1b       	sub	r26, r18
    1ea8:	b3 0b       	sbc	r27, r19
    1eaa:	e4 0b       	sbc	r30, r20
    1eac:	f5 0b       	sbc	r31, r21

00001eae <__udivmodsi4_ep>:
    1eae:	66 1f       	adc	r22, r22
    1eb0:	77 1f       	adc	r23, r23
    1eb2:	88 1f       	adc	r24, r24
    1eb4:	99 1f       	adc	r25, r25
    1eb6:	1a 94       	dec	r1
    1eb8:	69 f7       	brne	.-38     	; 0x1e94 <__udivmodsi4_loop>
    1eba:	60 95       	com	r22
    1ebc:	70 95       	com	r23
    1ebe:	80 95       	com	r24
    1ec0:	90 95       	com	r25
    1ec2:	9b 01       	movw	r18, r22
    1ec4:	ac 01       	movw	r20, r24
    1ec6:	bd 01       	movw	r22, r26
    1ec8:	cf 01       	movw	r24, r30
    1eca:	08 95       	ret

00001ecc <malloc>:
    1ecc:	0f 93       	push	r16
    1ece:	1f 93       	push	r17
    1ed0:	cf 93       	push	r28
    1ed2:	df 93       	push	r29
    1ed4:	82 30       	cpi	r24, 0x02	; 2
    1ed6:	91 05       	cpc	r25, r1
    1ed8:	10 f4       	brcc	.+4      	; 0x1ede <malloc+0x12>
    1eda:	82 e0       	ldi	r24, 0x02	; 2
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	e0 91 9e 07 	lds	r30, 0x079E	; 0x80079e <__flp>
    1ee2:	f0 91 9f 07 	lds	r31, 0x079F	; 0x80079f <__flp+0x1>
    1ee6:	20 e0       	ldi	r18, 0x00	; 0
    1ee8:	30 e0       	ldi	r19, 0x00	; 0
    1eea:	a0 e0       	ldi	r26, 0x00	; 0
    1eec:	b0 e0       	ldi	r27, 0x00	; 0
    1eee:	30 97       	sbiw	r30, 0x00	; 0
    1ef0:	19 f1       	breq	.+70     	; 0x1f38 <malloc+0x6c>
    1ef2:	40 81       	ld	r20, Z
    1ef4:	51 81       	ldd	r21, Z+1	; 0x01
    1ef6:	02 81       	ldd	r16, Z+2	; 0x02
    1ef8:	13 81       	ldd	r17, Z+3	; 0x03
    1efa:	48 17       	cp	r20, r24
    1efc:	59 07       	cpc	r21, r25
    1efe:	c8 f0       	brcs	.+50     	; 0x1f32 <malloc+0x66>
    1f00:	84 17       	cp	r24, r20
    1f02:	95 07       	cpc	r25, r21
    1f04:	69 f4       	brne	.+26     	; 0x1f20 <malloc+0x54>
    1f06:	10 97       	sbiw	r26, 0x00	; 0
    1f08:	31 f0       	breq	.+12     	; 0x1f16 <malloc+0x4a>
    1f0a:	12 96       	adiw	r26, 0x02	; 2
    1f0c:	0c 93       	st	X, r16
    1f0e:	12 97       	sbiw	r26, 0x02	; 2
    1f10:	13 96       	adiw	r26, 0x03	; 3
    1f12:	1c 93       	st	X, r17
    1f14:	27 c0       	rjmp	.+78     	; 0x1f64 <malloc+0x98>
    1f16:	00 93 9e 07 	sts	0x079E, r16	; 0x80079e <__flp>
    1f1a:	10 93 9f 07 	sts	0x079F, r17	; 0x80079f <__flp+0x1>
    1f1e:	22 c0       	rjmp	.+68     	; 0x1f64 <malloc+0x98>
    1f20:	21 15       	cp	r18, r1
    1f22:	31 05       	cpc	r19, r1
    1f24:	19 f0       	breq	.+6      	; 0x1f2c <malloc+0x60>
    1f26:	42 17       	cp	r20, r18
    1f28:	53 07       	cpc	r21, r19
    1f2a:	18 f4       	brcc	.+6      	; 0x1f32 <malloc+0x66>
    1f2c:	9a 01       	movw	r18, r20
    1f2e:	bd 01       	movw	r22, r26
    1f30:	ef 01       	movw	r28, r30
    1f32:	df 01       	movw	r26, r30
    1f34:	f8 01       	movw	r30, r16
    1f36:	db cf       	rjmp	.-74     	; 0x1eee <malloc+0x22>
    1f38:	21 15       	cp	r18, r1
    1f3a:	31 05       	cpc	r19, r1
    1f3c:	f9 f0       	breq	.+62     	; 0x1f7c <malloc+0xb0>
    1f3e:	28 1b       	sub	r18, r24
    1f40:	39 0b       	sbc	r19, r25
    1f42:	24 30       	cpi	r18, 0x04	; 4
    1f44:	31 05       	cpc	r19, r1
    1f46:	80 f4       	brcc	.+32     	; 0x1f68 <malloc+0x9c>
    1f48:	8a 81       	ldd	r24, Y+2	; 0x02
    1f4a:	9b 81       	ldd	r25, Y+3	; 0x03
    1f4c:	61 15       	cp	r22, r1
    1f4e:	71 05       	cpc	r23, r1
    1f50:	21 f0       	breq	.+8      	; 0x1f5a <malloc+0x8e>
    1f52:	fb 01       	movw	r30, r22
    1f54:	93 83       	std	Z+3, r25	; 0x03
    1f56:	82 83       	std	Z+2, r24	; 0x02
    1f58:	04 c0       	rjmp	.+8      	; 0x1f62 <malloc+0x96>
    1f5a:	90 93 9f 07 	sts	0x079F, r25	; 0x80079f <__flp+0x1>
    1f5e:	80 93 9e 07 	sts	0x079E, r24	; 0x80079e <__flp>
    1f62:	fe 01       	movw	r30, r28
    1f64:	32 96       	adiw	r30, 0x02	; 2
    1f66:	44 c0       	rjmp	.+136    	; 0x1ff0 <malloc+0x124>
    1f68:	fe 01       	movw	r30, r28
    1f6a:	e2 0f       	add	r30, r18
    1f6c:	f3 1f       	adc	r31, r19
    1f6e:	81 93       	st	Z+, r24
    1f70:	91 93       	st	Z+, r25
    1f72:	22 50       	subi	r18, 0x02	; 2
    1f74:	31 09       	sbc	r19, r1
    1f76:	39 83       	std	Y+1, r19	; 0x01
    1f78:	28 83       	st	Y, r18
    1f7a:	3a c0       	rjmp	.+116    	; 0x1ff0 <malloc+0x124>
    1f7c:	20 91 9c 07 	lds	r18, 0x079C	; 0x80079c <__brkval>
    1f80:	30 91 9d 07 	lds	r19, 0x079D	; 0x80079d <__brkval+0x1>
    1f84:	23 2b       	or	r18, r19
    1f86:	41 f4       	brne	.+16     	; 0x1f98 <malloc+0xcc>
    1f88:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1f8c:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1f90:	30 93 9d 07 	sts	0x079D, r19	; 0x80079d <__brkval+0x1>
    1f94:	20 93 9c 07 	sts	0x079C, r18	; 0x80079c <__brkval>
    1f98:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1f9c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    1fa0:	21 15       	cp	r18, r1
    1fa2:	31 05       	cpc	r19, r1
    1fa4:	41 f4       	brne	.+16     	; 0x1fb6 <malloc+0xea>
    1fa6:	2d b7       	in	r18, 0x3d	; 61
    1fa8:	3e b7       	in	r19, 0x3e	; 62
    1faa:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1fae:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1fb2:	24 1b       	sub	r18, r20
    1fb4:	35 0b       	sbc	r19, r21
    1fb6:	e0 91 9c 07 	lds	r30, 0x079C	; 0x80079c <__brkval>
    1fba:	f0 91 9d 07 	lds	r31, 0x079D	; 0x80079d <__brkval+0x1>
    1fbe:	e2 17       	cp	r30, r18
    1fc0:	f3 07       	cpc	r31, r19
    1fc2:	a0 f4       	brcc	.+40     	; 0x1fec <malloc+0x120>
    1fc4:	2e 1b       	sub	r18, r30
    1fc6:	3f 0b       	sbc	r19, r31
    1fc8:	28 17       	cp	r18, r24
    1fca:	39 07       	cpc	r19, r25
    1fcc:	78 f0       	brcs	.+30     	; 0x1fec <malloc+0x120>
    1fce:	ac 01       	movw	r20, r24
    1fd0:	4e 5f       	subi	r20, 0xFE	; 254
    1fd2:	5f 4f       	sbci	r21, 0xFF	; 255
    1fd4:	24 17       	cp	r18, r20
    1fd6:	35 07       	cpc	r19, r21
    1fd8:	48 f0       	brcs	.+18     	; 0x1fec <malloc+0x120>
    1fda:	4e 0f       	add	r20, r30
    1fdc:	5f 1f       	adc	r21, r31
    1fde:	50 93 9d 07 	sts	0x079D, r21	; 0x80079d <__brkval+0x1>
    1fe2:	40 93 9c 07 	sts	0x079C, r20	; 0x80079c <__brkval>
    1fe6:	81 93       	st	Z+, r24
    1fe8:	91 93       	st	Z+, r25
    1fea:	02 c0       	rjmp	.+4      	; 0x1ff0 <malloc+0x124>
    1fec:	e0 e0       	ldi	r30, 0x00	; 0
    1fee:	f0 e0       	ldi	r31, 0x00	; 0
    1ff0:	cf 01       	movw	r24, r30
    1ff2:	df 91       	pop	r29
    1ff4:	cf 91       	pop	r28
    1ff6:	1f 91       	pop	r17
    1ff8:	0f 91       	pop	r16
    1ffa:	08 95       	ret

00001ffc <free>:
    1ffc:	cf 93       	push	r28
    1ffe:	df 93       	push	r29
    2000:	00 97       	sbiw	r24, 0x00	; 0
    2002:	09 f4       	brne	.+2      	; 0x2006 <free+0xa>
    2004:	81 c0       	rjmp	.+258    	; 0x2108 <free+0x10c>
    2006:	fc 01       	movw	r30, r24
    2008:	32 97       	sbiw	r30, 0x02	; 2
    200a:	13 82       	std	Z+3, r1	; 0x03
    200c:	12 82       	std	Z+2, r1	; 0x02
    200e:	a0 91 9e 07 	lds	r26, 0x079E	; 0x80079e <__flp>
    2012:	b0 91 9f 07 	lds	r27, 0x079F	; 0x80079f <__flp+0x1>
    2016:	10 97       	sbiw	r26, 0x00	; 0
    2018:	81 f4       	brne	.+32     	; 0x203a <free+0x3e>
    201a:	20 81       	ld	r18, Z
    201c:	31 81       	ldd	r19, Z+1	; 0x01
    201e:	82 0f       	add	r24, r18
    2020:	93 1f       	adc	r25, r19
    2022:	20 91 9c 07 	lds	r18, 0x079C	; 0x80079c <__brkval>
    2026:	30 91 9d 07 	lds	r19, 0x079D	; 0x80079d <__brkval+0x1>
    202a:	28 17       	cp	r18, r24
    202c:	39 07       	cpc	r19, r25
    202e:	51 f5       	brne	.+84     	; 0x2084 <free+0x88>
    2030:	f0 93 9d 07 	sts	0x079D, r31	; 0x80079d <__brkval+0x1>
    2034:	e0 93 9c 07 	sts	0x079C, r30	; 0x80079c <__brkval>
    2038:	67 c0       	rjmp	.+206    	; 0x2108 <free+0x10c>
    203a:	ed 01       	movw	r28, r26
    203c:	20 e0       	ldi	r18, 0x00	; 0
    203e:	30 e0       	ldi	r19, 0x00	; 0
    2040:	ce 17       	cp	r28, r30
    2042:	df 07       	cpc	r29, r31
    2044:	40 f4       	brcc	.+16     	; 0x2056 <free+0x5a>
    2046:	4a 81       	ldd	r20, Y+2	; 0x02
    2048:	5b 81       	ldd	r21, Y+3	; 0x03
    204a:	9e 01       	movw	r18, r28
    204c:	41 15       	cp	r20, r1
    204e:	51 05       	cpc	r21, r1
    2050:	f1 f0       	breq	.+60     	; 0x208e <free+0x92>
    2052:	ea 01       	movw	r28, r20
    2054:	f5 cf       	rjmp	.-22     	; 0x2040 <free+0x44>
    2056:	d3 83       	std	Z+3, r29	; 0x03
    2058:	c2 83       	std	Z+2, r28	; 0x02
    205a:	40 81       	ld	r20, Z
    205c:	51 81       	ldd	r21, Z+1	; 0x01
    205e:	84 0f       	add	r24, r20
    2060:	95 1f       	adc	r25, r21
    2062:	c8 17       	cp	r28, r24
    2064:	d9 07       	cpc	r29, r25
    2066:	59 f4       	brne	.+22     	; 0x207e <free+0x82>
    2068:	88 81       	ld	r24, Y
    206a:	99 81       	ldd	r25, Y+1	; 0x01
    206c:	84 0f       	add	r24, r20
    206e:	95 1f       	adc	r25, r21
    2070:	02 96       	adiw	r24, 0x02	; 2
    2072:	91 83       	std	Z+1, r25	; 0x01
    2074:	80 83       	st	Z, r24
    2076:	8a 81       	ldd	r24, Y+2	; 0x02
    2078:	9b 81       	ldd	r25, Y+3	; 0x03
    207a:	93 83       	std	Z+3, r25	; 0x03
    207c:	82 83       	std	Z+2, r24	; 0x02
    207e:	21 15       	cp	r18, r1
    2080:	31 05       	cpc	r19, r1
    2082:	29 f4       	brne	.+10     	; 0x208e <free+0x92>
    2084:	f0 93 9f 07 	sts	0x079F, r31	; 0x80079f <__flp+0x1>
    2088:	e0 93 9e 07 	sts	0x079E, r30	; 0x80079e <__flp>
    208c:	3d c0       	rjmp	.+122    	; 0x2108 <free+0x10c>
    208e:	e9 01       	movw	r28, r18
    2090:	fb 83       	std	Y+3, r31	; 0x03
    2092:	ea 83       	std	Y+2, r30	; 0x02
    2094:	49 91       	ld	r20, Y+
    2096:	59 91       	ld	r21, Y+
    2098:	c4 0f       	add	r28, r20
    209a:	d5 1f       	adc	r29, r21
    209c:	ec 17       	cp	r30, r28
    209e:	fd 07       	cpc	r31, r29
    20a0:	61 f4       	brne	.+24     	; 0x20ba <free+0xbe>
    20a2:	80 81       	ld	r24, Z
    20a4:	91 81       	ldd	r25, Z+1	; 0x01
    20a6:	84 0f       	add	r24, r20
    20a8:	95 1f       	adc	r25, r21
    20aa:	02 96       	adiw	r24, 0x02	; 2
    20ac:	e9 01       	movw	r28, r18
    20ae:	99 83       	std	Y+1, r25	; 0x01
    20b0:	88 83       	st	Y, r24
    20b2:	82 81       	ldd	r24, Z+2	; 0x02
    20b4:	93 81       	ldd	r25, Z+3	; 0x03
    20b6:	9b 83       	std	Y+3, r25	; 0x03
    20b8:	8a 83       	std	Y+2, r24	; 0x02
    20ba:	e0 e0       	ldi	r30, 0x00	; 0
    20bc:	f0 e0       	ldi	r31, 0x00	; 0
    20be:	12 96       	adiw	r26, 0x02	; 2
    20c0:	8d 91       	ld	r24, X+
    20c2:	9c 91       	ld	r25, X
    20c4:	13 97       	sbiw	r26, 0x03	; 3
    20c6:	00 97       	sbiw	r24, 0x00	; 0
    20c8:	19 f0       	breq	.+6      	; 0x20d0 <free+0xd4>
    20ca:	fd 01       	movw	r30, r26
    20cc:	dc 01       	movw	r26, r24
    20ce:	f7 cf       	rjmp	.-18     	; 0x20be <free+0xc2>
    20d0:	8d 91       	ld	r24, X+
    20d2:	9c 91       	ld	r25, X
    20d4:	11 97       	sbiw	r26, 0x01	; 1
    20d6:	9d 01       	movw	r18, r26
    20d8:	2e 5f       	subi	r18, 0xFE	; 254
    20da:	3f 4f       	sbci	r19, 0xFF	; 255
    20dc:	82 0f       	add	r24, r18
    20de:	93 1f       	adc	r25, r19
    20e0:	20 91 9c 07 	lds	r18, 0x079C	; 0x80079c <__brkval>
    20e4:	30 91 9d 07 	lds	r19, 0x079D	; 0x80079d <__brkval+0x1>
    20e8:	28 17       	cp	r18, r24
    20ea:	39 07       	cpc	r19, r25
    20ec:	69 f4       	brne	.+26     	; 0x2108 <free+0x10c>
    20ee:	30 97       	sbiw	r30, 0x00	; 0
    20f0:	29 f4       	brne	.+10     	; 0x20fc <free+0x100>
    20f2:	10 92 9f 07 	sts	0x079F, r1	; 0x80079f <__flp+0x1>
    20f6:	10 92 9e 07 	sts	0x079E, r1	; 0x80079e <__flp>
    20fa:	02 c0       	rjmp	.+4      	; 0x2100 <free+0x104>
    20fc:	13 82       	std	Z+3, r1	; 0x03
    20fe:	12 82       	std	Z+2, r1	; 0x02
    2100:	b0 93 9d 07 	sts	0x079D, r27	; 0x80079d <__brkval+0x1>
    2104:	a0 93 9c 07 	sts	0x079C, r26	; 0x80079c <__brkval>
    2108:	df 91       	pop	r29
    210a:	cf 91       	pop	r28
    210c:	08 95       	ret

0000210e <do_rand>:
    210e:	8f 92       	push	r8
    2110:	9f 92       	push	r9
    2112:	af 92       	push	r10
    2114:	bf 92       	push	r11
    2116:	cf 92       	push	r12
    2118:	df 92       	push	r13
    211a:	ef 92       	push	r14
    211c:	ff 92       	push	r15
    211e:	cf 93       	push	r28
    2120:	df 93       	push	r29
    2122:	ec 01       	movw	r28, r24
    2124:	68 81       	ld	r22, Y
    2126:	79 81       	ldd	r23, Y+1	; 0x01
    2128:	8a 81       	ldd	r24, Y+2	; 0x02
    212a:	9b 81       	ldd	r25, Y+3	; 0x03
    212c:	61 15       	cp	r22, r1
    212e:	71 05       	cpc	r23, r1
    2130:	81 05       	cpc	r24, r1
    2132:	91 05       	cpc	r25, r1
    2134:	21 f4       	brne	.+8      	; 0x213e <do_rand+0x30>
    2136:	64 e2       	ldi	r22, 0x24	; 36
    2138:	79 ed       	ldi	r23, 0xD9	; 217
    213a:	8b e5       	ldi	r24, 0x5B	; 91
    213c:	97 e0       	ldi	r25, 0x07	; 7
    213e:	2d e1       	ldi	r18, 0x1D	; 29
    2140:	33 ef       	ldi	r19, 0xF3	; 243
    2142:	41 e0       	ldi	r20, 0x01	; 1
    2144:	50 e0       	ldi	r21, 0x00	; 0
    2146:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <__divmodsi4>
    214a:	49 01       	movw	r8, r18
    214c:	5a 01       	movw	r10, r20
    214e:	9b 01       	movw	r18, r22
    2150:	ac 01       	movw	r20, r24
    2152:	a7 ea       	ldi	r26, 0xA7	; 167
    2154:	b1 e4       	ldi	r27, 0x41	; 65
    2156:	0e 94 12 11 	call	0x2224	; 0x2224 <__muluhisi3>
    215a:	6b 01       	movw	r12, r22
    215c:	7c 01       	movw	r14, r24
    215e:	ac ee       	ldi	r26, 0xEC	; 236
    2160:	b4 ef       	ldi	r27, 0xF4	; 244
    2162:	a5 01       	movw	r20, r10
    2164:	94 01       	movw	r18, r8
    2166:	0e 94 20 11 	call	0x2240	; 0x2240 <__mulohisi3>
    216a:	dc 01       	movw	r26, r24
    216c:	cb 01       	movw	r24, r22
    216e:	8c 0d       	add	r24, r12
    2170:	9d 1d       	adc	r25, r13
    2172:	ae 1d       	adc	r26, r14
    2174:	bf 1d       	adc	r27, r15
    2176:	b7 ff       	sbrs	r27, 7
    2178:	03 c0       	rjmp	.+6      	; 0x2180 <do_rand+0x72>
    217a:	01 97       	sbiw	r24, 0x01	; 1
    217c:	a1 09       	sbc	r26, r1
    217e:	b0 48       	sbci	r27, 0x80	; 128
    2180:	88 83       	st	Y, r24
    2182:	99 83       	std	Y+1, r25	; 0x01
    2184:	aa 83       	std	Y+2, r26	; 0x02
    2186:	bb 83       	std	Y+3, r27	; 0x03
    2188:	9f 77       	andi	r25, 0x7F	; 127
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	ff 90       	pop	r15
    2190:	ef 90       	pop	r14
    2192:	df 90       	pop	r13
    2194:	cf 90       	pop	r12
    2196:	bf 90       	pop	r11
    2198:	af 90       	pop	r10
    219a:	9f 90       	pop	r9
    219c:	8f 90       	pop	r8
    219e:	08 95       	ret

000021a0 <rand_r>:
    21a0:	0e 94 87 10 	call	0x210e	; 0x210e <do_rand>
    21a4:	08 95       	ret

000021a6 <rand>:
    21a6:	86 e0       	ldi	r24, 0x06	; 6
    21a8:	91 e0       	ldi	r25, 0x01	; 1
    21aa:	0e 94 87 10 	call	0x210e	; 0x210e <do_rand>
    21ae:	08 95       	ret

000021b0 <srand>:
    21b0:	a0 e0       	ldi	r26, 0x00	; 0
    21b2:	b0 e0       	ldi	r27, 0x00	; 0
    21b4:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <next>
    21b8:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <next+0x1>
    21bc:	a0 93 08 01 	sts	0x0108, r26	; 0x800108 <next+0x2>
    21c0:	b0 93 09 01 	sts	0x0109, r27	; 0x800109 <next+0x3>
    21c4:	08 95       	ret

000021c6 <memcpy>:
    21c6:	fb 01       	movw	r30, r22
    21c8:	dc 01       	movw	r26, r24
    21ca:	02 c0       	rjmp	.+4      	; 0x21d0 <memcpy+0xa>
    21cc:	01 90       	ld	r0, Z+
    21ce:	0d 92       	st	X+, r0
    21d0:	41 50       	subi	r20, 0x01	; 1
    21d2:	50 40       	sbci	r21, 0x00	; 0
    21d4:	d8 f7       	brcc	.-10     	; 0x21cc <memcpy+0x6>
    21d6:	08 95       	ret

000021d8 <memset>:
    21d8:	dc 01       	movw	r26, r24
    21da:	01 c0       	rjmp	.+2      	; 0x21de <memset+0x6>
    21dc:	6d 93       	st	X+, r22
    21de:	41 50       	subi	r20, 0x01	; 1
    21e0:	50 40       	sbci	r21, 0x00	; 0
    21e2:	e0 f7       	brcc	.-8      	; 0x21dc <memset+0x4>
    21e4:	08 95       	ret

000021e6 <__divmodsi4>:
    21e6:	05 2e       	mov	r0, r21
    21e8:	97 fb       	bst	r25, 7
    21ea:	1e f4       	brtc	.+6      	; 0x21f2 <__divmodsi4+0xc>
    21ec:	00 94       	com	r0
    21ee:	0e 94 0a 11 	call	0x2214	; 0x2214 <__negsi2>
    21f2:	57 fd       	sbrc	r21, 7
    21f4:	07 d0       	rcall	.+14     	; 0x2204 <__divmodsi4_neg2>
    21f6:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <__udivmodsi4>
    21fa:	07 fc       	sbrc	r0, 7
    21fc:	03 d0       	rcall	.+6      	; 0x2204 <__divmodsi4_neg2>
    21fe:	4e f4       	brtc	.+18     	; 0x2212 <__divmodsi4_exit>
    2200:	0c 94 0a 11 	jmp	0x2214	; 0x2214 <__negsi2>

00002204 <__divmodsi4_neg2>:
    2204:	50 95       	com	r21
    2206:	40 95       	com	r20
    2208:	30 95       	com	r19
    220a:	21 95       	neg	r18
    220c:	3f 4f       	sbci	r19, 0xFF	; 255
    220e:	4f 4f       	sbci	r20, 0xFF	; 255
    2210:	5f 4f       	sbci	r21, 0xFF	; 255

00002212 <__divmodsi4_exit>:
    2212:	08 95       	ret

00002214 <__negsi2>:
    2214:	90 95       	com	r25
    2216:	80 95       	com	r24
    2218:	70 95       	com	r23
    221a:	61 95       	neg	r22
    221c:	7f 4f       	sbci	r23, 0xFF	; 255
    221e:	8f 4f       	sbci	r24, 0xFF	; 255
    2220:	9f 4f       	sbci	r25, 0xFF	; 255
    2222:	08 95       	ret

00002224 <__muluhisi3>:
    2224:	0e 94 25 11 	call	0x224a	; 0x224a <__umulhisi3>
    2228:	a5 9f       	mul	r26, r21
    222a:	90 0d       	add	r25, r0
    222c:	b4 9f       	mul	r27, r20
    222e:	90 0d       	add	r25, r0
    2230:	a4 9f       	mul	r26, r20
    2232:	80 0d       	add	r24, r0
    2234:	91 1d       	adc	r25, r1
    2236:	11 24       	eor	r1, r1
    2238:	08 95       	ret

0000223a <__mulshisi3>:
    223a:	b7 ff       	sbrs	r27, 7
    223c:	0c 94 12 11 	jmp	0x2224	; 0x2224 <__muluhisi3>

00002240 <__mulohisi3>:
    2240:	0e 94 12 11 	call	0x2224	; 0x2224 <__muluhisi3>
    2244:	82 1b       	sub	r24, r18
    2246:	93 0b       	sbc	r25, r19
    2248:	08 95       	ret

0000224a <__umulhisi3>:
    224a:	a2 9f       	mul	r26, r18
    224c:	b0 01       	movw	r22, r0
    224e:	b3 9f       	mul	r27, r19
    2250:	c0 01       	movw	r24, r0
    2252:	a3 9f       	mul	r26, r19
    2254:	70 0d       	add	r23, r0
    2256:	81 1d       	adc	r24, r1
    2258:	11 24       	eor	r1, r1
    225a:	91 1d       	adc	r25, r1
    225c:	b2 9f       	mul	r27, r18
    225e:	70 0d       	add	r23, r0
    2260:	81 1d       	adc	r24, r1
    2262:	11 24       	eor	r1, r1
    2264:	91 1d       	adc	r25, r1
    2266:	08 95       	ret

00002268 <_exit>:
    2268:	f8 94       	cli

0000226a <__stop_program>:
    226a:	ff cf       	rjmp	.-2      	; 0x226a <__stop_program>
